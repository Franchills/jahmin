
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var app = (function () {
    'use strict';

    function noop() { }
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    let src_url_equal_anchor;
    function src_url_equal(element_src, url) {
        if (!src_url_equal_anchor) {
            src_url_equal_anchor = document.createElement('a');
        }
        src_url_equal_anchor.href = url;
        return element_src === src_url_equal_anchor.href;
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
        if (slot_changes) {
            const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
            slot.p(slot_context, slot_changes);
        }
    }
    function get_all_dirty_from_scope($$scope) {
        if ($$scope.ctx.length > 32) {
            const dirty = [];
            const length = $$scope.ctx.length / 32;
            for (let i = 0; i < length; i++) {
                dirty[i] = -1;
            }
            return dirty;
        }
        return -1;
    }
    function null_to_empty(value) {
        return value == null ? '' : value;
    }
    function set_store_value(store, ret, value) {
        store.set(value);
        return ret;
    }
    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function set_custom_element_data(node, prop, value) {
        if (prop in node) {
            node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;
        }
        else {
            attr(node, prop, value);
        }
    }
    function to_number(value) {
        return value === '' ? null : +value;
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
        if (value === null) {
            node.style.removeProperty(key);
        }
        else {
            node.style.setProperty(key, value, important ? 'important' : '');
        }
    }
    function select_option(select, value) {
        for (let i = 0; i < select.options.length; i += 1) {
            const option = select.options[i];
            if (option.__value === value) {
                option.selected = true;
                return;
            }
        }
        select.selectedIndex = -1; // no option should be selected
    }
    function select_value(select) {
        const selected_option = select.querySelector(':checked') || select.options[0];
        return selected_option && selected_option.__value;
    }
    function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, bubbles, cancelable, detail);
        return e;
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail, { cancelable = false } = {}) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail, { cancelable });
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
                return !event.defaultPrevented;
            }
            return true;
        };
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    // flush() calls callbacks in this order:
    // 1. All beforeUpdate callbacks, in order: parents before children
    // 2. All bind:this callbacks, in reverse order: children before parents.
    // 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
    //    for afterUpdates called during the initial onMount, which are called in
    //    reverse order: children before parents.
    // Since callbacks might update component values, which could trigger another
    // call to flush(), the following steps guard against this:
    // 1. During beforeUpdate, any updated components will be added to the
    //    dirty_components array and will cause a reentrant call to flush(). Because
    //    the flush index is kept outside the function, the reentrant call will pick
    //    up where the earlier call left off and go through all dirty components. The
    //    current_component value is saved and restored so that the reentrant call will
    //    not interfere with the "parent" flush() call.
    // 2. bind:this callbacks cannot trigger new flush() calls.
    // 3. During afterUpdate, any updated components will NOT have their afterUpdate
    //    callback called a second time; the seen_callbacks set, outside the flush()
    //    function, guarantees this behavior.
    const seen_callbacks = new Set();
    let flushidx = 0; // Do *not* move this inside the flush() function
    function flush() {
        const saved_component = current_component;
        do {
            // first, call beforeUpdate functions
            // and update components
            while (flushidx < dirty_components.length) {
                const component = dirty_components[flushidx];
                flushidx++;
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            flushidx = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        seen_callbacks.clear();
        set_current_component(saved_component);
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
        else if (callback) {
            callback();
        }
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);

    function destroy_block(block, lookup) {
        block.d(1);
        lookup.delete(block.key);
    }
    function outro_and_destroy_block(block, lookup) {
        transition_out(block, 1, 1, () => {
            lookup.delete(block.key);
        });
    }
    function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
        let o = old_blocks.length;
        let n = list.length;
        let i = o;
        const old_indexes = {};
        while (i--)
            old_indexes[old_blocks[i].key] = i;
        const new_blocks = [];
        const new_lookup = new Map();
        const deltas = new Map();
        i = n;
        while (i--) {
            const child_ctx = get_context(ctx, list, i);
            const key = get_key(child_ctx);
            let block = lookup.get(key);
            if (!block) {
                block = create_each_block(key, child_ctx);
                block.c();
            }
            else if (dynamic) {
                block.p(child_ctx, dirty);
            }
            new_lookup.set(key, new_blocks[i] = block);
            if (key in old_indexes)
                deltas.set(key, Math.abs(i - old_indexes[key]));
        }
        const will_move = new Set();
        const did_move = new Set();
        function insert(block) {
            transition_in(block, 1);
            block.m(node, next);
            lookup.set(block.key, block);
            next = block.first;
            n--;
        }
        while (o && n) {
            const new_block = new_blocks[n - 1];
            const old_block = old_blocks[o - 1];
            const new_key = new_block.key;
            const old_key = old_block.key;
            if (new_block === old_block) {
                // do nothing
                next = new_block.first;
                o--;
                n--;
            }
            else if (!new_lookup.has(old_key)) {
                // remove old block
                destroy(old_block, lookup);
                o--;
            }
            else if (!lookup.has(new_key) || will_move.has(new_key)) {
                insert(new_block);
            }
            else if (did_move.has(old_key)) {
                o--;
            }
            else if (deltas.get(new_key) > deltas.get(old_key)) {
                did_move.add(new_key);
                insert(new_block);
            }
            else {
                will_move.add(old_key);
                o--;
            }
        }
        while (o--) {
            const old_block = old_blocks[o];
            if (!new_lookup.has(old_block.key))
                destroy(old_block, lookup);
        }
        while (n)
            insert(new_blocks[n - 1]);
        return new_blocks;
    }
    function validate_each_keys(ctx, list, get_context, get_key) {
        const keys = new Set();
        for (let i = 0; i < list.length; i++) {
            const key = get_key(get_context(ctx, list, i));
            if (keys.has(key)) {
                throw new Error('Cannot have duplicate keys in a keyed each');
            }
            keys.add(key);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = on_mount.map(run).filter(is_function);
                if (on_destroy) {
                    on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false,
            root: options.target || parent_component.$$.root
        };
        append_styles && append_styles($$.root);
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.49.0' }, detail), { bubbles: true }));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev('SvelteDOMSetProperty', { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    /*
     * Dexie.js - a minimalistic wrapper for IndexedDB
     * ===============================================
     *
     * By David Fahlander, david.fahlander@gmail.com
     *
     * Version 3.2.2, Wed Apr 27 2022
     *
     * https://dexie.org
     *
     * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/
     */
     
    const _global = typeof globalThis !== 'undefined' ? globalThis :
        typeof self !== 'undefined' ? self :
            typeof window !== 'undefined' ? window :
                global;

    const keys = Object.keys;
    const isArray$1 = Array.isArray;
    if (typeof Promise !== 'undefined' && !_global.Promise) {
        _global.Promise = Promise;
    }
    function extend$1(obj, extension) {
        if (typeof extension !== 'object')
            return obj;
        keys(extension).forEach(function (key) {
            obj[key] = extension[key];
        });
        return obj;
    }
    const getProto = Object.getPrototypeOf;
    const _hasOwn = {}.hasOwnProperty;
    function hasOwn$1(obj, prop) {
        return _hasOwn.call(obj, prop);
    }
    function props(proto, extension) {
        if (typeof extension === 'function')
            extension = extension(getProto(proto));
        (typeof Reflect === "undefined" ? keys : Reflect.ownKeys)(extension).forEach(key => {
            setProp(proto, key, extension[key]);
        });
    }
    const defineProperty = Object.defineProperty;
    function setProp(obj, prop, functionOrGetSet, options) {
        defineProperty(obj, prop, extend$1(functionOrGetSet && hasOwn$1(functionOrGetSet, "get") && typeof functionOrGetSet.get === 'function' ?
            { get: functionOrGetSet.get, set: functionOrGetSet.set, configurable: true } :
            { value: functionOrGetSet, configurable: true, writable: true }, options));
    }
    function derive(Child) {
        return {
            from: function (Parent) {
                Child.prototype = Object.create(Parent.prototype);
                setProp(Child.prototype, "constructor", Child);
                return {
                    extend: props.bind(null, Child.prototype)
                };
            }
        };
    }
    const getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    function getPropertyDescriptor(obj, prop) {
        const pd = getOwnPropertyDescriptor(obj, prop);
        let proto;
        return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);
    }
    const _slice = [].slice;
    function slice(args, start, end) {
        return _slice.call(args, start, end);
    }
    function override(origFunc, overridedFactory) {
        return overridedFactory(origFunc);
    }
    function assert(b) {
        if (!b)
            throw new Error("Assertion Failed");
    }
    function asap$1(fn) {
        if (_global.setImmediate)
            setImmediate(fn);
        else
            setTimeout(fn, 0);
    }
    function arrayToObject(array, extractor) {
        return array.reduce((result, item, i) => {
            var nameAndValue = extractor(item, i);
            if (nameAndValue)
                result[nameAndValue[0]] = nameAndValue[1];
            return result;
        }, {});
    }
    function tryCatch(fn, onerror, args) {
        try {
            fn.apply(null, args);
        }
        catch (ex) {
            onerror && onerror(ex);
        }
    }
    function getByKeyPath(obj, keyPath) {
        if (hasOwn$1(obj, keyPath))
            return obj[keyPath];
        if (!keyPath)
            return obj;
        if (typeof keyPath !== 'string') {
            var rv = [];
            for (var i = 0, l = keyPath.length; i < l; ++i) {
                var val = getByKeyPath(obj, keyPath[i]);
                rv.push(val);
            }
            return rv;
        }
        var period = keyPath.indexOf('.');
        if (period !== -1) {
            var innerObj = obj[keyPath.substr(0, period)];
            return innerObj === undefined ? undefined : getByKeyPath(innerObj, keyPath.substr(period + 1));
        }
        return undefined;
    }
    function setByKeyPath(obj, keyPath, value) {
        if (!obj || keyPath === undefined)
            return;
        if ('isFrozen' in Object && Object.isFrozen(obj))
            return;
        if (typeof keyPath !== 'string' && 'length' in keyPath) {
            assert(typeof value !== 'string' && 'length' in value);
            for (var i = 0, l = keyPath.length; i < l; ++i) {
                setByKeyPath(obj, keyPath[i], value[i]);
            }
        }
        else {
            var period = keyPath.indexOf('.');
            if (period !== -1) {
                var currentKeyPath = keyPath.substr(0, period);
                var remainingKeyPath = keyPath.substr(period + 1);
                if (remainingKeyPath === "")
                    if (value === undefined) {
                        if (isArray$1(obj) && !isNaN(parseInt(currentKeyPath)))
                            obj.splice(currentKeyPath, 1);
                        else
                            delete obj[currentKeyPath];
                    }
                    else
                        obj[currentKeyPath] = value;
                else {
                    var innerObj = obj[currentKeyPath];
                    if (!innerObj || !hasOwn$1(obj, currentKeyPath))
                        innerObj = (obj[currentKeyPath] = {});
                    setByKeyPath(innerObj, remainingKeyPath, value);
                }
            }
            else {
                if (value === undefined) {
                    if (isArray$1(obj) && !isNaN(parseInt(keyPath)))
                        obj.splice(keyPath, 1);
                    else
                        delete obj[keyPath];
                }
                else
                    obj[keyPath] = value;
            }
        }
    }
    function delByKeyPath(obj, keyPath) {
        if (typeof keyPath === 'string')
            setByKeyPath(obj, keyPath, undefined);
        else if ('length' in keyPath)
            [].map.call(keyPath, function (kp) {
                setByKeyPath(obj, kp, undefined);
            });
    }
    function shallowClone(obj) {
        var rv = {};
        for (var m in obj) {
            if (hasOwn$1(obj, m))
                rv[m] = obj[m];
        }
        return rv;
    }
    const concat = [].concat;
    function flatten(a) {
        return concat.apply([], a);
    }
    const intrinsicTypeNames = "Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey"
        .split(',').concat(flatten([8, 16, 32, 64].map(num => ["Int", "Uint", "Float"].map(t => t + num + "Array")))).filter(t => _global[t]);
    const intrinsicTypes = intrinsicTypeNames.map(t => _global[t]);
    arrayToObject(intrinsicTypeNames, x => [x, true]);
    let circularRefs = null;
    function deepClone(any) {
        circularRefs = typeof WeakMap !== 'undefined' && new WeakMap();
        const rv = innerDeepClone(any);
        circularRefs = null;
        return rv;
    }
    function innerDeepClone(any) {
        if (!any || typeof any !== 'object')
            return any;
        let rv = circularRefs && circularRefs.get(any);
        if (rv)
            return rv;
        if (isArray$1(any)) {
            rv = [];
            circularRefs && circularRefs.set(any, rv);
            for (var i = 0, l = any.length; i < l; ++i) {
                rv.push(innerDeepClone(any[i]));
            }
        }
        else if (intrinsicTypes.indexOf(any.constructor) >= 0) {
            rv = any;
        }
        else {
            const proto = getProto(any);
            rv = proto === Object.prototype ? {} : Object.create(proto);
            circularRefs && circularRefs.set(any, rv);
            for (var prop in any) {
                if (hasOwn$1(any, prop)) {
                    rv[prop] = innerDeepClone(any[prop]);
                }
            }
        }
        return rv;
    }
    const { toString: toString$1 } = {};
    function toStringTag(o) {
        return toString$1.call(o).slice(8, -1);
    }
    const iteratorSymbol = typeof Symbol !== 'undefined' ?
        Symbol.iterator :
        '@@iterator';
    const getIteratorOf = typeof iteratorSymbol === "symbol" ? function (x) {
        var i;
        return x != null && (i = x[iteratorSymbol]) && i.apply(x);
    } : function () { return null; };
    const NO_CHAR_ARRAY = {};
    function getArrayOf(arrayLike) {
        var i, a, x, it;
        if (arguments.length === 1) {
            if (isArray$1(arrayLike))
                return arrayLike.slice();
            if (this === NO_CHAR_ARRAY && typeof arrayLike === 'string')
                return [arrayLike];
            if ((it = getIteratorOf(arrayLike))) {
                a = [];
                while ((x = it.next()), !x.done)
                    a.push(x.value);
                return a;
            }
            if (arrayLike == null)
                return [arrayLike];
            i = arrayLike.length;
            if (typeof i === 'number') {
                a = new Array(i);
                while (i--)
                    a[i] = arrayLike[i];
                return a;
            }
            return [arrayLike];
        }
        i = arguments.length;
        a = new Array(i);
        while (i--)
            a[i] = arguments[i];
        return a;
    }
    const isAsyncFunction = typeof Symbol !== 'undefined'
        ? (fn) => fn[Symbol.toStringTag] === 'AsyncFunction'
        : () => false;

    var debug = typeof location !== 'undefined' &&
        /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
    function setDebug(value, filter) {
        debug = value;
        libraryFilter = filter;
    }
    var libraryFilter = () => true;
    const NEEDS_THROW_FOR_STACK = !new Error("").stack;
    function getErrorWithStack() {
        if (NEEDS_THROW_FOR_STACK)
            try {
                getErrorWithStack.arguments;
                throw new Error();
            }
            catch (e) {
                return e;
            }
        return new Error();
    }
    function prettyStack(exception, numIgnoredFrames) {
        var stack = exception.stack;
        if (!stack)
            return "";
        numIgnoredFrames = (numIgnoredFrames || 0);
        if (stack.indexOf(exception.name) === 0)
            numIgnoredFrames += (exception.name + exception.message).split('\n').length;
        return stack.split('\n')
            .slice(numIgnoredFrames)
            .filter(libraryFilter)
            .map(frame => "\n" + frame)
            .join('');
    }

    var dexieErrorNames = [
        'Modify',
        'Bulk',
        'OpenFailed',
        'VersionChange',
        'Schema',
        'Upgrade',
        'InvalidTable',
        'MissingAPI',
        'NoSuchDatabase',
        'InvalidArgument',
        'SubTransaction',
        'Unsupported',
        'Internal',
        'DatabaseClosed',
        'PrematureCommit',
        'ForeignAwait'
    ];
    var idbDomErrorNames = [
        'Unknown',
        'Constraint',
        'Data',
        'TransactionInactive',
        'ReadOnly',
        'Version',
        'NotFound',
        'InvalidState',
        'InvalidAccess',
        'Abort',
        'Timeout',
        'QuotaExceeded',
        'Syntax',
        'DataClone'
    ];
    var errorList = dexieErrorNames.concat(idbDomErrorNames);
    var defaultTexts = {
        VersionChanged: "Database version changed by other database connection",
        DatabaseClosed: "Database has been closed",
        Abort: "Transaction aborted",
        TransactionInactive: "Transaction has already completed or failed",
        MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb"
    };
    function DexieError(name, msg) {
        this._e = getErrorWithStack();
        this.name = name;
        this.message = msg;
    }
    derive(DexieError).from(Error).extend({
        stack: {
            get: function () {
                return this._stack ||
                    (this._stack = this.name + ": " + this.message + prettyStack(this._e, 2));
            }
        },
        toString: function () { return this.name + ": " + this.message; }
    });
    function getMultiErrorMessage(msg, failures) {
        return msg + ". Errors: " + Object.keys(failures)
            .map(key => failures[key].toString())
            .filter((v, i, s) => s.indexOf(v) === i)
            .join('\n');
    }
    function ModifyError(msg, failures, successCount, failedKeys) {
        this._e = getErrorWithStack();
        this.failures = failures;
        this.failedKeys = failedKeys;
        this.successCount = successCount;
        this.message = getMultiErrorMessage(msg, failures);
    }
    derive(ModifyError).from(DexieError);
    function BulkError(msg, failures) {
        this._e = getErrorWithStack();
        this.name = "BulkError";
        this.failures = Object.keys(failures).map(pos => failures[pos]);
        this.failuresByPos = failures;
        this.message = getMultiErrorMessage(msg, failures);
    }
    derive(BulkError).from(DexieError);
    var errnames = errorList.reduce((obj, name) => (obj[name] = name + "Error", obj), {});
    const BaseException = DexieError;
    var exceptions = errorList.reduce((obj, name) => {
        var fullName = name + "Error";
        function DexieError(msgOrInner, inner) {
            this._e = getErrorWithStack();
            this.name = fullName;
            if (!msgOrInner) {
                this.message = defaultTexts[name] || fullName;
                this.inner = null;
            }
            else if (typeof msgOrInner === 'string') {
                this.message = `${msgOrInner}${!inner ? '' : '\n ' + inner}`;
                this.inner = inner || null;
            }
            else if (typeof msgOrInner === 'object') {
                this.message = `${msgOrInner.name} ${msgOrInner.message}`;
                this.inner = msgOrInner;
            }
        }
        derive(DexieError).from(BaseException);
        obj[name] = DexieError;
        return obj;
    }, {});
    exceptions.Syntax = SyntaxError;
    exceptions.Type = TypeError;
    exceptions.Range = RangeError;
    var exceptionMap = idbDomErrorNames.reduce((obj, name) => {
        obj[name + "Error"] = exceptions[name];
        return obj;
    }, {});
    function mapError(domError, message) {
        if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name])
            return domError;
        var rv = new exceptionMap[domError.name](message || domError.message, domError);
        if ("stack" in domError) {
            setProp(rv, "stack", { get: function () {
                    return this.inner.stack;
                } });
        }
        return rv;
    }
    var fullNameExceptions = errorList.reduce((obj, name) => {
        if (["Syntax", "Type", "Range"].indexOf(name) === -1)
            obj[name + "Error"] = exceptions[name];
        return obj;
    }, {});
    fullNameExceptions.ModifyError = ModifyError;
    fullNameExceptions.DexieError = DexieError;
    fullNameExceptions.BulkError = BulkError;

    function nop() { }
    function mirror(val) { return val; }
    function pureFunctionChain(f1, f2) {
        if (f1 == null || f1 === mirror)
            return f2;
        return function (val) {
            return f2(f1(val));
        };
    }
    function callBoth(on1, on2) {
        return function () {
            on1.apply(this, arguments);
            on2.apply(this, arguments);
        };
    }
    function hookCreatingChain(f1, f2) {
        if (f1 === nop)
            return f2;
        return function () {
            var res = f1.apply(this, arguments);
            if (res !== undefined)
                arguments[0] = res;
            var onsuccess = this.onsuccess,
            onerror = this.onerror;
            this.onsuccess = null;
            this.onerror = null;
            var res2 = f2.apply(this, arguments);
            if (onsuccess)
                this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
            if (onerror)
                this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
            return res2 !== undefined ? res2 : res;
        };
    }
    function hookDeletingChain(f1, f2) {
        if (f1 === nop)
            return f2;
        return function () {
            f1.apply(this, arguments);
            var onsuccess = this.onsuccess,
            onerror = this.onerror;
            this.onsuccess = this.onerror = null;
            f2.apply(this, arguments);
            if (onsuccess)
                this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
            if (onerror)
                this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
        };
    }
    function hookUpdatingChain(f1, f2) {
        if (f1 === nop)
            return f2;
        return function (modifications) {
            var res = f1.apply(this, arguments);
            extend$1(modifications, res);
            var onsuccess = this.onsuccess,
            onerror = this.onerror;
            this.onsuccess = null;
            this.onerror = null;
            var res2 = f2.apply(this, arguments);
            if (onsuccess)
                this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
            if (onerror)
                this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
            return res === undefined ?
                (res2 === undefined ? undefined : res2) :
                (extend$1(res, res2));
        };
    }
    function reverseStoppableEventChain(f1, f2) {
        if (f1 === nop)
            return f2;
        return function () {
            if (f2.apply(this, arguments) === false)
                return false;
            return f1.apply(this, arguments);
        };
    }
    function promisableChain(f1, f2) {
        if (f1 === nop)
            return f2;
        return function () {
            var res = f1.apply(this, arguments);
            if (res && typeof res.then === 'function') {
                var thiz = this, i = arguments.length, args = new Array(i);
                while (i--)
                    args[i] = arguments[i];
                return res.then(function () {
                    return f2.apply(thiz, args);
                });
            }
            return f2.apply(this, arguments);
        };
    }

    var INTERNAL = {};
    const LONG_STACKS_CLIP_LIMIT = 100,
    MAX_LONG_STACKS = 20, ZONE_ECHO_LIMIT = 100, [resolvedNativePromise, nativePromiseProto, resolvedGlobalPromise] = typeof Promise === 'undefined' ?
        [] :
        (() => {
            let globalP = Promise.resolve();
            if (typeof crypto === 'undefined' || !crypto.subtle)
                return [globalP, getProto(globalP), globalP];
            const nativeP = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
            return [
                nativeP,
                getProto(nativeP),
                globalP
            ];
        })(), nativePromiseThen = nativePromiseProto && nativePromiseProto.then;
    const NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;
    const patchGlobalPromise = !!resolvedGlobalPromise;
    var stack_being_generated = false;
    var schedulePhysicalTick = resolvedGlobalPromise ?
        () => { resolvedGlobalPromise.then(physicalTick); }
        :
            _global.setImmediate ?
                setImmediate.bind(null, physicalTick) :
                _global.MutationObserver ?
                    () => {
                        var hiddenDiv = document.createElement("div");
                        (new MutationObserver(() => {
                            physicalTick();
                            hiddenDiv = null;
                        })).observe(hiddenDiv, { attributes: true });
                        hiddenDiv.setAttribute('i', '1');
                    } :
                    () => { setTimeout(physicalTick, 0); };
    var asap = function (callback, args) {
        microtickQueue.push([callback, args]);
        if (needsNewPhysicalTick) {
            schedulePhysicalTick();
            needsNewPhysicalTick = false;
        }
    };
    var isOutsideMicroTick = true,
    needsNewPhysicalTick = true,
    unhandledErrors = [],
    rejectingErrors = [],
    currentFulfiller = null, rejectionMapper = mirror;
    var globalPSD = {
        id: 'global',
        global: true,
        ref: 0,
        unhandleds: [],
        onunhandled: globalError,
        pgp: false,
        env: {},
        finalize: function () {
            this.unhandleds.forEach(uh => {
                try {
                    globalError(uh[0], uh[1]);
                }
                catch (e) { }
            });
        }
    };
    var PSD = globalPSD;
    var microtickQueue = [];
    var numScheduledCalls = 0;
    var tickFinalizers = [];
    function DexiePromise(fn) {
        if (typeof this !== 'object')
            throw new TypeError('Promises must be constructed via new');
        this._listeners = [];
        this.onuncatched = nop;
        this._lib = false;
        var psd = (this._PSD = PSD);
        if (debug) {
            this._stackHolder = getErrorWithStack();
            this._prev = null;
            this._numPrev = 0;
        }
        if (typeof fn !== 'function') {
            if (fn !== INTERNAL)
                throw new TypeError('Not a function');
            this._state = arguments[1];
            this._value = arguments[2];
            if (this._state === false)
                handleRejection(this, this._value);
            return;
        }
        this._state = null;
        this._value = null;
        ++psd.ref;
        executePromiseTask(this, fn);
    }
    const thenProp = {
        get: function () {
            var psd = PSD, microTaskId = totalEchoes;
            function then(onFulfilled, onRejected) {
                var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);
                const cleanup = possibleAwait && !decrementExpectedAwaits();
                var rv = new DexiePromise((resolve, reject) => {
                    propagateToListener(this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));
                });
                debug && linkToPreviousPromise(rv, this);
                return rv;
            }
            then.prototype = INTERNAL;
            return then;
        },
        set: function (value) {
            setProp(this, 'then', value && value.prototype === INTERNAL ?
                thenProp :
                {
                    get: function () {
                        return value;
                    },
                    set: thenProp.set
                });
        }
    };
    props(DexiePromise.prototype, {
        then: thenProp,
        _then: function (onFulfilled, onRejected) {
            propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));
        },
        catch: function (onRejected) {
            if (arguments.length === 1)
                return this.then(null, onRejected);
            var type = arguments[0], handler = arguments[1];
            return typeof type === 'function' ? this.then(null, err =>
            err instanceof type ? handler(err) : PromiseReject(err))
                : this.then(null, err =>
                err && err.name === type ? handler(err) : PromiseReject(err));
        },
        finally: function (onFinally) {
            return this.then(value => {
                onFinally();
                return value;
            }, err => {
                onFinally();
                return PromiseReject(err);
            });
        },
        stack: {
            get: function () {
                if (this._stack)
                    return this._stack;
                try {
                    stack_being_generated = true;
                    var stacks = getStack(this, [], MAX_LONG_STACKS);
                    var stack = stacks.join("\nFrom previous: ");
                    if (this._state !== null)
                        this._stack = stack;
                    return stack;
                }
                finally {
                    stack_being_generated = false;
                }
            }
        },
        timeout: function (ms, msg) {
            return ms < Infinity ?
                new DexiePromise((resolve, reject) => {
                    var handle = setTimeout(() => reject(new exceptions.Timeout(msg)), ms);
                    this.then(resolve, reject).finally(clearTimeout.bind(null, handle));
                }) : this;
        }
    });
    if (typeof Symbol !== 'undefined' && Symbol.toStringTag)
        setProp(DexiePromise.prototype, Symbol.toStringTag, 'Dexie.Promise');
    globalPSD.env = snapShot();
    function Listener(onFulfilled, onRejected, resolve, reject, zone) {
        this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
        this.onRejected = typeof onRejected === 'function' ? onRejected : null;
        this.resolve = resolve;
        this.reject = reject;
        this.psd = zone;
    }
    props(DexiePromise, {
        all: function () {
            var values = getArrayOf.apply(null, arguments)
                .map(onPossibleParallellAsync);
            return new DexiePromise(function (resolve, reject) {
                if (values.length === 0)
                    resolve([]);
                var remaining = values.length;
                values.forEach((a, i) => DexiePromise.resolve(a).then(x => {
                    values[i] = x;
                    if (!--remaining)
                        resolve(values);
                }, reject));
            });
        },
        resolve: value => {
            if (value instanceof DexiePromise)
                return value;
            if (value && typeof value.then === 'function')
                return new DexiePromise((resolve, reject) => {
                    value.then(resolve, reject);
                });
            var rv = new DexiePromise(INTERNAL, true, value);
            linkToPreviousPromise(rv, currentFulfiller);
            return rv;
        },
        reject: PromiseReject,
        race: function () {
            var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
            return new DexiePromise((resolve, reject) => {
                values.map(value => DexiePromise.resolve(value).then(resolve, reject));
            });
        },
        PSD: {
            get: () => PSD,
            set: value => PSD = value
        },
        totalEchoes: { get: () => totalEchoes },
        newPSD: newScope,
        usePSD: usePSD,
        scheduler: {
            get: () => asap,
            set: value => { asap = value; }
        },
        rejectionMapper: {
            get: () => rejectionMapper,
            set: value => { rejectionMapper = value; }
        },
        follow: (fn, zoneProps) => {
            return new DexiePromise((resolve, reject) => {
                return newScope((resolve, reject) => {
                    var psd = PSD;
                    psd.unhandleds = [];
                    psd.onunhandled = reject;
                    psd.finalize = callBoth(function () {
                        run_at_end_of_this_or_next_physical_tick(() => {
                            this.unhandleds.length === 0 ? resolve() : reject(this.unhandleds[0]);
                        });
                    }, psd.finalize);
                    fn();
                }, zoneProps, resolve, reject);
            });
        }
    });
    if (NativePromise) {
        if (NativePromise.allSettled)
            setProp(DexiePromise, "allSettled", function () {
                const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
                return new DexiePromise(resolve => {
                    if (possiblePromises.length === 0)
                        resolve([]);
                    let remaining = possiblePromises.length;
                    const results = new Array(remaining);
                    possiblePromises.forEach((p, i) => DexiePromise.resolve(p).then(value => results[i] = { status: "fulfilled", value }, reason => results[i] = { status: "rejected", reason })
                        .then(() => --remaining || resolve(results)));
                });
            });
        if (NativePromise.any && typeof AggregateError !== 'undefined')
            setProp(DexiePromise, "any", function () {
                const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
                return new DexiePromise((resolve, reject) => {
                    if (possiblePromises.length === 0)
                        reject(new AggregateError([]));
                    let remaining = possiblePromises.length;
                    const failures = new Array(remaining);
                    possiblePromises.forEach((p, i) => DexiePromise.resolve(p).then(value => resolve(value), failure => {
                        failures[i] = failure;
                        if (!--remaining)
                            reject(new AggregateError(failures));
                    }));
                });
            });
    }
    function executePromiseTask(promise, fn) {
        try {
            fn(value => {
                if (promise._state !== null)
                    return;
                if (value === promise)
                    throw new TypeError('A promise cannot be resolved with itself.');
                var shouldExecuteTick = promise._lib && beginMicroTickScope();
                if (value && typeof value.then === 'function') {
                    executePromiseTask(promise, (resolve, reject) => {
                        value instanceof DexiePromise ?
                            value._then(resolve, reject) :
                            value.then(resolve, reject);
                    });
                }
                else {
                    promise._state = true;
                    promise._value = value;
                    propagateAllListeners(promise);
                }
                if (shouldExecuteTick)
                    endMicroTickScope();
            }, handleRejection.bind(null, promise));
        }
        catch (ex) {
            handleRejection(promise, ex);
        }
    }
    function handleRejection(promise, reason) {
        rejectingErrors.push(reason);
        if (promise._state !== null)
            return;
        var shouldExecuteTick = promise._lib && beginMicroTickScope();
        reason = rejectionMapper(reason);
        promise._state = false;
        promise._value = reason;
        debug && reason !== null && typeof reason === 'object' && !reason._promise && tryCatch(() => {
            var origProp = getPropertyDescriptor(reason, "stack");
            reason._promise = promise;
            setProp(reason, "stack", {
                get: () => stack_being_generated ?
                    origProp && (origProp.get ?
                        origProp.get.apply(reason) :
                        origProp.value) :
                    promise.stack
            });
        });
        addPossiblyUnhandledError(promise);
        propagateAllListeners(promise);
        if (shouldExecuteTick)
            endMicroTickScope();
    }
    function propagateAllListeners(promise) {
        var listeners = promise._listeners;
        promise._listeners = [];
        for (var i = 0, len = listeners.length; i < len; ++i) {
            propagateToListener(promise, listeners[i]);
        }
        var psd = promise._PSD;
        --psd.ref || psd.finalize();
        if (numScheduledCalls === 0) {
            ++numScheduledCalls;
            asap(() => {
                if (--numScheduledCalls === 0)
                    finalizePhysicalTick();
            }, []);
        }
    }
    function propagateToListener(promise, listener) {
        if (promise._state === null) {
            promise._listeners.push(listener);
            return;
        }
        var cb = promise._state ? listener.onFulfilled : listener.onRejected;
        if (cb === null) {
            return (promise._state ? listener.resolve : listener.reject)(promise._value);
        }
        ++listener.psd.ref;
        ++numScheduledCalls;
        asap(callListener, [cb, promise, listener]);
    }
    function callListener(cb, promise, listener) {
        try {
            currentFulfiller = promise;
            var ret, value = promise._value;
            if (promise._state) {
                ret = cb(value);
            }
            else {
                if (rejectingErrors.length)
                    rejectingErrors = [];
                ret = cb(value);
                if (rejectingErrors.indexOf(value) === -1)
                    markErrorAsHandled(promise);
            }
            listener.resolve(ret);
        }
        catch (e) {
            listener.reject(e);
        }
        finally {
            currentFulfiller = null;
            if (--numScheduledCalls === 0)
                finalizePhysicalTick();
            --listener.psd.ref || listener.psd.finalize();
        }
    }
    function getStack(promise, stacks, limit) {
        if (stacks.length === limit)
            return stacks;
        var stack = "";
        if (promise._state === false) {
            var failure = promise._value, errorName, message;
            if (failure != null) {
                errorName = failure.name || "Error";
                message = failure.message || failure;
                stack = prettyStack(failure, 0);
            }
            else {
                errorName = failure;
                message = "";
            }
            stacks.push(errorName + (message ? ": " + message : "") + stack);
        }
        if (debug) {
            stack = prettyStack(promise._stackHolder, 2);
            if (stack && stacks.indexOf(stack) === -1)
                stacks.push(stack);
            if (promise._prev)
                getStack(promise._prev, stacks, limit);
        }
        return stacks;
    }
    function linkToPreviousPromise(promise, prev) {
        var numPrev = prev ? prev._numPrev + 1 : 0;
        if (numPrev < LONG_STACKS_CLIP_LIMIT) {
            promise._prev = prev;
            promise._numPrev = numPrev;
        }
    }
    function physicalTick() {
        beginMicroTickScope() && endMicroTickScope();
    }
    function beginMicroTickScope() {
        var wasRootExec = isOutsideMicroTick;
        isOutsideMicroTick = false;
        needsNewPhysicalTick = false;
        return wasRootExec;
    }
    function endMicroTickScope() {
        var callbacks, i, l;
        do {
            while (microtickQueue.length > 0) {
                callbacks = microtickQueue;
                microtickQueue = [];
                l = callbacks.length;
                for (i = 0; i < l; ++i) {
                    var item = callbacks[i];
                    item[0].apply(null, item[1]);
                }
            }
        } while (microtickQueue.length > 0);
        isOutsideMicroTick = true;
        needsNewPhysicalTick = true;
    }
    function finalizePhysicalTick() {
        var unhandledErrs = unhandledErrors;
        unhandledErrors = [];
        unhandledErrs.forEach(p => {
            p._PSD.onunhandled.call(null, p._value, p);
        });
        var finalizers = tickFinalizers.slice(0);
        var i = finalizers.length;
        while (i)
            finalizers[--i]();
    }
    function run_at_end_of_this_or_next_physical_tick(fn) {
        function finalizer() {
            fn();
            tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);
        }
        tickFinalizers.push(finalizer);
        ++numScheduledCalls;
        asap(() => {
            if (--numScheduledCalls === 0)
                finalizePhysicalTick();
        }, []);
    }
    function addPossiblyUnhandledError(promise) {
        if (!unhandledErrors.some(p => p._value === promise._value))
            unhandledErrors.push(promise);
    }
    function markErrorAsHandled(promise) {
        var i = unhandledErrors.length;
        while (i)
            if (unhandledErrors[--i]._value === promise._value) {
                unhandledErrors.splice(i, 1);
                return;
            }
    }
    function PromiseReject(reason) {
        return new DexiePromise(INTERNAL, false, reason);
    }
    function wrap(fn, errorCatcher) {
        var psd = PSD;
        return function () {
            var wasRootExec = beginMicroTickScope(), outerScope = PSD;
            try {
                switchToZone(psd, true);
                return fn.apply(this, arguments);
            }
            catch (e) {
                errorCatcher && errorCatcher(e);
            }
            finally {
                switchToZone(outerScope, false);
                if (wasRootExec)
                    endMicroTickScope();
            }
        };
    }
    const task = { awaits: 0, echoes: 0, id: 0 };
    var taskCounter = 0;
    var zoneStack = [];
    var zoneEchoes = 0;
    var totalEchoes = 0;
    var zone_id_counter = 0;
    function newScope(fn, props, a1, a2) {
        var parent = PSD, psd = Object.create(parent);
        psd.parent = parent;
        psd.ref = 0;
        psd.global = false;
        psd.id = ++zone_id_counter;
        var globalEnv = globalPSD.env;
        psd.env = patchGlobalPromise ? {
            Promise: DexiePromise,
            PromiseProp: { value: DexiePromise, configurable: true, writable: true },
            all: DexiePromise.all,
            race: DexiePromise.race,
            allSettled: DexiePromise.allSettled,
            any: DexiePromise.any,
            resolve: DexiePromise.resolve,
            reject: DexiePromise.reject,
            nthen: getPatchedPromiseThen(globalEnv.nthen, psd),
            gthen: getPatchedPromiseThen(globalEnv.gthen, psd)
        } : {};
        if (props)
            extend$1(psd, props);
        ++parent.ref;
        psd.finalize = function () {
            --this.parent.ref || this.parent.finalize();
        };
        var rv = usePSD(psd, fn, a1, a2);
        if (psd.ref === 0)
            psd.finalize();
        return rv;
    }
    function incrementExpectedAwaits() {
        if (!task.id)
            task.id = ++taskCounter;
        ++task.awaits;
        task.echoes += ZONE_ECHO_LIMIT;
        return task.id;
    }
    function decrementExpectedAwaits() {
        if (!task.awaits)
            return false;
        if (--task.awaits === 0)
            task.id = 0;
        task.echoes = task.awaits * ZONE_ECHO_LIMIT;
        return true;
    }
    if (('' + nativePromiseThen).indexOf('[native code]') === -1) {
        incrementExpectedAwaits = decrementExpectedAwaits = nop;
    }
    function onPossibleParallellAsync(possiblePromise) {
        if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {
            incrementExpectedAwaits();
            return possiblePromise.then(x => {
                decrementExpectedAwaits();
                return x;
            }, e => {
                decrementExpectedAwaits();
                return rejection(e);
            });
        }
        return possiblePromise;
    }
    function zoneEnterEcho(targetZone) {
        ++totalEchoes;
        if (!task.echoes || --task.echoes === 0) {
            task.echoes = task.id = 0;
        }
        zoneStack.push(PSD);
        switchToZone(targetZone, true);
    }
    function zoneLeaveEcho() {
        var zone = zoneStack[zoneStack.length - 1];
        zoneStack.pop();
        switchToZone(zone, false);
    }
    function switchToZone(targetZone, bEnteringZone) {
        var currentZone = PSD;
        if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {
            enqueueNativeMicroTask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);
        }
        if (targetZone === PSD)
            return;
        PSD = targetZone;
        if (currentZone === globalPSD)
            globalPSD.env = snapShot();
        if (patchGlobalPromise) {
            var GlobalPromise = globalPSD.env.Promise;
            var targetEnv = targetZone.env;
            nativePromiseProto.then = targetEnv.nthen;
            GlobalPromise.prototype.then = targetEnv.gthen;
            if (currentZone.global || targetZone.global) {
                Object.defineProperty(_global, 'Promise', targetEnv.PromiseProp);
                GlobalPromise.all = targetEnv.all;
                GlobalPromise.race = targetEnv.race;
                GlobalPromise.resolve = targetEnv.resolve;
                GlobalPromise.reject = targetEnv.reject;
                if (targetEnv.allSettled)
                    GlobalPromise.allSettled = targetEnv.allSettled;
                if (targetEnv.any)
                    GlobalPromise.any = targetEnv.any;
            }
        }
    }
    function snapShot() {
        var GlobalPromise = _global.Promise;
        return patchGlobalPromise ? {
            Promise: GlobalPromise,
            PromiseProp: Object.getOwnPropertyDescriptor(_global, "Promise"),
            all: GlobalPromise.all,
            race: GlobalPromise.race,
            allSettled: GlobalPromise.allSettled,
            any: GlobalPromise.any,
            resolve: GlobalPromise.resolve,
            reject: GlobalPromise.reject,
            nthen: nativePromiseProto.then,
            gthen: GlobalPromise.prototype.then
        } : {};
    }
    function usePSD(psd, fn, a1, a2, a3) {
        var outerScope = PSD;
        try {
            switchToZone(psd, true);
            return fn(a1, a2, a3);
        }
        finally {
            switchToZone(outerScope, false);
        }
    }
    function enqueueNativeMicroTask(job) {
        nativePromiseThen.call(resolvedNativePromise, job);
    }
    function nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {
        return typeof fn !== 'function' ? fn : function () {
            var outerZone = PSD;
            if (possibleAwait)
                incrementExpectedAwaits();
            switchToZone(zone, true);
            try {
                return fn.apply(this, arguments);
            }
            finally {
                switchToZone(outerZone, false);
                if (cleanup)
                    enqueueNativeMicroTask(decrementExpectedAwaits);
            }
        };
    }
    function getPatchedPromiseThen(origThen, zone) {
        return function (onResolved, onRejected) {
            return origThen.call(this, nativeAwaitCompatibleWrap(onResolved, zone), nativeAwaitCompatibleWrap(onRejected, zone));
        };
    }
    const UNHANDLEDREJECTION = "unhandledrejection";
    function globalError(err, promise) {
        var rv;
        try {
            rv = promise.onuncatched(err);
        }
        catch (e) { }
        if (rv !== false)
            try {
                var event, eventData = { promise: promise, reason: err };
                if (_global.document && document.createEvent) {
                    event = document.createEvent('Event');
                    event.initEvent(UNHANDLEDREJECTION, true, true);
                    extend$1(event, eventData);
                }
                else if (_global.CustomEvent) {
                    event = new CustomEvent(UNHANDLEDREJECTION, { detail: eventData });
                    extend$1(event, eventData);
                }
                if (event && _global.dispatchEvent) {
                    dispatchEvent(event);
                    if (!_global.PromiseRejectionEvent && _global.onunhandledrejection)
                        try {
                            _global.onunhandledrejection(event);
                        }
                        catch (_) { }
                }
                if (debug && event && !event.defaultPrevented) {
                    console.warn(`Unhandled rejection: ${err.stack || err}`);
                }
            }
            catch (e) { }
    }
    var rejection = DexiePromise.reject;

    function tempTransaction(db, mode, storeNames, fn) {
        if (!db.idbdb || (!db._state.openComplete && (!PSD.letThrough && !db._vip))) {
            if (db._state.openComplete) {
                return rejection(new exceptions.DatabaseClosed(db._state.dbOpenError));
            }
            if (!db._state.isBeingOpened) {
                if (!db._options.autoOpen)
                    return rejection(new exceptions.DatabaseClosed());
                db.open().catch(nop);
            }
            return db._state.dbReadyPromise.then(() => tempTransaction(db, mode, storeNames, fn));
        }
        else {
            var trans = db._createTransaction(mode, storeNames, db._dbSchema);
            try {
                trans.create();
                db._state.PR1398_maxLoop = 3;
            }
            catch (ex) {
                if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {
                    console.warn('Dexie: Need to reopen db');
                    db._close();
                    return db.open().then(() => tempTransaction(db, mode, storeNames, fn));
                }
                return rejection(ex);
            }
            return trans._promise(mode, (resolve, reject) => {
                return newScope(() => {
                    PSD.trans = trans;
                    return fn(resolve, reject, trans);
                });
            }).then(result => {
                return trans._completion.then(() => result);
            });
        }
    }

    const DEXIE_VERSION = '3.2.2';
    const maxString = String.fromCharCode(65535);
    const minKey = -Infinity;
    const INVALID_KEY_ARGUMENT = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.";
    const STRING_EXPECTED = "String expected.";
    const connections = [];
    const isIEOrEdge = typeof navigator !== 'undefined' && /(MSIE|Trident|Edge)/.test(navigator.userAgent);
    const hasIEDeleteObjectStoreBug = isIEOrEdge;
    const hangsOnDeleteLargeKeyRange = isIEOrEdge;
    const dexieStackFrameFilter = frame => !/(dexie\.js|dexie\.min\.js)/.test(frame);
    const DBNAMES_DB = '__dbnames';
    const READONLY = 'readonly';
    const READWRITE = 'readwrite';

    function combine(filter1, filter2) {
        return filter1 ?
            filter2 ?
                function () { return filter1.apply(this, arguments) && filter2.apply(this, arguments); } :
                filter1 :
            filter2;
    }

    const AnyRange = {
        type: 3 ,
        lower: -Infinity,
        lowerOpen: false,
        upper: [[]],
        upperOpen: false
    };

    function workaroundForUndefinedPrimKey(keyPath) {
        return typeof keyPath === "string" && !/\./.test(keyPath)
            ? (obj) => {
                if (obj[keyPath] === undefined && (keyPath in obj)) {
                    obj = deepClone(obj);
                    delete obj[keyPath];
                }
                return obj;
            }
            : (obj) => obj;
    }

    class Table {
        _trans(mode, fn, writeLocked) {
            const trans = this._tx || PSD.trans;
            const tableName = this.name;
            function checkTableInTransaction(resolve, reject, trans) {
                if (!trans.schema[tableName])
                    throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
                return fn(trans.idbtrans, trans);
            }
            const wasRootExec = beginMicroTickScope();
            try {
                return trans && trans.db === this.db ?
                    trans === PSD.trans ?
                        trans._promise(mode, checkTableInTransaction, writeLocked) :
                        newScope(() => trans._promise(mode, checkTableInTransaction, writeLocked), { trans: trans, transless: PSD.transless || PSD }) :
                    tempTransaction(this.db, mode, [this.name], checkTableInTransaction);
            }
            finally {
                if (wasRootExec)
                    endMicroTickScope();
            }
        }
        get(keyOrCrit, cb) {
            if (keyOrCrit && keyOrCrit.constructor === Object)
                return this.where(keyOrCrit).first(cb);
            return this._trans('readonly', (trans) => {
                return this.core.get({ trans, key: keyOrCrit })
                    .then(res => this.hook.reading.fire(res));
            }).then(cb);
        }
        where(indexOrCrit) {
            if (typeof indexOrCrit === 'string')
                return new this.db.WhereClause(this, indexOrCrit);
            if (isArray$1(indexOrCrit))
                return new this.db.WhereClause(this, `[${indexOrCrit.join('+')}]`);
            const keyPaths = keys(indexOrCrit);
            if (keyPaths.length === 1)
                return this
                    .where(keyPaths[0])
                    .equals(indexOrCrit[keyPaths[0]]);
            const compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(ix => ix.compound &&
                keyPaths.every(keyPath => ix.keyPath.indexOf(keyPath) >= 0) &&
                ix.keyPath.every(keyPath => keyPaths.indexOf(keyPath) >= 0))[0];
            if (compoundIndex && this.db._maxKey !== maxString)
                return this
                    .where(compoundIndex.name)
                    .equals(compoundIndex.keyPath.map(kp => indexOrCrit[kp]));
            if (!compoundIndex && debug)
                console.warn(`The query ${JSON.stringify(indexOrCrit)} on ${this.name} would benefit of a ` +
                    `compound index [${keyPaths.join('+')}]`);
            const { idxByName } = this.schema;
            const idb = this.db._deps.indexedDB;
            function equals(a, b) {
                try {
                    return idb.cmp(a, b) === 0;
                }
                catch (e) {
                    return false;
                }
            }
            const [idx, filterFunction] = keyPaths.reduce(([prevIndex, prevFilterFn], keyPath) => {
                const index = idxByName[keyPath];
                const value = indexOrCrit[keyPath];
                return [
                    prevIndex || index,
                    prevIndex || !index ?
                        combine(prevFilterFn, index && index.multi ?
                            x => {
                                const prop = getByKeyPath(x, keyPath);
                                return isArray$1(prop) && prop.some(item => equals(value, item));
                            } : x => equals(value, getByKeyPath(x, keyPath)))
                        : prevFilterFn
                ];
            }, [null, null]);
            return idx ?
                this.where(idx.name).equals(indexOrCrit[idx.keyPath])
                    .filter(filterFunction) :
                compoundIndex ?
                    this.filter(filterFunction) :
                    this.where(keyPaths).equals('');
        }
        filter(filterFunction) {
            return this.toCollection().and(filterFunction);
        }
        count(thenShortcut) {
            return this.toCollection().count(thenShortcut);
        }
        offset(offset) {
            return this.toCollection().offset(offset);
        }
        limit(numRows) {
            return this.toCollection().limit(numRows);
        }
        each(callback) {
            return this.toCollection().each(callback);
        }
        toArray(thenShortcut) {
            return this.toCollection().toArray(thenShortcut);
        }
        toCollection() {
            return new this.db.Collection(new this.db.WhereClause(this));
        }
        orderBy(index) {
            return new this.db.Collection(new this.db.WhereClause(this, isArray$1(index) ?
                `[${index.join('+')}]` :
                index));
        }
        reverse() {
            return this.toCollection().reverse();
        }
        mapToClass(constructor) {
            this.schema.mappedClass = constructor;
            const readHook = obj => {
                if (!obj)
                    return obj;
                const res = Object.create(constructor.prototype);
                for (var m in obj)
                    if (hasOwn$1(obj, m))
                        try {
                            res[m] = obj[m];
                        }
                        catch (_) { }
                return res;
            };
            if (this.schema.readHook) {
                this.hook.reading.unsubscribe(this.schema.readHook);
            }
            this.schema.readHook = readHook;
            this.hook("reading", readHook);
            return constructor;
        }
        defineClass() {
            function Class(content) {
                extend$1(this, content);
            }
            return this.mapToClass(Class);
        }
        add(obj, key) {
            const { auto, keyPath } = this.schema.primKey;
            let objToAdd = obj;
            if (keyPath && auto) {
                objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
            }
            return this._trans('readwrite', trans => {
                return this.core.mutate({ trans, type: 'add', keys: key != null ? [key] : null, values: [objToAdd] });
            }).then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult)
                .then(lastResult => {
                if (keyPath) {
                    try {
                        setByKeyPath(obj, keyPath, lastResult);
                    }
                    catch (_) { }
                }
                return lastResult;
            });
        }
        update(keyOrObject, modifications) {
            if (typeof keyOrObject === 'object' && !isArray$1(keyOrObject)) {
                const key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);
                if (key === undefined)
                    return rejection(new exceptions.InvalidArgument("Given object does not contain its primary key"));
                try {
                    if (typeof modifications !== "function") {
                        keys(modifications).forEach(keyPath => {
                            setByKeyPath(keyOrObject, keyPath, modifications[keyPath]);
                        });
                    }
                    else {
                        modifications(keyOrObject, { value: keyOrObject, primKey: key });
                    }
                }
                catch (_a) {
                }
                return this.where(":id").equals(key).modify(modifications);
            }
            else {
                return this.where(":id").equals(keyOrObject).modify(modifications);
            }
        }
        put(obj, key) {
            const { auto, keyPath } = this.schema.primKey;
            let objToAdd = obj;
            if (keyPath && auto) {
                objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
            }
            return this._trans('readwrite', trans => this.core.mutate({ trans, type: 'put', values: [objToAdd], keys: key != null ? [key] : null }))
                .then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult)
                .then(lastResult => {
                if (keyPath) {
                    try {
                        setByKeyPath(obj, keyPath, lastResult);
                    }
                    catch (_) { }
                }
                return lastResult;
            });
        }
        delete(key) {
            return this._trans('readwrite', trans => this.core.mutate({ trans, type: 'delete', keys: [key] }))
                .then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined);
        }
        clear() {
            return this._trans('readwrite', trans => this.core.mutate({ trans, type: 'deleteRange', range: AnyRange }))
                .then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined);
        }
        bulkGet(keys) {
            return this._trans('readonly', trans => {
                return this.core.getMany({
                    keys,
                    trans
                }).then(result => result.map(res => this.hook.reading.fire(res)));
            });
        }
        bulkAdd(objects, keysOrOptions, options) {
            const keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;
            options = options || (keys ? undefined : keysOrOptions);
            const wantResults = options ? options.allKeys : undefined;
            return this._trans('readwrite', trans => {
                const { auto, keyPath } = this.schema.primKey;
                if (keyPath && keys)
                    throw new exceptions.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
                if (keys && keys.length !== objects.length)
                    throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
                const numObjects = objects.length;
                let objectsToAdd = keyPath && auto ?
                    objects.map(workaroundForUndefinedPrimKey(keyPath)) :
                    objects;
                return this.core.mutate({ trans, type: 'add', keys: keys, values: objectsToAdd, wantResults })
                    .then(({ numFailures, results, lastResult, failures }) => {
                    const result = wantResults ? results : lastResult;
                    if (numFailures === 0)
                        return result;
                    throw new BulkError(`${this.name}.bulkAdd(): ${numFailures} of ${numObjects} operations failed`, failures);
                });
            });
        }
        bulkPut(objects, keysOrOptions, options) {
            const keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;
            options = options || (keys ? undefined : keysOrOptions);
            const wantResults = options ? options.allKeys : undefined;
            return this._trans('readwrite', trans => {
                const { auto, keyPath } = this.schema.primKey;
                if (keyPath && keys)
                    throw new exceptions.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
                if (keys && keys.length !== objects.length)
                    throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
                const numObjects = objects.length;
                let objectsToPut = keyPath && auto ?
                    objects.map(workaroundForUndefinedPrimKey(keyPath)) :
                    objects;
                return this.core.mutate({ trans, type: 'put', keys: keys, values: objectsToPut, wantResults })
                    .then(({ numFailures, results, lastResult, failures }) => {
                    const result = wantResults ? results : lastResult;
                    if (numFailures === 0)
                        return result;
                    throw new BulkError(`${this.name}.bulkPut(): ${numFailures} of ${numObjects} operations failed`, failures);
                });
            });
        }
        bulkDelete(keys) {
            const numKeys = keys.length;
            return this._trans('readwrite', trans => {
                return this.core.mutate({ trans, type: 'delete', keys: keys });
            }).then(({ numFailures, lastResult, failures }) => {
                if (numFailures === 0)
                    return lastResult;
                throw new BulkError(`${this.name}.bulkDelete(): ${numFailures} of ${numKeys} operations failed`, failures);
            });
        }
    }

    function Events(ctx) {
        var evs = {};
        var rv = function (eventName, subscriber) {
            if (subscriber) {
                var i = arguments.length, args = new Array(i - 1);
                while (--i)
                    args[i - 1] = arguments[i];
                evs[eventName].subscribe.apply(null, args);
                return ctx;
            }
            else if (typeof (eventName) === 'string') {
                return evs[eventName];
            }
        };
        rv.addEventType = add;
        for (var i = 1, l = arguments.length; i < l; ++i) {
            add(arguments[i]);
        }
        return rv;
        function add(eventName, chainFunction, defaultFunction) {
            if (typeof eventName === 'object')
                return addConfiguredEvents(eventName);
            if (!chainFunction)
                chainFunction = reverseStoppableEventChain;
            if (!defaultFunction)
                defaultFunction = nop;
            var context = {
                subscribers: [],
                fire: defaultFunction,
                subscribe: function (cb) {
                    if (context.subscribers.indexOf(cb) === -1) {
                        context.subscribers.push(cb);
                        context.fire = chainFunction(context.fire, cb);
                    }
                },
                unsubscribe: function (cb) {
                    context.subscribers = context.subscribers.filter(function (fn) { return fn !== cb; });
                    context.fire = context.subscribers.reduce(chainFunction, defaultFunction);
                }
            };
            evs[eventName] = rv[eventName] = context;
            return context;
        }
        function addConfiguredEvents(cfg) {
            keys(cfg).forEach(function (eventName) {
                var args = cfg[eventName];
                if (isArray$1(args)) {
                    add(eventName, cfg[eventName][0], cfg[eventName][1]);
                }
                else if (args === 'asap') {
                    var context = add(eventName, mirror, function fire() {
                        var i = arguments.length, args = new Array(i);
                        while (i--)
                            args[i] = arguments[i];
                        context.subscribers.forEach(function (fn) {
                            asap$1(function fireEvent() {
                                fn.apply(null, args);
                            });
                        });
                    });
                }
                else
                    throw new exceptions.InvalidArgument("Invalid event config");
            });
        }
    }

    function makeClassConstructor(prototype, constructor) {
        derive(constructor).from({ prototype });
        return constructor;
    }

    function createTableConstructor(db) {
        return makeClassConstructor(Table.prototype, function Table(name, tableSchema, trans) {
            this.db = db;
            this._tx = trans;
            this.name = name;
            this.schema = tableSchema;
            this.hook = db._allTables[name] ? db._allTables[name].hook : Events(null, {
                "creating": [hookCreatingChain, nop],
                "reading": [pureFunctionChain, mirror],
                "updating": [hookUpdatingChain, nop],
                "deleting": [hookDeletingChain, nop]
            });
        });
    }

    function isPlainKeyRange(ctx, ignoreLimitFilter) {
        return !(ctx.filter || ctx.algorithm || ctx.or) &&
            (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);
    }
    function addFilter(ctx, fn) {
        ctx.filter = combine(ctx.filter, fn);
    }
    function addReplayFilter(ctx, factory, isLimitFilter) {
        var curr = ctx.replayFilter;
        ctx.replayFilter = curr ? () => combine(curr(), factory()) : factory;
        ctx.justLimit = isLimitFilter && !curr;
    }
    function addMatchFilter(ctx, fn) {
        ctx.isMatch = combine(ctx.isMatch, fn);
    }
    function getIndexOrStore(ctx, coreSchema) {
        if (ctx.isPrimKey)
            return coreSchema.primaryKey;
        const index = coreSchema.getIndexByKeyPath(ctx.index);
        if (!index)
            throw new exceptions.Schema("KeyPath " + ctx.index + " on object store " + coreSchema.name + " is not indexed");
        return index;
    }
    function openCursor(ctx, coreTable, trans) {
        const index = getIndexOrStore(ctx, coreTable.schema);
        return coreTable.openCursor({
            trans,
            values: !ctx.keysOnly,
            reverse: ctx.dir === 'prev',
            unique: !!ctx.unique,
            query: {
                index,
                range: ctx.range
            }
        });
    }
    function iter(ctx, fn, coreTrans, coreTable) {
        const filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;
        if (!ctx.or) {
            return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter), fn, !ctx.keysOnly && ctx.valueMapper);
        }
        else {
            const set = {};
            const union = (item, cursor, advance) => {
                if (!filter || filter(cursor, advance, result => cursor.stop(result), err => cursor.fail(err))) {
                    var primaryKey = cursor.primaryKey;
                    var key = '' + primaryKey;
                    if (key === '[object ArrayBuffer]')
                        key = '' + new Uint8Array(primaryKey);
                    if (!hasOwn$1(set, key)) {
                        set[key] = true;
                        fn(item, cursor, advance);
                    }
                }
            };
            return Promise.all([
                ctx.or._iterate(union, coreTrans),
                iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)
            ]);
        }
    }
    function iterate(cursorPromise, filter, fn, valueMapper) {
        var mappedFn = valueMapper ? (x, c, a) => fn(valueMapper(x), c, a) : fn;
        var wrappedFn = wrap(mappedFn);
        return cursorPromise.then(cursor => {
            if (cursor) {
                return cursor.start(() => {
                    var c = () => cursor.continue();
                    if (!filter || filter(cursor, advancer => c = advancer, val => { cursor.stop(val); c = nop; }, e => { cursor.fail(e); c = nop; }))
                        wrappedFn(cursor.value, cursor, advancer => c = advancer);
                    c();
                });
            }
        });
    }

    function cmp(a, b) {
        try {
            const ta = type(a);
            const tb = type(b);
            if (ta !== tb) {
                if (ta === 'Array')
                    return 1;
                if (tb === 'Array')
                    return -1;
                if (ta === 'binary')
                    return 1;
                if (tb === 'binary')
                    return -1;
                if (ta === 'string')
                    return 1;
                if (tb === 'string')
                    return -1;
                if (ta === 'Date')
                    return 1;
                if (tb !== 'Date')
                    return NaN;
                return -1;
            }
            switch (ta) {
                case 'number':
                case 'Date':
                case 'string':
                    return a > b ? 1 : a < b ? -1 : 0;
                case 'binary': {
                    return compareUint8Arrays(getUint8Array(a), getUint8Array(b));
                }
                case 'Array':
                    return compareArrays(a, b);
            }
        }
        catch (_a) { }
        return NaN;
    }
    function compareArrays(a, b) {
        const al = a.length;
        const bl = b.length;
        const l = al < bl ? al : bl;
        for (let i = 0; i < l; ++i) {
            const res = cmp(a[i], b[i]);
            if (res !== 0)
                return res;
        }
        return al === bl ? 0 : al < bl ? -1 : 1;
    }
    function compareUint8Arrays(a, b) {
        const al = a.length;
        const bl = b.length;
        const l = al < bl ? al : bl;
        for (let i = 0; i < l; ++i) {
            if (a[i] !== b[i])
                return a[i] < b[i] ? -1 : 1;
        }
        return al === bl ? 0 : al < bl ? -1 : 1;
    }
    function type(x) {
        const t = typeof x;
        if (t !== 'object')
            return t;
        if (ArrayBuffer.isView(x))
            return 'binary';
        const tsTag = toStringTag(x);
        return tsTag === 'ArrayBuffer' ? 'binary' : tsTag;
    }
    function getUint8Array(a) {
        if (a instanceof Uint8Array)
            return a;
        if (ArrayBuffer.isView(a))
            return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
        return new Uint8Array(a);
    }

    class Collection {
        _read(fn, cb) {
            var ctx = this._ctx;
            return ctx.error ?
                ctx.table._trans(null, rejection.bind(null, ctx.error)) :
                ctx.table._trans('readonly', fn).then(cb);
        }
        _write(fn) {
            var ctx = this._ctx;
            return ctx.error ?
                ctx.table._trans(null, rejection.bind(null, ctx.error)) :
                ctx.table._trans('readwrite', fn, "locked");
        }
        _addAlgorithm(fn) {
            var ctx = this._ctx;
            ctx.algorithm = combine(ctx.algorithm, fn);
        }
        _iterate(fn, coreTrans) {
            return iter(this._ctx, fn, coreTrans, this._ctx.table.core);
        }
        clone(props) {
            var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);
            if (props)
                extend$1(ctx, props);
            rv._ctx = ctx;
            return rv;
        }
        raw() {
            this._ctx.valueMapper = null;
            return this;
        }
        each(fn) {
            var ctx = this._ctx;
            return this._read(trans => iter(ctx, fn, trans, ctx.table.core));
        }
        count(cb) {
            return this._read(trans => {
                const ctx = this._ctx;
                const coreTable = ctx.table.core;
                if (isPlainKeyRange(ctx, true)) {
                    return coreTable.count({
                        trans,
                        query: {
                            index: getIndexOrStore(ctx, coreTable.schema),
                            range: ctx.range
                        }
                    }).then(count => Math.min(count, ctx.limit));
                }
                else {
                    var count = 0;
                    return iter(ctx, () => { ++count; return false; }, trans, coreTable)
                        .then(() => count);
                }
            }).then(cb);
        }
        sortBy(keyPath, cb) {
            const parts = keyPath.split('.').reverse(), lastPart = parts[0], lastIndex = parts.length - 1;
            function getval(obj, i) {
                if (i)
                    return getval(obj[parts[i]], i - 1);
                return obj[lastPart];
            }
            var order = this._ctx.dir === "next" ? 1 : -1;
            function sorter(a, b) {
                var aVal = getval(a, lastIndex), bVal = getval(b, lastIndex);
                return aVal < bVal ? -order : aVal > bVal ? order : 0;
            }
            return this.toArray(function (a) {
                return a.sort(sorter);
            }).then(cb);
        }
        toArray(cb) {
            return this._read(trans => {
                var ctx = this._ctx;
                if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
                    const { valueMapper } = ctx;
                    const index = getIndexOrStore(ctx, ctx.table.core.schema);
                    return ctx.table.core.query({
                        trans,
                        limit: ctx.limit,
                        values: true,
                        query: {
                            index,
                            range: ctx.range
                        }
                    }).then(({ result }) => valueMapper ? result.map(valueMapper) : result);
                }
                else {
                    const a = [];
                    return iter(ctx, item => a.push(item), trans, ctx.table.core).then(() => a);
                }
            }, cb);
        }
        offset(offset) {
            var ctx = this._ctx;
            if (offset <= 0)
                return this;
            ctx.offset += offset;
            if (isPlainKeyRange(ctx)) {
                addReplayFilter(ctx, () => {
                    var offsetLeft = offset;
                    return (cursor, advance) => {
                        if (offsetLeft === 0)
                            return true;
                        if (offsetLeft === 1) {
                            --offsetLeft;
                            return false;
                        }
                        advance(() => {
                            cursor.advance(offsetLeft);
                            offsetLeft = 0;
                        });
                        return false;
                    };
                });
            }
            else {
                addReplayFilter(ctx, () => {
                    var offsetLeft = offset;
                    return () => (--offsetLeft < 0);
                });
            }
            return this;
        }
        limit(numRows) {
            this._ctx.limit = Math.min(this._ctx.limit, numRows);
            addReplayFilter(this._ctx, () => {
                var rowsLeft = numRows;
                return function (cursor, advance, resolve) {
                    if (--rowsLeft <= 0)
                        advance(resolve);
                    return rowsLeft >= 0;
                };
            }, true);
            return this;
        }
        until(filterFunction, bIncludeStopEntry) {
            addFilter(this._ctx, function (cursor, advance, resolve) {
                if (filterFunction(cursor.value)) {
                    advance(resolve);
                    return bIncludeStopEntry;
                }
                else {
                    return true;
                }
            });
            return this;
        }
        first(cb) {
            return this.limit(1).toArray(function (a) { return a[0]; }).then(cb);
        }
        last(cb) {
            return this.reverse().first(cb);
        }
        filter(filterFunction) {
            addFilter(this._ctx, function (cursor) {
                return filterFunction(cursor.value);
            });
            addMatchFilter(this._ctx, filterFunction);
            return this;
        }
        and(filter) {
            return this.filter(filter);
        }
        or(indexName) {
            return new this.db.WhereClause(this._ctx.table, indexName, this);
        }
        reverse() {
            this._ctx.dir = (this._ctx.dir === "prev" ? "next" : "prev");
            if (this._ondirectionchange)
                this._ondirectionchange(this._ctx.dir);
            return this;
        }
        desc() {
            return this.reverse();
        }
        eachKey(cb) {
            var ctx = this._ctx;
            ctx.keysOnly = !ctx.isMatch;
            return this.each(function (val, cursor) { cb(cursor.key, cursor); });
        }
        eachUniqueKey(cb) {
            this._ctx.unique = "unique";
            return this.eachKey(cb);
        }
        eachPrimaryKey(cb) {
            var ctx = this._ctx;
            ctx.keysOnly = !ctx.isMatch;
            return this.each(function (val, cursor) { cb(cursor.primaryKey, cursor); });
        }
        keys(cb) {
            var ctx = this._ctx;
            ctx.keysOnly = !ctx.isMatch;
            var a = [];
            return this.each(function (item, cursor) {
                a.push(cursor.key);
            }).then(function () {
                return a;
            }).then(cb);
        }
        primaryKeys(cb) {
            var ctx = this._ctx;
            if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
                return this._read(trans => {
                    var index = getIndexOrStore(ctx, ctx.table.core.schema);
                    return ctx.table.core.query({
                        trans,
                        values: false,
                        limit: ctx.limit,
                        query: {
                            index,
                            range: ctx.range
                        }
                    });
                }).then(({ result }) => result).then(cb);
            }
            ctx.keysOnly = !ctx.isMatch;
            var a = [];
            return this.each(function (item, cursor) {
                a.push(cursor.primaryKey);
            }).then(function () {
                return a;
            }).then(cb);
        }
        uniqueKeys(cb) {
            this._ctx.unique = "unique";
            return this.keys(cb);
        }
        firstKey(cb) {
            return this.limit(1).keys(function (a) { return a[0]; }).then(cb);
        }
        lastKey(cb) {
            return this.reverse().firstKey(cb);
        }
        distinct() {
            var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];
            if (!idx || !idx.multi)
                return this;
            var set = {};
            addFilter(this._ctx, function (cursor) {
                var strKey = cursor.primaryKey.toString();
                var found = hasOwn$1(set, strKey);
                set[strKey] = true;
                return !found;
            });
            return this;
        }
        modify(changes) {
            var ctx = this._ctx;
            return this._write(trans => {
                var modifyer;
                if (typeof changes === 'function') {
                    modifyer = changes;
                }
                else {
                    var keyPaths = keys(changes);
                    var numKeys = keyPaths.length;
                    modifyer = function (item) {
                        var anythingModified = false;
                        for (var i = 0; i < numKeys; ++i) {
                            var keyPath = keyPaths[i], val = changes[keyPath];
                            if (getByKeyPath(item, keyPath) !== val) {
                                setByKeyPath(item, keyPath, val);
                                anythingModified = true;
                            }
                        }
                        return anythingModified;
                    };
                }
                const coreTable = ctx.table.core;
                const { outbound, extractKey } = coreTable.schema.primaryKey;
                const limit = this.db._options.modifyChunkSize || 200;
                const totalFailures = [];
                let successCount = 0;
                const failedKeys = [];
                const applyMutateResult = (expectedCount, res) => {
                    const { failures, numFailures } = res;
                    successCount += expectedCount - numFailures;
                    for (let pos of keys(failures)) {
                        totalFailures.push(failures[pos]);
                    }
                };
                return this.clone().primaryKeys().then(keys => {
                    const nextChunk = (offset) => {
                        const count = Math.min(limit, keys.length - offset);
                        return coreTable.getMany({
                            trans,
                            keys: keys.slice(offset, offset + count),
                            cache: "immutable"
                        }).then(values => {
                            const addValues = [];
                            const putValues = [];
                            const putKeys = outbound ? [] : null;
                            const deleteKeys = [];
                            for (let i = 0; i < count; ++i) {
                                const origValue = values[i];
                                const ctx = {
                                    value: deepClone(origValue),
                                    primKey: keys[offset + i]
                                };
                                if (modifyer.call(ctx, ctx.value, ctx) !== false) {
                                    if (ctx.value == null) {
                                        deleteKeys.push(keys[offset + i]);
                                    }
                                    else if (!outbound && cmp(extractKey(origValue), extractKey(ctx.value)) !== 0) {
                                        deleteKeys.push(keys[offset + i]);
                                        addValues.push(ctx.value);
                                    }
                                    else {
                                        putValues.push(ctx.value);
                                        if (outbound)
                                            putKeys.push(keys[offset + i]);
                                    }
                                }
                            }
                            const criteria = isPlainKeyRange(ctx) &&
                                ctx.limit === Infinity &&
                                (typeof changes !== 'function' || changes === deleteCallback) && {
                                index: ctx.index,
                                range: ctx.range
                            };
                            return Promise.resolve(addValues.length > 0 &&
                                coreTable.mutate({ trans, type: 'add', values: addValues })
                                    .then(res => {
                                    for (let pos in res.failures) {
                                        deleteKeys.splice(parseInt(pos), 1);
                                    }
                                    applyMutateResult(addValues.length, res);
                                })).then(() => (putValues.length > 0 || (criteria && typeof changes === 'object')) &&
                                coreTable.mutate({
                                    trans,
                                    type: 'put',
                                    keys: putKeys,
                                    values: putValues,
                                    criteria,
                                    changeSpec: typeof changes !== 'function'
                                        && changes
                                }).then(res => applyMutateResult(putValues.length, res))).then(() => (deleteKeys.length > 0 || (criteria && changes === deleteCallback)) &&
                                coreTable.mutate({
                                    trans,
                                    type: 'delete',
                                    keys: deleteKeys,
                                    criteria
                                }).then(res => applyMutateResult(deleteKeys.length, res))).then(() => {
                                return keys.length > offset + count && nextChunk(offset + limit);
                            });
                        });
                    };
                    return nextChunk(0).then(() => {
                        if (totalFailures.length > 0)
                            throw new ModifyError("Error modifying one or more objects", totalFailures, successCount, failedKeys);
                        return keys.length;
                    });
                });
            });
        }
        delete() {
            var ctx = this._ctx, range = ctx.range;
            if (isPlainKeyRange(ctx) &&
                ((ctx.isPrimKey && !hangsOnDeleteLargeKeyRange) || range.type === 3 ))
             {
                return this._write(trans => {
                    const { primaryKey } = ctx.table.core.schema;
                    const coreRange = range;
                    return ctx.table.core.count({ trans, query: { index: primaryKey, range: coreRange } }).then(count => {
                        return ctx.table.core.mutate({ trans, type: 'deleteRange', range: coreRange })
                            .then(({ failures, lastResult, results, numFailures }) => {
                            if (numFailures)
                                throw new ModifyError("Could not delete some values", Object.keys(failures).map(pos => failures[pos]), count - numFailures);
                            return count - numFailures;
                        });
                    });
                });
            }
            return this.modify(deleteCallback);
        }
    }
    const deleteCallback = (value, ctx) => ctx.value = null;

    function createCollectionConstructor(db) {
        return makeClassConstructor(Collection.prototype, function Collection(whereClause, keyRangeGenerator) {
            this.db = db;
            let keyRange = AnyRange, error = null;
            if (keyRangeGenerator)
                try {
                    keyRange = keyRangeGenerator();
                }
                catch (ex) {
                    error = ex;
                }
            const whereCtx = whereClause._ctx;
            const table = whereCtx.table;
            const readingHook = table.hook.reading.fire;
            this._ctx = {
                table: table,
                index: whereCtx.index,
                isPrimKey: (!whereCtx.index || (table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name)),
                range: keyRange,
                keysOnly: false,
                dir: "next",
                unique: "",
                algorithm: null,
                filter: null,
                replayFilter: null,
                justLimit: true,
                isMatch: null,
                offset: 0,
                limit: Infinity,
                error: error,
                or: whereCtx.or,
                valueMapper: readingHook !== mirror ? readingHook : null
            };
        });
    }

    function simpleCompare(a, b) {
        return a < b ? -1 : a === b ? 0 : 1;
    }
    function simpleCompareReverse(a, b) {
        return a > b ? -1 : a === b ? 0 : 1;
    }

    function fail(collectionOrWhereClause, err, T) {
        var collection = collectionOrWhereClause instanceof WhereClause ?
            new collectionOrWhereClause.Collection(collectionOrWhereClause) :
            collectionOrWhereClause;
        collection._ctx.error = T ? new T(err) : new TypeError(err);
        return collection;
    }
    function emptyCollection(whereClause) {
        return new whereClause.Collection(whereClause, () => rangeEqual("")).limit(0);
    }
    function upperFactory(dir) {
        return dir === "next" ?
            (s) => s.toUpperCase() :
            (s) => s.toLowerCase();
    }
    function lowerFactory(dir) {
        return dir === "next" ?
            (s) => s.toLowerCase() :
            (s) => s.toUpperCase();
    }
    function nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp, dir) {
        var length = Math.min(key.length, lowerNeedle.length);
        var llp = -1;
        for (var i = 0; i < length; ++i) {
            var lwrKeyChar = lowerKey[i];
            if (lwrKeyChar !== lowerNeedle[i]) {
                if (cmp(key[i], upperNeedle[i]) < 0)
                    return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);
                if (cmp(key[i], lowerNeedle[i]) < 0)
                    return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);
                if (llp >= 0)
                    return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);
                return null;
            }
            if (cmp(key[i], lwrKeyChar) < 0)
                llp = i;
        }
        if (length < lowerNeedle.length && dir === "next")
            return key + upperNeedle.substr(key.length);
        if (length < key.length && dir === "prev")
            return key.substr(0, upperNeedle.length);
        return (llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1));
    }
    function addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {
        var upper, lower, compare, upperNeedles, lowerNeedles, direction, nextKeySuffix, needlesLen = needles.length;
        if (!needles.every(s => typeof s === 'string')) {
            return fail(whereClause, STRING_EXPECTED);
        }
        function initDirection(dir) {
            upper = upperFactory(dir);
            lower = lowerFactory(dir);
            compare = (dir === "next" ? simpleCompare : simpleCompareReverse);
            var needleBounds = needles.map(function (needle) {
                return { lower: lower(needle), upper: upper(needle) };
            }).sort(function (a, b) {
                return compare(a.lower, b.lower);
            });
            upperNeedles = needleBounds.map(function (nb) { return nb.upper; });
            lowerNeedles = needleBounds.map(function (nb) { return nb.lower; });
            direction = dir;
            nextKeySuffix = (dir === "next" ? "" : suffix);
        }
        initDirection("next");
        var c = new whereClause.Collection(whereClause, () => createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix));
        c._ondirectionchange = function (direction) {
            initDirection(direction);
        };
        var firstPossibleNeedle = 0;
        c._addAlgorithm(function (cursor, advance, resolve) {
            var key = cursor.key;
            if (typeof key !== 'string')
                return false;
            var lowerKey = lower(key);
            if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {
                return true;
            }
            else {
                var lowestPossibleCasing = null;
                for (var i = firstPossibleNeedle; i < needlesLen; ++i) {
                    var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);
                    if (casing === null && lowestPossibleCasing === null)
                        firstPossibleNeedle = i + 1;
                    else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {
                        lowestPossibleCasing = casing;
                    }
                }
                if (lowestPossibleCasing !== null) {
                    advance(function () { cursor.continue(lowestPossibleCasing + nextKeySuffix); });
                }
                else {
                    advance(resolve);
                }
                return false;
            }
        });
        return c;
    }
    function createRange(lower, upper, lowerOpen, upperOpen) {
        return {
            type: 2 ,
            lower,
            upper,
            lowerOpen,
            upperOpen
        };
    }
    function rangeEqual(value) {
        return {
            type: 1 ,
            lower: value,
            upper: value
        };
    }

    class WhereClause {
        get Collection() {
            return this._ctx.table.db.Collection;
        }
        between(lower, upper, includeLower, includeUpper) {
            includeLower = includeLower !== false;
            includeUpper = includeUpper === true;
            try {
                if ((this._cmp(lower, upper) > 0) ||
                    (this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper)))
                    return emptyCollection(this);
                return new this.Collection(this, () => createRange(lower, upper, !includeLower, !includeUpper));
            }
            catch (e) {
                return fail(this, INVALID_KEY_ARGUMENT);
            }
        }
        equals(value) {
            if (value == null)
                return fail(this, INVALID_KEY_ARGUMENT);
            return new this.Collection(this, () => rangeEqual(value));
        }
        above(value) {
            if (value == null)
                return fail(this, INVALID_KEY_ARGUMENT);
            return new this.Collection(this, () => createRange(value, undefined, true));
        }
        aboveOrEqual(value) {
            if (value == null)
                return fail(this, INVALID_KEY_ARGUMENT);
            return new this.Collection(this, () => createRange(value, undefined, false));
        }
        below(value) {
            if (value == null)
                return fail(this, INVALID_KEY_ARGUMENT);
            return new this.Collection(this, () => createRange(undefined, value, false, true));
        }
        belowOrEqual(value) {
            if (value == null)
                return fail(this, INVALID_KEY_ARGUMENT);
            return new this.Collection(this, () => createRange(undefined, value));
        }
        startsWith(str) {
            if (typeof str !== 'string')
                return fail(this, STRING_EXPECTED);
            return this.between(str, str + maxString, true, true);
        }
        startsWithIgnoreCase(str) {
            if (str === "")
                return this.startsWith(str);
            return addIgnoreCaseAlgorithm(this, (x, a) => x.indexOf(a[0]) === 0, [str], maxString);
        }
        equalsIgnoreCase(str) {
            return addIgnoreCaseAlgorithm(this, (x, a) => x === a[0], [str], "");
        }
        anyOfIgnoreCase() {
            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
            if (set.length === 0)
                return emptyCollection(this);
            return addIgnoreCaseAlgorithm(this, (x, a) => a.indexOf(x) !== -1, set, "");
        }
        startsWithAnyOfIgnoreCase() {
            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
            if (set.length === 0)
                return emptyCollection(this);
            return addIgnoreCaseAlgorithm(this, (x, a) => a.some(n => x.indexOf(n) === 0), set, maxString);
        }
        anyOf() {
            const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
            let compare = this._cmp;
            try {
                set.sort(compare);
            }
            catch (e) {
                return fail(this, INVALID_KEY_ARGUMENT);
            }
            if (set.length === 0)
                return emptyCollection(this);
            const c = new this.Collection(this, () => createRange(set[0], set[set.length - 1]));
            c._ondirectionchange = direction => {
                compare = (direction === "next" ?
                    this._ascending :
                    this._descending);
                set.sort(compare);
            };
            let i = 0;
            c._addAlgorithm((cursor, advance, resolve) => {
                const key = cursor.key;
                while (compare(key, set[i]) > 0) {
                    ++i;
                    if (i === set.length) {
                        advance(resolve);
                        return false;
                    }
                }
                if (compare(key, set[i]) === 0) {
                    return true;
                }
                else {
                    advance(() => { cursor.continue(set[i]); });
                    return false;
                }
            });
            return c;
        }
        notEqual(value) {
            return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], { includeLowers: false, includeUppers: false });
        }
        noneOf() {
            const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
            if (set.length === 0)
                return new this.Collection(this);
            try {
                set.sort(this._ascending);
            }
            catch (e) {
                return fail(this, INVALID_KEY_ARGUMENT);
            }
            const ranges = set.reduce((res, val) => res ?
                res.concat([[res[res.length - 1][1], val]]) :
                [[minKey, val]], null);
            ranges.push([set[set.length - 1], this.db._maxKey]);
            return this.inAnyRange(ranges, { includeLowers: false, includeUppers: false });
        }
        inAnyRange(ranges, options) {
            const cmp = this._cmp, ascending = this._ascending, descending = this._descending, min = this._min, max = this._max;
            if (ranges.length === 0)
                return emptyCollection(this);
            if (!ranges.every(range => range[0] !== undefined &&
                range[1] !== undefined &&
                ascending(range[0], range[1]) <= 0)) {
                return fail(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", exceptions.InvalidArgument);
            }
            const includeLowers = !options || options.includeLowers !== false;
            const includeUppers = options && options.includeUppers === true;
            function addRange(ranges, newRange) {
                let i = 0, l = ranges.length;
                for (; i < l; ++i) {
                    const range = ranges[i];
                    if (cmp(newRange[0], range[1]) < 0 && cmp(newRange[1], range[0]) > 0) {
                        range[0] = min(range[0], newRange[0]);
                        range[1] = max(range[1], newRange[1]);
                        break;
                    }
                }
                if (i === l)
                    ranges.push(newRange);
                return ranges;
            }
            let sortDirection = ascending;
            function rangeSorter(a, b) { return sortDirection(a[0], b[0]); }
            let set;
            try {
                set = ranges.reduce(addRange, []);
                set.sort(rangeSorter);
            }
            catch (ex) {
                return fail(this, INVALID_KEY_ARGUMENT);
            }
            let rangePos = 0;
            const keyIsBeyondCurrentEntry = includeUppers ?
                key => ascending(key, set[rangePos][1]) > 0 :
                key => ascending(key, set[rangePos][1]) >= 0;
            const keyIsBeforeCurrentEntry = includeLowers ?
                key => descending(key, set[rangePos][0]) > 0 :
                key => descending(key, set[rangePos][0]) >= 0;
            function keyWithinCurrentRange(key) {
                return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);
            }
            let checkKey = keyIsBeyondCurrentEntry;
            const c = new this.Collection(this, () => createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers));
            c._ondirectionchange = direction => {
                if (direction === "next") {
                    checkKey = keyIsBeyondCurrentEntry;
                    sortDirection = ascending;
                }
                else {
                    checkKey = keyIsBeforeCurrentEntry;
                    sortDirection = descending;
                }
                set.sort(rangeSorter);
            };
            c._addAlgorithm((cursor, advance, resolve) => {
                var key = cursor.key;
                while (checkKey(key)) {
                    ++rangePos;
                    if (rangePos === set.length) {
                        advance(resolve);
                        return false;
                    }
                }
                if (keyWithinCurrentRange(key)) {
                    return true;
                }
                else if (this._cmp(key, set[rangePos][1]) === 0 || this._cmp(key, set[rangePos][0]) === 0) {
                    return false;
                }
                else {
                    advance(() => {
                        if (sortDirection === ascending)
                            cursor.continue(set[rangePos][0]);
                        else
                            cursor.continue(set[rangePos][1]);
                    });
                    return false;
                }
            });
            return c;
        }
        startsWithAnyOf() {
            const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
            if (!set.every(s => typeof s === 'string')) {
                return fail(this, "startsWithAnyOf() only works with strings");
            }
            if (set.length === 0)
                return emptyCollection(this);
            return this.inAnyRange(set.map((str) => [str, str + maxString]));
        }
    }

    function createWhereClauseConstructor(db) {
        return makeClassConstructor(WhereClause.prototype, function WhereClause(table, index, orCollection) {
            this.db = db;
            this._ctx = {
                table: table,
                index: index === ":id" ? null : index,
                or: orCollection
            };
            const indexedDB = db._deps.indexedDB;
            if (!indexedDB)
                throw new exceptions.MissingAPI();
            this._cmp = this._ascending = indexedDB.cmp.bind(indexedDB);
            this._descending = (a, b) => indexedDB.cmp(b, a);
            this._max = (a, b) => indexedDB.cmp(a, b) > 0 ? a : b;
            this._min = (a, b) => indexedDB.cmp(a, b) < 0 ? a : b;
            this._IDBKeyRange = db._deps.IDBKeyRange;
        });
    }

    function eventRejectHandler(reject) {
        return wrap(function (event) {
            preventDefault(event);
            reject(event.target.error);
            return false;
        });
    }
    function preventDefault(event) {
        if (event.stopPropagation)
            event.stopPropagation();
        if (event.preventDefault)
            event.preventDefault();
    }

    const DEXIE_STORAGE_MUTATED_EVENT_NAME = 'storagemutated';
    const STORAGE_MUTATED_DOM_EVENT_NAME = 'x-storagemutated-1';
    const globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);

    class Transaction {
        _lock() {
            assert(!PSD.global);
            ++this._reculock;
            if (this._reculock === 1 && !PSD.global)
                PSD.lockOwnerFor = this;
            return this;
        }
        _unlock() {
            assert(!PSD.global);
            if (--this._reculock === 0) {
                if (!PSD.global)
                    PSD.lockOwnerFor = null;
                while (this._blockedFuncs.length > 0 && !this._locked()) {
                    var fnAndPSD = this._blockedFuncs.shift();
                    try {
                        usePSD(fnAndPSD[1], fnAndPSD[0]);
                    }
                    catch (e) { }
                }
            }
            return this;
        }
        _locked() {
            return this._reculock && PSD.lockOwnerFor !== this;
        }
        create(idbtrans) {
            if (!this.mode)
                return this;
            const idbdb = this.db.idbdb;
            const dbOpenError = this.db._state.dbOpenError;
            assert(!this.idbtrans);
            if (!idbtrans && !idbdb) {
                switch (dbOpenError && dbOpenError.name) {
                    case "DatabaseClosedError":
                        throw new exceptions.DatabaseClosed(dbOpenError);
                    case "MissingAPIError":
                        throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);
                    default:
                        throw new exceptions.OpenFailed(dbOpenError);
                }
            }
            if (!this.active)
                throw new exceptions.TransactionInactive();
            assert(this._completion._state === null);
            idbtrans = this.idbtrans = idbtrans ||
                (this.db.core
                    ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })
                    : idbdb.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }));
            idbtrans.onerror = wrap(ev => {
                preventDefault(ev);
                this._reject(idbtrans.error);
            });
            idbtrans.onabort = wrap(ev => {
                preventDefault(ev);
                this.active && this._reject(new exceptions.Abort(idbtrans.error));
                this.active = false;
                this.on("abort").fire(ev);
            });
            idbtrans.oncomplete = wrap(() => {
                this.active = false;
                this._resolve();
                if ('mutatedParts' in idbtrans) {
                    globalEvents.storagemutated.fire(idbtrans["mutatedParts"]);
                }
            });
            return this;
        }
        _promise(mode, fn, bWriteLock) {
            if (mode === 'readwrite' && this.mode !== 'readwrite')
                return rejection(new exceptions.ReadOnly("Transaction is readonly"));
            if (!this.active)
                return rejection(new exceptions.TransactionInactive());
            if (this._locked()) {
                return new DexiePromise((resolve, reject) => {
                    this._blockedFuncs.push([() => {
                            this._promise(mode, fn, bWriteLock).then(resolve, reject);
                        }, PSD]);
                });
            }
            else if (bWriteLock) {
                return newScope(() => {
                    var p = new DexiePromise((resolve, reject) => {
                        this._lock();
                        const rv = fn(resolve, reject, this);
                        if (rv && rv.then)
                            rv.then(resolve, reject);
                    });
                    p.finally(() => this._unlock());
                    p._lib = true;
                    return p;
                });
            }
            else {
                var p = new DexiePromise((resolve, reject) => {
                    var rv = fn(resolve, reject, this);
                    if (rv && rv.then)
                        rv.then(resolve, reject);
                });
                p._lib = true;
                return p;
            }
        }
        _root() {
            return this.parent ? this.parent._root() : this;
        }
        waitFor(promiseLike) {
            var root = this._root();
            const promise = DexiePromise.resolve(promiseLike);
            if (root._waitingFor) {
                root._waitingFor = root._waitingFor.then(() => promise);
            }
            else {
                root._waitingFor = promise;
                root._waitingQueue = [];
                var store = root.idbtrans.objectStore(root.storeNames[0]);
                (function spin() {
                    ++root._spinCount;
                    while (root._waitingQueue.length)
                        (root._waitingQueue.shift())();
                    if (root._waitingFor)
                        store.get(-Infinity).onsuccess = spin;
                }());
            }
            var currentWaitPromise = root._waitingFor;
            return new DexiePromise((resolve, reject) => {
                promise.then(res => root._waitingQueue.push(wrap(resolve.bind(null, res))), err => root._waitingQueue.push(wrap(reject.bind(null, err)))).finally(() => {
                    if (root._waitingFor === currentWaitPromise) {
                        root._waitingFor = null;
                    }
                });
            });
        }
        abort() {
            if (this.active) {
                this.active = false;
                if (this.idbtrans)
                    this.idbtrans.abort();
                this._reject(new exceptions.Abort());
            }
        }
        table(tableName) {
            const memoizedTables = (this._memoizedTables || (this._memoizedTables = {}));
            if (hasOwn$1(memoizedTables, tableName))
                return memoizedTables[tableName];
            const tableSchema = this.schema[tableName];
            if (!tableSchema) {
                throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
            }
            const transactionBoundTable = new this.db.Table(tableName, tableSchema, this);
            transactionBoundTable.core = this.db.core.table(tableName);
            memoizedTables[tableName] = transactionBoundTable;
            return transactionBoundTable;
        }
    }

    function createTransactionConstructor(db) {
        return makeClassConstructor(Transaction.prototype, function Transaction(mode, storeNames, dbschema, chromeTransactionDurability, parent) {
            this.db = db;
            this.mode = mode;
            this.storeNames = storeNames;
            this.schema = dbschema;
            this.chromeTransactionDurability = chromeTransactionDurability;
            this.idbtrans = null;
            this.on = Events(this, "complete", "error", "abort");
            this.parent = parent || null;
            this.active = true;
            this._reculock = 0;
            this._blockedFuncs = [];
            this._resolve = null;
            this._reject = null;
            this._waitingFor = null;
            this._waitingQueue = null;
            this._spinCount = 0;
            this._completion = new DexiePromise((resolve, reject) => {
                this._resolve = resolve;
                this._reject = reject;
            });
            this._completion.then(() => {
                this.active = false;
                this.on.complete.fire();
            }, e => {
                var wasActive = this.active;
                this.active = false;
                this.on.error.fire(e);
                this.parent ?
                    this.parent._reject(e) :
                    wasActive && this.idbtrans && this.idbtrans.abort();
                return rejection(e);
            });
        });
    }

    function createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey) {
        return {
            name,
            keyPath,
            unique,
            multi,
            auto,
            compound,
            src: (unique && !isPrimKey ? '&' : '') + (multi ? '*' : '') + (auto ? "++" : "") + nameFromKeyPath(keyPath)
        };
    }
    function nameFromKeyPath(keyPath) {
        return typeof keyPath === 'string' ?
            keyPath :
            keyPath ? ('[' + [].join.call(keyPath, '+') + ']') : "";
    }

    function createTableSchema(name, primKey, indexes) {
        return {
            name,
            primKey,
            indexes,
            mappedClass: null,
            idxByName: arrayToObject(indexes, index => [index.name, index])
        };
    }

    function safariMultiStoreFix(storeNames) {
        return storeNames.length === 1 ? storeNames[0] : storeNames;
    }
    let getMaxKey = (IdbKeyRange) => {
        try {
            IdbKeyRange.only([[]]);
            getMaxKey = () => [[]];
            return [[]];
        }
        catch (e) {
            getMaxKey = () => maxString;
            return maxString;
        }
    };

    function getKeyExtractor(keyPath) {
        if (keyPath == null) {
            return () => undefined;
        }
        else if (typeof keyPath === 'string') {
            return getSinglePathKeyExtractor(keyPath);
        }
        else {
            return obj => getByKeyPath(obj, keyPath);
        }
    }
    function getSinglePathKeyExtractor(keyPath) {
        const split = keyPath.split('.');
        if (split.length === 1) {
            return obj => obj[keyPath];
        }
        else {
            return obj => getByKeyPath(obj, keyPath);
        }
    }

    function arrayify(arrayLike) {
        return [].slice.call(arrayLike);
    }
    let _id_counter = 0;
    function getKeyPathAlias(keyPath) {
        return keyPath == null ?
            ":id" :
            typeof keyPath === 'string' ?
                keyPath :
                `[${keyPath.join('+')}]`;
    }
    function createDBCore(db, IdbKeyRange, tmpTrans) {
        function extractSchema(db, trans) {
            const tables = arrayify(db.objectStoreNames);
            return {
                schema: {
                    name: db.name,
                    tables: tables.map(table => trans.objectStore(table)).map(store => {
                        const { keyPath, autoIncrement } = store;
                        const compound = isArray$1(keyPath);
                        const outbound = keyPath == null;
                        const indexByKeyPath = {};
                        const result = {
                            name: store.name,
                            primaryKey: {
                                name: null,
                                isPrimaryKey: true,
                                outbound,
                                compound,
                                keyPath,
                                autoIncrement,
                                unique: true,
                                extractKey: getKeyExtractor(keyPath)
                            },
                            indexes: arrayify(store.indexNames).map(indexName => store.index(indexName))
                                .map(index => {
                                const { name, unique, multiEntry, keyPath } = index;
                                const compound = isArray$1(keyPath);
                                const result = {
                                    name,
                                    compound,
                                    keyPath,
                                    unique,
                                    multiEntry,
                                    extractKey: getKeyExtractor(keyPath)
                                };
                                indexByKeyPath[getKeyPathAlias(keyPath)] = result;
                                return result;
                            }),
                            getIndexByKeyPath: (keyPath) => indexByKeyPath[getKeyPathAlias(keyPath)]
                        };
                        indexByKeyPath[":id"] = result.primaryKey;
                        if (keyPath != null) {
                            indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;
                        }
                        return result;
                    })
                },
                hasGetAll: tables.length > 0 && ('getAll' in trans.objectStore(tables[0])) &&
                    !(typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&
                        !/(Chrome\/|Edge\/)/.test(navigator.userAgent) &&
                        [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604)
            };
        }
        function makeIDBKeyRange(range) {
            if (range.type === 3 )
                return null;
            if (range.type === 4 )
                throw new Error("Cannot convert never type to IDBKeyRange");
            const { lower, upper, lowerOpen, upperOpen } = range;
            const idbRange = lower === undefined ?
                upper === undefined ?
                    null :
                    IdbKeyRange.upperBound(upper, !!upperOpen) :
                upper === undefined ?
                    IdbKeyRange.lowerBound(lower, !!lowerOpen) :
                    IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);
            return idbRange;
        }
        function createDbCoreTable(tableSchema) {
            const tableName = tableSchema.name;
            function mutate({ trans, type, keys, values, range }) {
                return new Promise((resolve, reject) => {
                    resolve = wrap(resolve);
                    const store = trans.objectStore(tableName);
                    const outbound = store.keyPath == null;
                    const isAddOrPut = type === "put" || type === "add";
                    if (!isAddOrPut && type !== 'delete' && type !== 'deleteRange')
                        throw new Error("Invalid operation type: " + type);
                    const { length } = keys || values || { length: 1 };
                    if (keys && values && keys.length !== values.length) {
                        throw new Error("Given keys array must have same length as given values array.");
                    }
                    if (length === 0)
                        return resolve({ numFailures: 0, failures: {}, results: [], lastResult: undefined });
                    let req;
                    const reqs = [];
                    const failures = [];
                    let numFailures = 0;
                    const errorHandler = event => {
                        ++numFailures;
                        preventDefault(event);
                    };
                    if (type === 'deleteRange') {
                        if (range.type === 4 )
                            return resolve({ numFailures, failures, results: [], lastResult: undefined });
                        if (range.type === 3 )
                            reqs.push(req = store.clear());
                        else
                            reqs.push(req = store.delete(makeIDBKeyRange(range)));
                    }
                    else {
                        const [args1, args2] = isAddOrPut ?
                            outbound ?
                                [values, keys] :
                                [values, null] :
                            [keys, null];
                        if (isAddOrPut) {
                            for (let i = 0; i < length; ++i) {
                                reqs.push(req = (args2 && args2[i] !== undefined ?
                                    store[type](args1[i], args2[i]) :
                                    store[type](args1[i])));
                                req.onerror = errorHandler;
                            }
                        }
                        else {
                            for (let i = 0; i < length; ++i) {
                                reqs.push(req = store[type](args1[i]));
                                req.onerror = errorHandler;
                            }
                        }
                    }
                    const done = event => {
                        const lastResult = event.target.result;
                        reqs.forEach((req, i) => req.error != null && (failures[i] = req.error));
                        resolve({
                            numFailures,
                            failures,
                            results: type === "delete" ? keys : reqs.map(req => req.result),
                            lastResult
                        });
                    };
                    req.onerror = event => {
                        errorHandler(event);
                        done(event);
                    };
                    req.onsuccess = done;
                });
            }
            function openCursor({ trans, values, query, reverse, unique }) {
                return new Promise((resolve, reject) => {
                    resolve = wrap(resolve);
                    const { index, range } = query;
                    const store = trans.objectStore(tableName);
                    const source = index.isPrimaryKey ?
                        store :
                        store.index(index.name);
                    const direction = reverse ?
                        unique ?
                            "prevunique" :
                            "prev" :
                        unique ?
                            "nextunique" :
                            "next";
                    const req = values || !('openKeyCursor' in source) ?
                        source.openCursor(makeIDBKeyRange(range), direction) :
                        source.openKeyCursor(makeIDBKeyRange(range), direction);
                    req.onerror = eventRejectHandler(reject);
                    req.onsuccess = wrap(ev => {
                        const cursor = req.result;
                        if (!cursor) {
                            resolve(null);
                            return;
                        }
                        cursor.___id = ++_id_counter;
                        cursor.done = false;
                        const _cursorContinue = cursor.continue.bind(cursor);
                        let _cursorContinuePrimaryKey = cursor.continuePrimaryKey;
                        if (_cursorContinuePrimaryKey)
                            _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);
                        const _cursorAdvance = cursor.advance.bind(cursor);
                        const doThrowCursorIsNotStarted = () => { throw new Error("Cursor not started"); };
                        const doThrowCursorIsStopped = () => { throw new Error("Cursor not stopped"); };
                        cursor.trans = trans;
                        cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;
                        cursor.fail = wrap(reject);
                        cursor.next = function () {
                            let gotOne = 1;
                            return this.start(() => gotOne-- ? this.continue() : this.stop()).then(() => this);
                        };
                        cursor.start = (callback) => {
                            const iterationPromise = new Promise((resolveIteration, rejectIteration) => {
                                resolveIteration = wrap(resolveIteration);
                                req.onerror = eventRejectHandler(rejectIteration);
                                cursor.fail = rejectIteration;
                                cursor.stop = value => {
                                    cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;
                                    resolveIteration(value);
                                };
                            });
                            const guardedCallback = () => {
                                if (req.result) {
                                    try {
                                        callback();
                                    }
                                    catch (err) {
                                        cursor.fail(err);
                                    }
                                }
                                else {
                                    cursor.done = true;
                                    cursor.start = () => { throw new Error("Cursor behind last entry"); };
                                    cursor.stop();
                                }
                            };
                            req.onsuccess = wrap(ev => {
                                req.onsuccess = guardedCallback;
                                guardedCallback();
                            });
                            cursor.continue = _cursorContinue;
                            cursor.continuePrimaryKey = _cursorContinuePrimaryKey;
                            cursor.advance = _cursorAdvance;
                            guardedCallback();
                            return iterationPromise;
                        };
                        resolve(cursor);
                    }, reject);
                });
            }
            function query(hasGetAll) {
                return (request) => {
                    return new Promise((resolve, reject) => {
                        resolve = wrap(resolve);
                        const { trans, values, limit, query } = request;
                        const nonInfinitLimit = limit === Infinity ? undefined : limit;
                        const { index, range } = query;
                        const store = trans.objectStore(tableName);
                        const source = index.isPrimaryKey ? store : store.index(index.name);
                        const idbKeyRange = makeIDBKeyRange(range);
                        if (limit === 0)
                            return resolve({ result: [] });
                        if (hasGetAll) {
                            const req = values ?
                                source.getAll(idbKeyRange, nonInfinitLimit) :
                                source.getAllKeys(idbKeyRange, nonInfinitLimit);
                            req.onsuccess = event => resolve({ result: event.target.result });
                            req.onerror = eventRejectHandler(reject);
                        }
                        else {
                            let count = 0;
                            const req = values || !('openKeyCursor' in source) ?
                                source.openCursor(idbKeyRange) :
                                source.openKeyCursor(idbKeyRange);
                            const result = [];
                            req.onsuccess = event => {
                                const cursor = req.result;
                                if (!cursor)
                                    return resolve({ result });
                                result.push(values ? cursor.value : cursor.primaryKey);
                                if (++count === limit)
                                    return resolve({ result });
                                cursor.continue();
                            };
                            req.onerror = eventRejectHandler(reject);
                        }
                    });
                };
            }
            return {
                name: tableName,
                schema: tableSchema,
                mutate,
                getMany({ trans, keys }) {
                    return new Promise((resolve, reject) => {
                        resolve = wrap(resolve);
                        const store = trans.objectStore(tableName);
                        const length = keys.length;
                        const result = new Array(length);
                        let keyCount = 0;
                        let callbackCount = 0;
                        let req;
                        const successHandler = event => {
                            const req = event.target;
                            if ((result[req._pos] = req.result) != null)
                                ;
                            if (++callbackCount === keyCount)
                                resolve(result);
                        };
                        const errorHandler = eventRejectHandler(reject);
                        for (let i = 0; i < length; ++i) {
                            const key = keys[i];
                            if (key != null) {
                                req = store.get(keys[i]);
                                req._pos = i;
                                req.onsuccess = successHandler;
                                req.onerror = errorHandler;
                                ++keyCount;
                            }
                        }
                        if (keyCount === 0)
                            resolve(result);
                    });
                },
                get({ trans, key }) {
                    return new Promise((resolve, reject) => {
                        resolve = wrap(resolve);
                        const store = trans.objectStore(tableName);
                        const req = store.get(key);
                        req.onsuccess = event => resolve(event.target.result);
                        req.onerror = eventRejectHandler(reject);
                    });
                },
                query: query(hasGetAll),
                openCursor,
                count({ query, trans }) {
                    const { index, range } = query;
                    return new Promise((resolve, reject) => {
                        const store = trans.objectStore(tableName);
                        const source = index.isPrimaryKey ? store : store.index(index.name);
                        const idbKeyRange = makeIDBKeyRange(range);
                        const req = idbKeyRange ? source.count(idbKeyRange) : source.count();
                        req.onsuccess = wrap(ev => resolve(ev.target.result));
                        req.onerror = eventRejectHandler(reject);
                    });
                }
            };
        }
        const { schema, hasGetAll } = extractSchema(db, tmpTrans);
        const tables = schema.tables.map(tableSchema => createDbCoreTable(tableSchema));
        const tableMap = {};
        tables.forEach(table => tableMap[table.name] = table);
        return {
            stack: "dbcore",
            transaction: db.transaction.bind(db),
            table(name) {
                const result = tableMap[name];
                if (!result)
                    throw new Error(`Table '${name}' not found`);
                return tableMap[name];
            },
            MIN_KEY: -Infinity,
            MAX_KEY: getMaxKey(IdbKeyRange),
            schema
        };
    }

    function createMiddlewareStack(stackImpl, middlewares) {
        return middlewares.reduce((down, { create }) => ({ ...down, ...create(down) }), stackImpl);
    }
    function createMiddlewareStacks(middlewares, idbdb, { IDBKeyRange, indexedDB }, tmpTrans) {
        const dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange, tmpTrans), middlewares.dbcore);
        return {
            dbcore
        };
    }
    function generateMiddlewareStacks({ _novip: db }, tmpTrans) {
        const idbdb = tmpTrans.db;
        const stacks = createMiddlewareStacks(db._middlewares, idbdb, db._deps, tmpTrans);
        db.core = stacks.dbcore;
        db.tables.forEach(table => {
            const tableName = table.name;
            if (db.core.schema.tables.some(tbl => tbl.name === tableName)) {
                table.core = db.core.table(tableName);
                if (db[tableName] instanceof db.Table) {
                    db[tableName].core = table.core;
                }
            }
        });
    }

    function setApiOnPlace({ _novip: db }, objs, tableNames, dbschema) {
        tableNames.forEach(tableName => {
            const schema = dbschema[tableName];
            objs.forEach(obj => {
                const propDesc = getPropertyDescriptor(obj, tableName);
                if (!propDesc || ("value" in propDesc && propDesc.value === undefined)) {
                    if (obj === db.Transaction.prototype || obj instanceof db.Transaction) {
                        setProp(obj, tableName, {
                            get() { return this.table(tableName); },
                            set(value) {
                                defineProperty(this, tableName, { value, writable: true, configurable: true, enumerable: true });
                            }
                        });
                    }
                    else {
                        obj[tableName] = new db.Table(tableName, schema);
                    }
                }
            });
        });
    }
    function removeTablesApi({ _novip: db }, objs) {
        objs.forEach(obj => {
            for (let key in obj) {
                if (obj[key] instanceof db.Table)
                    delete obj[key];
            }
        });
    }
    function lowerVersionFirst(a, b) {
        return a._cfg.version - b._cfg.version;
    }
    function runUpgraders(db, oldVersion, idbUpgradeTrans, reject) {
        const globalSchema = db._dbSchema;
        const trans = db._createTransaction('readwrite', db._storeNames, globalSchema);
        trans.create(idbUpgradeTrans);
        trans._completion.catch(reject);
        const rejectTransaction = trans._reject.bind(trans);
        const transless = PSD.transless || PSD;
        newScope(() => {
            PSD.trans = trans;
            PSD.transless = transless;
            if (oldVersion === 0) {
                keys(globalSchema).forEach(tableName => {
                    createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);
                });
                generateMiddlewareStacks(db, idbUpgradeTrans);
                DexiePromise.follow(() => db.on.populate.fire(trans)).catch(rejectTransaction);
            }
            else
                updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans).catch(rejectTransaction);
        });
    }
    function updateTablesAndIndexes({ _novip: db }, oldVersion, trans, idbUpgradeTrans) {
        const queue = [];
        const versions = db._versions;
        let globalSchema = db._dbSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);
        let anyContentUpgraderHasRun = false;
        const versToRun = versions.filter(v => v._cfg.version >= oldVersion);
        versToRun.forEach(version => {
            queue.push(() => {
                const oldSchema = globalSchema;
                const newSchema = version._cfg.dbschema;
                adjustToExistingIndexNames(db, oldSchema, idbUpgradeTrans);
                adjustToExistingIndexNames(db, newSchema, idbUpgradeTrans);
                globalSchema = db._dbSchema = newSchema;
                const diff = getSchemaDiff(oldSchema, newSchema);
                diff.add.forEach(tuple => {
                    createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);
                });
                diff.change.forEach(change => {
                    if (change.recreate) {
                        throw new exceptions.Upgrade("Not yet support for changing primary key");
                    }
                    else {
                        const store = idbUpgradeTrans.objectStore(change.name);
                        change.add.forEach(idx => addIndex(store, idx));
                        change.change.forEach(idx => {
                            store.deleteIndex(idx.name);
                            addIndex(store, idx);
                        });
                        change.del.forEach(idxName => store.deleteIndex(idxName));
                    }
                });
                const contentUpgrade = version._cfg.contentUpgrade;
                if (contentUpgrade && version._cfg.version > oldVersion) {
                    generateMiddlewareStacks(db, idbUpgradeTrans);
                    trans._memoizedTables = {};
                    anyContentUpgraderHasRun = true;
                    let upgradeSchema = shallowClone(newSchema);
                    diff.del.forEach(table => {
                        upgradeSchema[table] = oldSchema[table];
                    });
                    removeTablesApi(db, [db.Transaction.prototype]);
                    setApiOnPlace(db, [db.Transaction.prototype], keys(upgradeSchema), upgradeSchema);
                    trans.schema = upgradeSchema;
                    const contentUpgradeIsAsync = isAsyncFunction(contentUpgrade);
                    if (contentUpgradeIsAsync) {
                        incrementExpectedAwaits();
                    }
                    let returnValue;
                    const promiseFollowed = DexiePromise.follow(() => {
                        returnValue = contentUpgrade(trans);
                        if (returnValue) {
                            if (contentUpgradeIsAsync) {
                                var decrementor = decrementExpectedAwaits.bind(null, null);
                                returnValue.then(decrementor, decrementor);
                            }
                        }
                    });
                    return (returnValue && typeof returnValue.then === 'function' ?
                        DexiePromise.resolve(returnValue) : promiseFollowed.then(() => returnValue));
                }
            });
            queue.push(idbtrans => {
                if (!anyContentUpgraderHasRun || !hasIEDeleteObjectStoreBug) {
                    const newSchema = version._cfg.dbschema;
                    deleteRemovedTables(newSchema, idbtrans);
                }
                removeTablesApi(db, [db.Transaction.prototype]);
                setApiOnPlace(db, [db.Transaction.prototype], db._storeNames, db._dbSchema);
                trans.schema = db._dbSchema;
            });
        });
        function runQueue() {
            return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) :
                DexiePromise.resolve();
        }
        return runQueue().then(() => {
            createMissingTables(globalSchema, idbUpgradeTrans);
        });
    }
    function getSchemaDiff(oldSchema, newSchema) {
        const diff = {
            del: [],
            add: [],
            change: []
        };
        let table;
        for (table in oldSchema) {
            if (!newSchema[table])
                diff.del.push(table);
        }
        for (table in newSchema) {
            const oldDef = oldSchema[table], newDef = newSchema[table];
            if (!oldDef) {
                diff.add.push([table, newDef]);
            }
            else {
                const change = {
                    name: table,
                    def: newDef,
                    recreate: false,
                    del: [],
                    add: [],
                    change: []
                };
                if ((
                '' + (oldDef.primKey.keyPath || '')) !== ('' + (newDef.primKey.keyPath || '')) ||
                    (oldDef.primKey.auto !== newDef.primKey.auto && !isIEOrEdge))
                 {
                    change.recreate = true;
                    diff.change.push(change);
                }
                else {
                    const oldIndexes = oldDef.idxByName;
                    const newIndexes = newDef.idxByName;
                    let idxName;
                    for (idxName in oldIndexes) {
                        if (!newIndexes[idxName])
                            change.del.push(idxName);
                    }
                    for (idxName in newIndexes) {
                        const oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];
                        if (!oldIdx)
                            change.add.push(newIdx);
                        else if (oldIdx.src !== newIdx.src)
                            change.change.push(newIdx);
                    }
                    if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {
                        diff.change.push(change);
                    }
                }
            }
        }
        return diff;
    }
    function createTable(idbtrans, tableName, primKey, indexes) {
        const store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ?
            { keyPath: primKey.keyPath, autoIncrement: primKey.auto } :
            { autoIncrement: primKey.auto });
        indexes.forEach(idx => addIndex(store, idx));
        return store;
    }
    function createMissingTables(newSchema, idbtrans) {
        keys(newSchema).forEach(tableName => {
            if (!idbtrans.db.objectStoreNames.contains(tableName)) {
                createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);
            }
        });
    }
    function deleteRemovedTables(newSchema, idbtrans) {
        [].slice.call(idbtrans.db.objectStoreNames).forEach(storeName => newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName));
    }
    function addIndex(store, idx) {
        store.createIndex(idx.name, idx.keyPath, { unique: idx.unique, multiEntry: idx.multi });
    }
    function buildGlobalSchema(db, idbdb, tmpTrans) {
        const globalSchema = {};
        const dbStoreNames = slice(idbdb.objectStoreNames, 0);
        dbStoreNames.forEach(storeName => {
            const store = tmpTrans.objectStore(storeName);
            let keyPath = store.keyPath;
            const primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || "", false, false, !!store.autoIncrement, keyPath && typeof keyPath !== "string", true);
            const indexes = [];
            for (let j = 0; j < store.indexNames.length; ++j) {
                const idbindex = store.index(store.indexNames[j]);
                keyPath = idbindex.keyPath;
                var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== "string", false);
                indexes.push(index);
            }
            globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);
        });
        return globalSchema;
    }
    function readGlobalSchema({ _novip: db }, idbdb, tmpTrans) {
        db.verno = idbdb.version / 10;
        const globalSchema = db._dbSchema = buildGlobalSchema(db, idbdb, tmpTrans);
        db._storeNames = slice(idbdb.objectStoreNames, 0);
        setApiOnPlace(db, [db._allTables], keys(globalSchema), globalSchema);
    }
    function verifyInstalledSchema(db, tmpTrans) {
        const installedSchema = buildGlobalSchema(db, db.idbdb, tmpTrans);
        const diff = getSchemaDiff(installedSchema, db._dbSchema);
        return !(diff.add.length || diff.change.some(ch => ch.add.length || ch.change.length));
    }
    function adjustToExistingIndexNames({ _novip: db }, schema, idbtrans) {
        const storeNames = idbtrans.db.objectStoreNames;
        for (let i = 0; i < storeNames.length; ++i) {
            const storeName = storeNames[i];
            const store = idbtrans.objectStore(storeName);
            db._hasGetAll = 'getAll' in store;
            for (let j = 0; j < store.indexNames.length; ++j) {
                const indexName = store.indexNames[j];
                const keyPath = store.index(indexName).keyPath;
                const dexieName = typeof keyPath === 'string' ? keyPath : "[" + slice(keyPath).join('+') + "]";
                if (schema[storeName]) {
                    const indexSpec = schema[storeName].idxByName[dexieName];
                    if (indexSpec) {
                        indexSpec.name = indexName;
                        delete schema[storeName].idxByName[dexieName];
                        schema[storeName].idxByName[indexName] = indexSpec;
                    }
                }
            }
        }
        if (typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&
            !/(Chrome\/|Edge\/)/.test(navigator.userAgent) &&
            _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope &&
            [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) {
            db._hasGetAll = false;
        }
    }
    function parseIndexSyntax(primKeyAndIndexes) {
        return primKeyAndIndexes.split(',').map((index, indexNum) => {
            index = index.trim();
            const name = index.replace(/([&*]|\+\+)/g, "");
            const keyPath = /^\[/.test(name) ? name.match(/^\[(.*)\]$/)[1].split('+') : name;
            return createIndexSpec(name, keyPath || null, /\&/.test(index), /\*/.test(index), /\+\+/.test(index), isArray$1(keyPath), indexNum === 0);
        });
    }

    class Version {
        _parseStoresSpec(stores, outSchema) {
            keys(stores).forEach(tableName => {
                if (stores[tableName] !== null) {
                    var indexes = parseIndexSyntax(stores[tableName]);
                    var primKey = indexes.shift();
                    if (primKey.multi)
                        throw new exceptions.Schema("Primary key cannot be multi-valued");
                    indexes.forEach(idx => {
                        if (idx.auto)
                            throw new exceptions.Schema("Only primary key can be marked as autoIncrement (++)");
                        if (!idx.keyPath)
                            throw new exceptions.Schema("Index must have a name and cannot be an empty string");
                    });
                    outSchema[tableName] = createTableSchema(tableName, primKey, indexes);
                }
            });
        }
        stores(stores) {
            const db = this.db;
            this._cfg.storesSource = this._cfg.storesSource ?
                extend$1(this._cfg.storesSource, stores) :
                stores;
            const versions = db._versions;
            const storesSpec = {};
            let dbschema = {};
            versions.forEach(version => {
                extend$1(storesSpec, version._cfg.storesSource);
                dbschema = (version._cfg.dbschema = {});
                version._parseStoresSpec(storesSpec, dbschema);
            });
            db._dbSchema = dbschema;
            removeTablesApi(db, [db._allTables, db, db.Transaction.prototype]);
            setApiOnPlace(db, [db._allTables, db, db.Transaction.prototype, this._cfg.tables], keys(dbschema), dbschema);
            db._storeNames = keys(dbschema);
            return this;
        }
        upgrade(upgradeFunction) {
            this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);
            return this;
        }
    }

    function createVersionConstructor(db) {
        return makeClassConstructor(Version.prototype, function Version(versionNumber) {
            this.db = db;
            this._cfg = {
                version: versionNumber,
                storesSource: null,
                dbschema: {},
                tables: {},
                contentUpgrade: null
            };
        });
    }

    function getDbNamesTable(indexedDB, IDBKeyRange) {
        let dbNamesDB = indexedDB["_dbNamesDB"];
        if (!dbNamesDB) {
            dbNamesDB = indexedDB["_dbNamesDB"] = new Dexie$1(DBNAMES_DB, {
                addons: [],
                indexedDB,
                IDBKeyRange,
            });
            dbNamesDB.version(1).stores({ dbnames: "name" });
        }
        return dbNamesDB.table("dbnames");
    }
    function hasDatabasesNative(indexedDB) {
        return indexedDB && typeof indexedDB.databases === "function";
    }
    function getDatabaseNames({ indexedDB, IDBKeyRange, }) {
        return hasDatabasesNative(indexedDB)
            ? Promise.resolve(indexedDB.databases()).then((infos) => infos
                .map((info) => info.name)
                .filter((name) => name !== DBNAMES_DB))
            : getDbNamesTable(indexedDB, IDBKeyRange).toCollection().primaryKeys();
    }
    function _onDatabaseCreated({ indexedDB, IDBKeyRange }, name) {
        !hasDatabasesNative(indexedDB) &&
            name !== DBNAMES_DB &&
            getDbNamesTable(indexedDB, IDBKeyRange).put({ name }).catch(nop);
    }
    function _onDatabaseDeleted({ indexedDB, IDBKeyRange }, name) {
        !hasDatabasesNative(indexedDB) &&
            name !== DBNAMES_DB &&
            getDbNamesTable(indexedDB, IDBKeyRange).delete(name).catch(nop);
    }

    function vip(fn) {
        return newScope(function () {
            PSD.letThrough = true;
            return fn();
        });
    }

    function idbReady() {
        var isSafari = !navigator.userAgentData &&
            /Safari\//.test(navigator.userAgent) &&
            !/Chrom(e|ium)\//.test(navigator.userAgent);
        if (!isSafari || !indexedDB.databases)
            return Promise.resolve();
        var intervalId;
        return new Promise(function (resolve) {
            var tryIdb = function () { return indexedDB.databases().finally(resolve); };
            intervalId = setInterval(tryIdb, 100);
            tryIdb();
        }).finally(function () { return clearInterval(intervalId); });
    }

    function dexieOpen(db) {
        const state = db._state;
        const { indexedDB } = db._deps;
        if (state.isBeingOpened || db.idbdb)
            return state.dbReadyPromise.then(() => state.dbOpenError ?
                rejection(state.dbOpenError) :
                db);
        debug && (state.openCanceller._stackHolder = getErrorWithStack());
        state.isBeingOpened = true;
        state.dbOpenError = null;
        state.openComplete = false;
        const openCanceller = state.openCanceller;
        function throwIfCancelled() {
            if (state.openCanceller !== openCanceller)
                throw new exceptions.DatabaseClosed('db.open() was cancelled');
        }
        let resolveDbReady = state.dbReadyResolve,
        upgradeTransaction = null, wasCreated = false;
        return DexiePromise.race([openCanceller, (typeof navigator === 'undefined' ? DexiePromise.resolve() : idbReady()).then(() => new DexiePromise((resolve, reject) => {
                throwIfCancelled();
                if (!indexedDB)
                    throw new exceptions.MissingAPI();
                const dbName = db.name;
                const req = state.autoSchema ?
                    indexedDB.open(dbName) :
                    indexedDB.open(dbName, Math.round(db.verno * 10));
                if (!req)
                    throw new exceptions.MissingAPI();
                req.onerror = eventRejectHandler(reject);
                req.onblocked = wrap(db._fireOnBlocked);
                req.onupgradeneeded = wrap(e => {
                    upgradeTransaction = req.transaction;
                    if (state.autoSchema && !db._options.allowEmptyDB) {
                        req.onerror = preventDefault;
                        upgradeTransaction.abort();
                        req.result.close();
                        const delreq = indexedDB.deleteDatabase(dbName);
                        delreq.onsuccess = delreq.onerror = wrap(() => {
                            reject(new exceptions.NoSuchDatabase(`Database ${dbName} doesnt exist`));
                        });
                    }
                    else {
                        upgradeTransaction.onerror = eventRejectHandler(reject);
                        var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;
                        wasCreated = oldVer < 1;
                        db._novip.idbdb = req.result;
                        runUpgraders(db, oldVer / 10, upgradeTransaction, reject);
                    }
                }, reject);
                req.onsuccess = wrap(() => {
                    upgradeTransaction = null;
                    const idbdb = db._novip.idbdb = req.result;
                    const objectStoreNames = slice(idbdb.objectStoreNames);
                    if (objectStoreNames.length > 0)
                        try {
                            const tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), 'readonly');
                            if (state.autoSchema)
                                readGlobalSchema(db, idbdb, tmpTrans);
                            else {
                                adjustToExistingIndexNames(db, db._dbSchema, tmpTrans);
                                if (!verifyInstalledSchema(db, tmpTrans)) {
                                    console.warn(`Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.`);
                                }
                            }
                            generateMiddlewareStacks(db, tmpTrans);
                        }
                        catch (e) {
                        }
                    connections.push(db);
                    idbdb.onversionchange = wrap(ev => {
                        state.vcFired = true;
                        db.on("versionchange").fire(ev);
                    });
                    idbdb.onclose = wrap(ev => {
                        db.on("close").fire(ev);
                    });
                    if (wasCreated)
                        _onDatabaseCreated(db._deps, dbName);
                    resolve();
                }, reject);
            }))]).then(() => {
            throwIfCancelled();
            state.onReadyBeingFired = [];
            return DexiePromise.resolve(vip(() => db.on.ready.fire(db.vip))).then(function fireRemainders() {
                if (state.onReadyBeingFired.length > 0) {
                    let remainders = state.onReadyBeingFired.reduce(promisableChain, nop);
                    state.onReadyBeingFired = [];
                    return DexiePromise.resolve(vip(() => remainders(db.vip))).then(fireRemainders);
                }
            });
        }).finally(() => {
            state.onReadyBeingFired = null;
            state.isBeingOpened = false;
        }).then(() => {
            return db;
        }).catch(err => {
            state.dbOpenError = err;
            try {
                upgradeTransaction && upgradeTransaction.abort();
            }
            catch (_a) { }
            if (openCanceller === state.openCanceller) {
                db._close();
            }
            return rejection(err);
        }).finally(() => {
            state.openComplete = true;
            resolveDbReady();
        });
    }

    function awaitIterator(iterator) {
        var callNext = result => iterator.next(result), doThrow = error => iterator.throw(error), onSuccess = step(callNext), onError = step(doThrow);
        function step(getNext) {
            return (val) => {
                var next = getNext(val), value = next.value;
                return next.done ? value :
                    (!value || typeof value.then !== 'function' ?
                        isArray$1(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) :
                        value.then(onSuccess, onError));
            };
        }
        return step(callNext)();
    }

    function extractTransactionArgs(mode, _tableArgs_, scopeFunc) {
        var i = arguments.length;
        if (i < 2)
            throw new exceptions.InvalidArgument("Too few arguments");
        var args = new Array(i - 1);
        while (--i)
            args[i - 1] = arguments[i];
        scopeFunc = args.pop();
        var tables = flatten(args);
        return [mode, tables, scopeFunc];
    }
    function enterTransactionScope(db, mode, storeNames, parentTransaction, scopeFunc) {
        return DexiePromise.resolve().then(() => {
            const transless = PSD.transless || PSD;
            const trans = db._createTransaction(mode, storeNames, db._dbSchema, parentTransaction);
            const zoneProps = {
                trans: trans,
                transless: transless
            };
            if (parentTransaction) {
                trans.idbtrans = parentTransaction.idbtrans;
            }
            else {
                try {
                    trans.create();
                    db._state.PR1398_maxLoop = 3;
                }
                catch (ex) {
                    if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {
                        console.warn('Dexie: Need to reopen db');
                        db._close();
                        return db.open().then(() => enterTransactionScope(db, mode, storeNames, null, scopeFunc));
                    }
                    return rejection(ex);
                }
            }
            const scopeFuncIsAsync = isAsyncFunction(scopeFunc);
            if (scopeFuncIsAsync) {
                incrementExpectedAwaits();
            }
            let returnValue;
            const promiseFollowed = DexiePromise.follow(() => {
                returnValue = scopeFunc.call(trans, trans);
                if (returnValue) {
                    if (scopeFuncIsAsync) {
                        var decrementor = decrementExpectedAwaits.bind(null, null);
                        returnValue.then(decrementor, decrementor);
                    }
                    else if (typeof returnValue.next === 'function' && typeof returnValue.throw === 'function') {
                        returnValue = awaitIterator(returnValue);
                    }
                }
            }, zoneProps);
            return (returnValue && typeof returnValue.then === 'function' ?
                DexiePromise.resolve(returnValue).then(x => trans.active ?
                    x
                    : rejection(new exceptions.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn")))
                : promiseFollowed.then(() => returnValue)).then(x => {
                if (parentTransaction)
                    trans._resolve();
                return trans._completion.then(() => x);
            }).catch(e => {
                trans._reject(e);
                return rejection(e);
            });
        });
    }

    function pad(a, value, count) {
        const result = isArray$1(a) ? a.slice() : [a];
        for (let i = 0; i < count; ++i)
            result.push(value);
        return result;
    }
    function createVirtualIndexMiddleware(down) {
        return {
            ...down,
            table(tableName) {
                const table = down.table(tableName);
                const { schema } = table;
                const indexLookup = {};
                const allVirtualIndexes = [];
                function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {
                    const keyPathAlias = getKeyPathAlias(keyPath);
                    const indexList = (indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || []);
                    const keyLength = keyPath == null ? 0 : typeof keyPath === 'string' ? 1 : keyPath.length;
                    const isVirtual = keyTail > 0;
                    const virtualIndex = {
                        ...lowLevelIndex,
                        isVirtual,
                        keyTail,
                        keyLength,
                        extractKey: getKeyExtractor(keyPath),
                        unique: !isVirtual && lowLevelIndex.unique
                    };
                    indexList.push(virtualIndex);
                    if (!virtualIndex.isPrimaryKey) {
                        allVirtualIndexes.push(virtualIndex);
                    }
                    if (keyLength > 1) {
                        const virtualKeyPath = keyLength === 2 ?
                            keyPath[0] :
                            keyPath.slice(0, keyLength - 1);
                        addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);
                    }
                    indexList.sort((a, b) => a.keyTail - b.keyTail);
                    return virtualIndex;
                }
                const primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);
                indexLookup[":id"] = [primaryKey];
                for (const index of schema.indexes) {
                    addVirtualIndexes(index.keyPath, 0, index);
                }
                function findBestIndex(keyPath) {
                    const result = indexLookup[getKeyPathAlias(keyPath)];
                    return result && result[0];
                }
                function translateRange(range, keyTail) {
                    return {
                        type: range.type === 1  ?
                            2  :
                            range.type,
                        lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),
                        lowerOpen: true,
                        upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),
                        upperOpen: true
                    };
                }
                function translateRequest(req) {
                    const index = req.query.index;
                    return index.isVirtual ? {
                        ...req,
                        query: {
                            index,
                            range: translateRange(req.query.range, index.keyTail)
                        }
                    } : req;
                }
                const result = {
                    ...table,
                    schema: {
                        ...schema,
                        primaryKey,
                        indexes: allVirtualIndexes,
                        getIndexByKeyPath: findBestIndex
                    },
                    count(req) {
                        return table.count(translateRequest(req));
                    },
                    query(req) {
                        return table.query(translateRequest(req));
                    },
                    openCursor(req) {
                        const { keyTail, isVirtual, keyLength } = req.query.index;
                        if (!isVirtual)
                            return table.openCursor(req);
                        function createVirtualCursor(cursor) {
                            function _continue(key) {
                                key != null ?
                                    cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) :
                                    req.unique ?
                                        cursor.continue(cursor.key.slice(0, keyLength)
                                            .concat(req.reverse
                                            ? down.MIN_KEY
                                            : down.MAX_KEY, keyTail)) :
                                        cursor.continue();
                            }
                            const virtualCursor = Object.create(cursor, {
                                continue: { value: _continue },
                                continuePrimaryKey: {
                                    value(key, primaryKey) {
                                        cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey);
                                    }
                                },
                                primaryKey: {
                                    get() {
                                        return cursor.primaryKey;
                                    }
                                },
                                key: {
                                    get() {
                                        const key = cursor.key;
                                        return keyLength === 1 ?
                                            key[0] :
                                            key.slice(0, keyLength);
                                    }
                                },
                                value: {
                                    get() {
                                        return cursor.value;
                                    }
                                }
                            });
                            return virtualCursor;
                        }
                        return table.openCursor(translateRequest(req))
                            .then(cursor => cursor && createVirtualCursor(cursor));
                    }
                };
                return result;
            }
        };
    }
    const virtualIndexMiddleware = {
        stack: "dbcore",
        name: "VirtualIndexMiddleware",
        level: 1,
        create: createVirtualIndexMiddleware
    };

    function getObjectDiff(a, b, rv, prfx) {
        rv = rv || {};
        prfx = prfx || '';
        keys(a).forEach((prop) => {
            if (!hasOwn$1(b, prop)) {
                rv[prfx + prop] = undefined;
            }
            else {
                var ap = a[prop], bp = b[prop];
                if (typeof ap === 'object' && typeof bp === 'object' && ap && bp) {
                    const apTypeName = toStringTag(ap);
                    const bpTypeName = toStringTag(bp);
                    if (apTypeName !== bpTypeName) {
                        rv[prfx + prop] = b[prop];
                    }
                    else if (apTypeName === 'Object') {
                        getObjectDiff(ap, bp, rv, prfx + prop + '.');
                    }
                    else if (ap !== bp) {
                        rv[prfx + prop] = b[prop];
                    }
                }
                else if (ap !== bp)
                    rv[prfx + prop] = b[prop];
            }
        });
        keys(b).forEach((prop) => {
            if (!hasOwn$1(a, prop)) {
                rv[prfx + prop] = b[prop];
            }
        });
        return rv;
    }

    function getEffectiveKeys(primaryKey, req) {
        if (req.type === 'delete')
            return req.keys;
        return req.keys || req.values.map(primaryKey.extractKey);
    }

    const hooksMiddleware = {
        stack: "dbcore",
        name: "HooksMiddleware",
        level: 2,
        create: (downCore) => ({
            ...downCore,
            table(tableName) {
                const downTable = downCore.table(tableName);
                const { primaryKey } = downTable.schema;
                const tableMiddleware = {
                    ...downTable,
                    mutate(req) {
                        const dxTrans = PSD.trans;
                        const { deleting, creating, updating } = dxTrans.table(tableName).hook;
                        switch (req.type) {
                            case 'add':
                                if (creating.fire === nop)
                                    break;
                                return dxTrans._promise('readwrite', () => addPutOrDelete(req), true);
                            case 'put':
                                if (creating.fire === nop && updating.fire === nop)
                                    break;
                                return dxTrans._promise('readwrite', () => addPutOrDelete(req), true);
                            case 'delete':
                                if (deleting.fire === nop)
                                    break;
                                return dxTrans._promise('readwrite', () => addPutOrDelete(req), true);
                            case 'deleteRange':
                                if (deleting.fire === nop)
                                    break;
                                return dxTrans._promise('readwrite', () => deleteRange(req), true);
                        }
                        return downTable.mutate(req);
                        function addPutOrDelete(req) {
                            const dxTrans = PSD.trans;
                            const keys = req.keys || getEffectiveKeys(primaryKey, req);
                            if (!keys)
                                throw new Error("Keys missing");
                            req = req.type === 'add' || req.type === 'put' ?
                                { ...req, keys } :
                                { ...req };
                            if (req.type !== 'delete')
                                req.values = [...req.values];
                            if (req.keys)
                                req.keys = [...req.keys];
                            return getExistingValues(downTable, req, keys).then(existingValues => {
                                const contexts = keys.map((key, i) => {
                                    const existingValue = existingValues[i];
                                    const ctx = { onerror: null, onsuccess: null };
                                    if (req.type === 'delete') {
                                        deleting.fire.call(ctx, key, existingValue, dxTrans);
                                    }
                                    else if (req.type === 'add' || existingValue === undefined) {
                                        const generatedPrimaryKey = creating.fire.call(ctx, key, req.values[i], dxTrans);
                                        if (key == null && generatedPrimaryKey != null) {
                                            key = generatedPrimaryKey;
                                            req.keys[i] = key;
                                            if (!primaryKey.outbound) {
                                                setByKeyPath(req.values[i], primaryKey.keyPath, key);
                                            }
                                        }
                                    }
                                    else {
                                        const objectDiff = getObjectDiff(existingValue, req.values[i]);
                                        const additionalChanges = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans);
                                        if (additionalChanges) {
                                            const requestedValue = req.values[i];
                                            Object.keys(additionalChanges).forEach(keyPath => {
                                                if (hasOwn$1(requestedValue, keyPath)) {
                                                    requestedValue[keyPath] = additionalChanges[keyPath];
                                                }
                                                else {
                                                    setByKeyPath(requestedValue, keyPath, additionalChanges[keyPath]);
                                                }
                                            });
                                        }
                                    }
                                    return ctx;
                                });
                                return downTable.mutate(req).then(({ failures, results, numFailures, lastResult }) => {
                                    for (let i = 0; i < keys.length; ++i) {
                                        const primKey = results ? results[i] : keys[i];
                                        const ctx = contexts[i];
                                        if (primKey == null) {
                                            ctx.onerror && ctx.onerror(failures[i]);
                                        }
                                        else {
                                            ctx.onsuccess && ctx.onsuccess(req.type === 'put' && existingValues[i] ?
                                                req.values[i] :
                                                primKey
                                            );
                                        }
                                    }
                                    return { failures, results, numFailures, lastResult };
                                }).catch(error => {
                                    contexts.forEach(ctx => ctx.onerror && ctx.onerror(error));
                                    return Promise.reject(error);
                                });
                            });
                        }
                        function deleteRange(req) {
                            return deleteNextChunk(req.trans, req.range, 10000);
                        }
                        function deleteNextChunk(trans, range, limit) {
                            return downTable.query({ trans, values: false, query: { index: primaryKey, range }, limit })
                                .then(({ result }) => {
                                return addPutOrDelete({ type: 'delete', keys: result, trans }).then(res => {
                                    if (res.numFailures > 0)
                                        return Promise.reject(res.failures[0]);
                                    if (result.length < limit) {
                                        return { failures: [], numFailures: 0, lastResult: undefined };
                                    }
                                    else {
                                        return deleteNextChunk(trans, { ...range, lower: result[result.length - 1], lowerOpen: true }, limit);
                                    }
                                });
                            });
                        }
                    }
                };
                return tableMiddleware;
            },
        })
    };
    function getExistingValues(table, req, effectiveKeys) {
        return req.type === "add"
            ? Promise.resolve([])
            : table.getMany({ trans: req.trans, keys: effectiveKeys, cache: "immutable" });
    }

    function getFromTransactionCache(keys, cache, clone) {
        try {
            if (!cache)
                return null;
            if (cache.keys.length < keys.length)
                return null;
            const result = [];
            for (let i = 0, j = 0; i < cache.keys.length && j < keys.length; ++i) {
                if (cmp(cache.keys[i], keys[j]) !== 0)
                    continue;
                result.push(clone ? deepClone(cache.values[i]) : cache.values[i]);
                ++j;
            }
            return result.length === keys.length ? result : null;
        }
        catch (_a) {
            return null;
        }
    }
    const cacheExistingValuesMiddleware = {
        stack: "dbcore",
        level: -1,
        create: (core) => {
            return {
                table: (tableName) => {
                    const table = core.table(tableName);
                    return {
                        ...table,
                        getMany: (req) => {
                            if (!req.cache) {
                                return table.getMany(req);
                            }
                            const cachedResult = getFromTransactionCache(req.keys, req.trans["_cache"], req.cache === "clone");
                            if (cachedResult) {
                                return DexiePromise.resolve(cachedResult);
                            }
                            return table.getMany(req).then((res) => {
                                req.trans["_cache"] = {
                                    keys: req.keys,
                                    values: req.cache === "clone" ? deepClone(res) : res,
                                };
                                return res;
                            });
                        },
                        mutate: (req) => {
                            if (req.type !== "add")
                                req.trans["_cache"] = null;
                            return table.mutate(req);
                        },
                    };
                },
            };
        },
    };

    function isEmptyRange(node) {
        return !("from" in node);
    }
    const RangeSet = function (fromOrTree, to) {
        if (this) {
            extend$1(this, arguments.length ? { d: 1, from: fromOrTree, to: arguments.length > 1 ? to : fromOrTree } : { d: 0 });
        }
        else {
            const rv = new RangeSet();
            if (fromOrTree && ("d" in fromOrTree)) {
                extend$1(rv, fromOrTree);
            }
            return rv;
        }
    };
    props(RangeSet.prototype, {
        add(rangeSet) {
            mergeRanges(this, rangeSet);
            return this;
        },
        addKey(key) {
            addRange(this, key, key);
            return this;
        },
        addKeys(keys) {
            keys.forEach(key => addRange(this, key, key));
            return this;
        },
        [iteratorSymbol]() {
            return getRangeSetIterator(this);
        }
    });
    function addRange(target, from, to) {
        const diff = cmp(from, to);
        if (isNaN(diff))
            return;
        if (diff > 0)
            throw RangeError();
        if (isEmptyRange(target))
            return extend$1(target, { from, to, d: 1 });
        const left = target.l;
        const right = target.r;
        if (cmp(to, target.from) < 0) {
            left
                ? addRange(left, from, to)
                : (target.l = { from, to, d: 1, l: null, r: null });
            return rebalance(target);
        }
        if (cmp(from, target.to) > 0) {
            right
                ? addRange(right, from, to)
                : (target.r = { from, to, d: 1, l: null, r: null });
            return rebalance(target);
        }
        if (cmp(from, target.from) < 0) {
            target.from = from;
            target.l = null;
            target.d = right ? right.d + 1 : 1;
        }
        if (cmp(to, target.to) > 0) {
            target.to = to;
            target.r = null;
            target.d = target.l ? target.l.d + 1 : 1;
        }
        const rightWasCutOff = !target.r;
        if (left && !target.l) {
            mergeRanges(target, left);
        }
        if (right && rightWasCutOff) {
            mergeRanges(target, right);
        }
    }
    function mergeRanges(target, newSet) {
        function _addRangeSet(target, { from, to, l, r }) {
            addRange(target, from, to);
            if (l)
                _addRangeSet(target, l);
            if (r)
                _addRangeSet(target, r);
        }
        if (!isEmptyRange(newSet))
            _addRangeSet(target, newSet);
    }
    function rangesOverlap(rangeSet1, rangeSet2) {
        const i1 = getRangeSetIterator(rangeSet2);
        let nextResult1 = i1.next();
        if (nextResult1.done)
            return false;
        let a = nextResult1.value;
        const i2 = getRangeSetIterator(rangeSet1);
        let nextResult2 = i2.next(a.from);
        let b = nextResult2.value;
        while (!nextResult1.done && !nextResult2.done) {
            if (cmp(b.from, a.to) <= 0 && cmp(b.to, a.from) >= 0)
                return true;
            cmp(a.from, b.from) < 0
                ? (a = (nextResult1 = i1.next(b.from)).value)
                : (b = (nextResult2 = i2.next(a.from)).value);
        }
        return false;
    }
    function getRangeSetIterator(node) {
        let state = isEmptyRange(node) ? null : { s: 0, n: node };
        return {
            next(key) {
                const keyProvided = arguments.length > 0;
                while (state) {
                    switch (state.s) {
                        case 0:
                            state.s = 1;
                            if (keyProvided) {
                                while (state.n.l && cmp(key, state.n.from) < 0)
                                    state = { up: state, n: state.n.l, s: 1 };
                            }
                            else {
                                while (state.n.l)
                                    state = { up: state, n: state.n.l, s: 1 };
                            }
                        case 1:
                            state.s = 2;
                            if (!keyProvided || cmp(key, state.n.to) <= 0)
                                return { value: state.n, done: false };
                        case 2:
                            if (state.n.r) {
                                state.s = 3;
                                state = { up: state, n: state.n.r, s: 0 };
                                continue;
                            }
                        case 3:
                            state = state.up;
                    }
                }
                return { done: true };
            },
        };
    }
    function rebalance(target) {
        var _a, _b;
        const diff = (((_a = target.r) === null || _a === void 0 ? void 0 : _a.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);
        const r = diff > 1 ? "r" : diff < -1 ? "l" : "";
        if (r) {
            const l = r === "r" ? "l" : "r";
            const rootClone = { ...target };
            const oldRootRight = target[r];
            target.from = oldRootRight.from;
            target.to = oldRootRight.to;
            target[r] = oldRootRight[r];
            rootClone[r] = oldRootRight[l];
            target[l] = rootClone;
            rootClone.d = computeDepth(rootClone);
        }
        target.d = computeDepth(target);
    }
    function computeDepth({ r, l }) {
        return (r ? (l ? Math.max(r.d, l.d) : r.d) : l ? l.d : 0) + 1;
    }

    const observabilityMiddleware = {
        stack: "dbcore",
        level: 0,
        create: (core) => {
            const dbName = core.schema.name;
            const FULL_RANGE = new RangeSet(core.MIN_KEY, core.MAX_KEY);
            return {
                ...core,
                table: (tableName) => {
                    const table = core.table(tableName);
                    const { schema } = table;
                    const { primaryKey } = schema;
                    const { extractKey, outbound } = primaryKey;
                    const tableClone = {
                        ...table,
                        mutate: (req) => {
                            const trans = req.trans;
                            const mutatedParts = trans.mutatedParts || (trans.mutatedParts = {});
                            const getRangeSet = (indexName) => {
                                const part = `idb://${dbName}/${tableName}/${indexName}`;
                                return (mutatedParts[part] ||
                                    (mutatedParts[part] = new RangeSet()));
                            };
                            const pkRangeSet = getRangeSet("");
                            const delsRangeSet = getRangeSet(":dels");
                            const { type } = req;
                            let [keys, newObjs] = req.type === "deleteRange"
                                ? [req.range]
                                : req.type === "delete"
                                    ? [req.keys]
                                    : req.values.length < 50
                                        ? [[], req.values]
                                        : [];
                            const oldCache = req.trans["_cache"];
                            return table.mutate(req).then((res) => {
                                if (isArray$1(keys)) {
                                    if (type !== "delete")
                                        keys = res.results;
                                    pkRangeSet.addKeys(keys);
                                    const oldObjs = getFromTransactionCache(keys, oldCache);
                                    if (!oldObjs && type !== "add") {
                                        delsRangeSet.addKeys(keys);
                                    }
                                    if (oldObjs || newObjs) {
                                        trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);
                                    }
                                }
                                else if (keys) {
                                    const range = { from: keys.lower, to: keys.upper };
                                    delsRangeSet.add(range);
                                    pkRangeSet.add(range);
                                }
                                else {
                                    pkRangeSet.add(FULL_RANGE);
                                    delsRangeSet.add(FULL_RANGE);
                                    schema.indexes.forEach(idx => getRangeSet(idx.name).add(FULL_RANGE));
                                }
                                return res;
                            });
                        },
                    };
                    const getRange = ({ query: { index, range }, }) => {
                        var _a, _b;
                        return [
                            index,
                            new RangeSet((_a = range.lower) !== null && _a !== void 0 ? _a : core.MIN_KEY, (_b = range.upper) !== null && _b !== void 0 ? _b : core.MAX_KEY),
                        ];
                    };
                    const readSubscribers = {
                        get: (req) => [primaryKey, new RangeSet(req.key)],
                        getMany: (req) => [primaryKey, new RangeSet().addKeys(req.keys)],
                        count: getRange,
                        query: getRange,
                        openCursor: getRange,
                    };
                    keys(readSubscribers).forEach(method => {
                        tableClone[method] = function (req) {
                            const { subscr } = PSD;
                            if (subscr) {
                                const getRangeSet = (indexName) => {
                                    const part = `idb://${dbName}/${tableName}/${indexName}`;
                                    return (subscr[part] ||
                                        (subscr[part] = new RangeSet()));
                                };
                                const pkRangeSet = getRangeSet("");
                                const delsRangeSet = getRangeSet(":dels");
                                const [queriedIndex, queriedRanges] = readSubscribers[method](req);
                                getRangeSet(queriedIndex.name || "").add(queriedRanges);
                                if (!queriedIndex.isPrimaryKey) {
                                    if (method === "count") {
                                        delsRangeSet.add(FULL_RANGE);
                                    }
                                    else {
                                        const keysPromise = method === "query" &&
                                            outbound &&
                                            req.values &&
                                            table.query({
                                                ...req,
                                                values: false,
                                            });
                                        return table[method].apply(this, arguments).then((res) => {
                                            if (method === "query") {
                                                if (outbound && req.values) {
                                                    return keysPromise.then(({ result: resultingKeys }) => {
                                                        pkRangeSet.addKeys(resultingKeys);
                                                        return res;
                                                    });
                                                }
                                                const pKeys = req.values
                                                    ? res.result.map(extractKey)
                                                    : res.result;
                                                if (req.values) {
                                                    pkRangeSet.addKeys(pKeys);
                                                }
                                                else {
                                                    delsRangeSet.addKeys(pKeys);
                                                }
                                            }
                                            else if (method === "openCursor") {
                                                const cursor = res;
                                                const wantValues = req.values;
                                                return (cursor &&
                                                    Object.create(cursor, {
                                                        key: {
                                                            get() {
                                                                delsRangeSet.addKey(cursor.primaryKey);
                                                                return cursor.key;
                                                            },
                                                        },
                                                        primaryKey: {
                                                            get() {
                                                                const pkey = cursor.primaryKey;
                                                                delsRangeSet.addKey(pkey);
                                                                return pkey;
                                                            },
                                                        },
                                                        value: {
                                                            get() {
                                                                wantValues && pkRangeSet.addKey(cursor.primaryKey);
                                                                return cursor.value;
                                                            },
                                                        },
                                                    }));
                                            }
                                            return res;
                                        });
                                    }
                                }
                            }
                            return table[method].apply(this, arguments);
                        };
                    });
                    return tableClone;
                },
            };
        },
    };
    function trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {
        function addAffectedIndex(ix) {
            const rangeSet = getRangeSet(ix.name || "");
            function extractKey(obj) {
                return obj != null ? ix.extractKey(obj) : null;
            }
            const addKeyOrKeys = (key) => ix.multiEntry && isArray$1(key)
                ? key.forEach(key => rangeSet.addKey(key))
                : rangeSet.addKey(key);
            (oldObjs || newObjs).forEach((_, i) => {
                const oldKey = oldObjs && extractKey(oldObjs[i]);
                const newKey = newObjs && extractKey(newObjs[i]);
                if (cmp(oldKey, newKey) !== 0) {
                    if (oldKey != null)
                        addKeyOrKeys(oldKey);
                    if (newKey != null)
                        addKeyOrKeys(newKey);
                }
            });
        }
        schema.indexes.forEach(addAffectedIndex);
    }

    class Dexie$1 {
        constructor(name, options) {
            this._middlewares = {};
            this.verno = 0;
            const deps = Dexie$1.dependencies;
            this._options = options = {
                addons: Dexie$1.addons,
                autoOpen: true,
                indexedDB: deps.indexedDB,
                IDBKeyRange: deps.IDBKeyRange,
                ...options
            };
            this._deps = {
                indexedDB: options.indexedDB,
                IDBKeyRange: options.IDBKeyRange
            };
            const { addons, } = options;
            this._dbSchema = {};
            this._versions = [];
            this._storeNames = [];
            this._allTables = {};
            this.idbdb = null;
            this._novip = this;
            const state = {
                dbOpenError: null,
                isBeingOpened: false,
                onReadyBeingFired: null,
                openComplete: false,
                dbReadyResolve: nop,
                dbReadyPromise: null,
                cancelOpen: nop,
                openCanceller: null,
                autoSchema: true,
                PR1398_maxLoop: 3
            };
            state.dbReadyPromise = new DexiePromise(resolve => {
                state.dbReadyResolve = resolve;
            });
            state.openCanceller = new DexiePromise((_, reject) => {
                state.cancelOpen = reject;
            });
            this._state = state;
            this.name = name;
            this.on = Events(this, "populate", "blocked", "versionchange", "close", { ready: [promisableChain, nop] });
            this.on.ready.subscribe = override(this.on.ready.subscribe, subscribe => {
                return (subscriber, bSticky) => {
                    Dexie$1.vip(() => {
                        const state = this._state;
                        if (state.openComplete) {
                            if (!state.dbOpenError)
                                DexiePromise.resolve().then(subscriber);
                            if (bSticky)
                                subscribe(subscriber);
                        }
                        else if (state.onReadyBeingFired) {
                            state.onReadyBeingFired.push(subscriber);
                            if (bSticky)
                                subscribe(subscriber);
                        }
                        else {
                            subscribe(subscriber);
                            const db = this;
                            if (!bSticky)
                                subscribe(function unsubscribe() {
                                    db.on.ready.unsubscribe(subscriber);
                                    db.on.ready.unsubscribe(unsubscribe);
                                });
                        }
                    });
                };
            });
            this.Collection = createCollectionConstructor(this);
            this.Table = createTableConstructor(this);
            this.Transaction = createTransactionConstructor(this);
            this.Version = createVersionConstructor(this);
            this.WhereClause = createWhereClauseConstructor(this);
            this.on("versionchange", ev => {
                if (ev.newVersion > 0)
                    console.warn(`Another connection wants to upgrade database '${this.name}'. Closing db now to resume the upgrade.`);
                else
                    console.warn(`Another connection wants to delete database '${this.name}'. Closing db now to resume the delete request.`);
                this.close();
            });
            this.on("blocked", ev => {
                if (!ev.newVersion || ev.newVersion < ev.oldVersion)
                    console.warn(`Dexie.delete('${this.name}') was blocked`);
                else
                    console.warn(`Upgrade '${this.name}' blocked by other connection holding version ${ev.oldVersion / 10}`);
            });
            this._maxKey = getMaxKey(options.IDBKeyRange);
            this._createTransaction = (mode, storeNames, dbschema, parentTransaction) => new this.Transaction(mode, storeNames, dbschema, this._options.chromeTransactionDurability, parentTransaction);
            this._fireOnBlocked = ev => {
                this.on("blocked").fire(ev);
                connections
                    .filter(c => c.name === this.name && c !== this && !c._state.vcFired)
                    .map(c => c.on("versionchange").fire(ev));
            };
            this.use(virtualIndexMiddleware);
            this.use(hooksMiddleware);
            this.use(observabilityMiddleware);
            this.use(cacheExistingValuesMiddleware);
            this.vip = Object.create(this, { _vip: { value: true } });
            addons.forEach(addon => addon(this));
        }
        version(versionNumber) {
            if (isNaN(versionNumber) || versionNumber < 0.1)
                throw new exceptions.Type(`Given version is not a positive number`);
            versionNumber = Math.round(versionNumber * 10) / 10;
            if (this.idbdb || this._state.isBeingOpened)
                throw new exceptions.Schema("Cannot add version when database is open");
            this.verno = Math.max(this.verno, versionNumber);
            const versions = this._versions;
            var versionInstance = versions.filter(v => v._cfg.version === versionNumber)[0];
            if (versionInstance)
                return versionInstance;
            versionInstance = new this.Version(versionNumber);
            versions.push(versionInstance);
            versions.sort(lowerVersionFirst);
            versionInstance.stores({});
            this._state.autoSchema = false;
            return versionInstance;
        }
        _whenReady(fn) {
            return (this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip)) ? fn() : new DexiePromise((resolve, reject) => {
                if (this._state.openComplete) {
                    return reject(new exceptions.DatabaseClosed(this._state.dbOpenError));
                }
                if (!this._state.isBeingOpened) {
                    if (!this._options.autoOpen) {
                        reject(new exceptions.DatabaseClosed());
                        return;
                    }
                    this.open().catch(nop);
                }
                this._state.dbReadyPromise.then(resolve, reject);
            }).then(fn);
        }
        use({ stack, create, level, name }) {
            if (name)
                this.unuse({ stack, name });
            const middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);
            middlewares.push({ stack, create, level: level == null ? 10 : level, name });
            middlewares.sort((a, b) => a.level - b.level);
            return this;
        }
        unuse({ stack, name, create }) {
            if (stack && this._middlewares[stack]) {
                this._middlewares[stack] = this._middlewares[stack].filter(mw => create ? mw.create !== create :
                    name ? mw.name !== name :
                        false);
            }
            return this;
        }
        open() {
            return dexieOpen(this);
        }
        _close() {
            const state = this._state;
            const idx = connections.indexOf(this);
            if (idx >= 0)
                connections.splice(idx, 1);
            if (this.idbdb) {
                try {
                    this.idbdb.close();
                }
                catch (e) { }
                this._novip.idbdb = null;
            }
            state.dbReadyPromise = new DexiePromise(resolve => {
                state.dbReadyResolve = resolve;
            });
            state.openCanceller = new DexiePromise((_, reject) => {
                state.cancelOpen = reject;
            });
        }
        close() {
            this._close();
            const state = this._state;
            this._options.autoOpen = false;
            state.dbOpenError = new exceptions.DatabaseClosed();
            if (state.isBeingOpened)
                state.cancelOpen(state.dbOpenError);
        }
        delete() {
            const hasArguments = arguments.length > 0;
            const state = this._state;
            return new DexiePromise((resolve, reject) => {
                const doDelete = () => {
                    this.close();
                    var req = this._deps.indexedDB.deleteDatabase(this.name);
                    req.onsuccess = wrap(() => {
                        _onDatabaseDeleted(this._deps, this.name);
                        resolve();
                    });
                    req.onerror = eventRejectHandler(reject);
                    req.onblocked = this._fireOnBlocked;
                };
                if (hasArguments)
                    throw new exceptions.InvalidArgument("Arguments not allowed in db.delete()");
                if (state.isBeingOpened) {
                    state.dbReadyPromise.then(doDelete);
                }
                else {
                    doDelete();
                }
            });
        }
        backendDB() {
            return this.idbdb;
        }
        isOpen() {
            return this.idbdb !== null;
        }
        hasBeenClosed() {
            const dbOpenError = this._state.dbOpenError;
            return dbOpenError && (dbOpenError.name === 'DatabaseClosed');
        }
        hasFailed() {
            return this._state.dbOpenError !== null;
        }
        dynamicallyOpened() {
            return this._state.autoSchema;
        }
        get tables() {
            return keys(this._allTables).map(name => this._allTables[name]);
        }
        transaction() {
            const args = extractTransactionArgs.apply(this, arguments);
            return this._transaction.apply(this, args);
        }
        _transaction(mode, tables, scopeFunc) {
            let parentTransaction = PSD.trans;
            if (!parentTransaction || parentTransaction.db !== this || mode.indexOf('!') !== -1)
                parentTransaction = null;
            const onlyIfCompatible = mode.indexOf('?') !== -1;
            mode = mode.replace('!', '').replace('?', '');
            let idbMode, storeNames;
            try {
                storeNames = tables.map(table => {
                    var storeName = table instanceof this.Table ? table.name : table;
                    if (typeof storeName !== 'string')
                        throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
                    return storeName;
                });
                if (mode == "r" || mode === READONLY)
                    idbMode = READONLY;
                else if (mode == "rw" || mode == READWRITE)
                    idbMode = READWRITE;
                else
                    throw new exceptions.InvalidArgument("Invalid transaction mode: " + mode);
                if (parentTransaction) {
                    if (parentTransaction.mode === READONLY && idbMode === READWRITE) {
                        if (onlyIfCompatible) {
                            parentTransaction = null;
                        }
                        else
                            throw new exceptions.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
                    }
                    if (parentTransaction) {
                        storeNames.forEach(storeName => {
                            if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {
                                if (onlyIfCompatible) {
                                    parentTransaction = null;
                                }
                                else
                                    throw new exceptions.SubTransaction("Table " + storeName +
                                        " not included in parent transaction.");
                            }
                        });
                    }
                    if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {
                        parentTransaction = null;
                    }
                }
            }
            catch (e) {
                return parentTransaction ?
                    parentTransaction._promise(null, (_, reject) => { reject(e); }) :
                    rejection(e);
            }
            const enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);
            return (parentTransaction ?
                parentTransaction._promise(idbMode, enterTransaction, "lock") :
                PSD.trans ?
                    usePSD(PSD.transless, () => this._whenReady(enterTransaction)) :
                    this._whenReady(enterTransaction));
        }
        table(tableName) {
            if (!hasOwn$1(this._allTables, tableName)) {
                throw new exceptions.InvalidTable(`Table ${tableName} does not exist`);
            }
            return this._allTables[tableName];
        }
    }

    const symbolObservable = typeof Symbol !== "undefined" && "observable" in Symbol
        ? Symbol.observable
        : "@@observable";
    class Observable {
        constructor(subscribe) {
            this._subscribe = subscribe;
        }
        subscribe(x, error, complete) {
            return this._subscribe(!x || typeof x === "function" ? { next: x, error, complete } : x);
        }
        [symbolObservable]() {
            return this;
        }
    }

    function extendObservabilitySet(target, newSet) {
        keys(newSet).forEach(part => {
            const rangeSet = target[part] || (target[part] = new RangeSet());
            mergeRanges(rangeSet, newSet[part]);
        });
        return target;
    }

    function liveQuery(querier) {
        return new Observable((observer) => {
            const scopeFuncIsAsync = isAsyncFunction(querier);
            function execute(subscr) {
                if (scopeFuncIsAsync) {
                    incrementExpectedAwaits();
                }
                const exec = () => newScope(querier, { subscr, trans: null });
                const rv = PSD.trans
                    ?
                        usePSD(PSD.transless, exec)
                    : exec();
                if (scopeFuncIsAsync) {
                    rv.then(decrementExpectedAwaits, decrementExpectedAwaits);
                }
                return rv;
            }
            let closed = false;
            let accumMuts = {};
            let currentObs = {};
            const subscription = {
                get closed() {
                    return closed;
                },
                unsubscribe: () => {
                    closed = true;
                    globalEvents.storagemutated.unsubscribe(mutationListener);
                },
            };
            observer.start && observer.start(subscription);
            let querying = false, startedListening = false;
            function shouldNotify() {
                return keys(currentObs).some((key) => accumMuts[key] && rangesOverlap(accumMuts[key], currentObs[key]));
            }
            const mutationListener = (parts) => {
                extendObservabilitySet(accumMuts, parts);
                if (shouldNotify()) {
                    doQuery();
                }
            };
            const doQuery = () => {
                if (querying || closed)
                    return;
                accumMuts = {};
                const subscr = {};
                const ret = execute(subscr);
                if (!startedListening) {
                    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);
                    startedListening = true;
                }
                querying = true;
                Promise.resolve(ret).then((result) => {
                    querying = false;
                    if (closed)
                        return;
                    if (shouldNotify()) {
                        doQuery();
                    }
                    else {
                        accumMuts = {};
                        currentObs = subscr;
                        observer.next && observer.next(result);
                    }
                }, (err) => {
                    querying = false;
                    observer.error && observer.error(err);
                    subscription.unsubscribe();
                });
            };
            doQuery();
            return subscription;
        });
    }

    let domDeps;
    try {
        domDeps = {
            indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,
            IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange
        };
    }
    catch (e) {
        domDeps = { indexedDB: null, IDBKeyRange: null };
    }

    const Dexie = Dexie$1;
    props(Dexie, {
        ...fullNameExceptions,
        delete(databaseName) {
            const db = new Dexie(databaseName, { addons: [] });
            return db.delete();
        },
        exists(name) {
            return new Dexie(name, { addons: [] }).open().then(db => {
                db.close();
                return true;
            }).catch('NoSuchDatabaseError', () => false);
        },
        getDatabaseNames(cb) {
            try {
                return getDatabaseNames(Dexie.dependencies).then(cb);
            }
            catch (_a) {
                return rejection(new exceptions.MissingAPI());
            }
        },
        defineClass() {
            function Class(content) {
                extend$1(this, content);
            }
            return Class;
        },
        ignoreTransaction(scopeFunc) {
            return PSD.trans ?
                usePSD(PSD.transless, scopeFunc) :
                scopeFunc();
        },
        vip,
        async: function (generatorFn) {
            return function () {
                try {
                    var rv = awaitIterator(generatorFn.apply(this, arguments));
                    if (!rv || typeof rv.then !== 'function')
                        return DexiePromise.resolve(rv);
                    return rv;
                }
                catch (e) {
                    return rejection(e);
                }
            };
        },
        spawn: function (generatorFn, args, thiz) {
            try {
                var rv = awaitIterator(generatorFn.apply(thiz, args || []));
                if (!rv || typeof rv.then !== 'function')
                    return DexiePromise.resolve(rv);
                return rv;
            }
            catch (e) {
                return rejection(e);
            }
        },
        currentTransaction: {
            get: () => PSD.trans || null
        },
        waitFor: function (promiseOrFunction, optionalTimeout) {
            const promise = DexiePromise.resolve(typeof promiseOrFunction === 'function' ?
                Dexie.ignoreTransaction(promiseOrFunction) :
                promiseOrFunction)
                .timeout(optionalTimeout || 60000);
            return PSD.trans ?
                PSD.trans.waitFor(promise) :
                promise;
        },
        Promise: DexiePromise,
        debug: {
            get: () => debug,
            set: value => {
                setDebug(value, value === 'dexie' ? () => true : dexieStackFrameFilter);
            }
        },
        derive: derive,
        extend: extend$1,
        props: props,
        override: override,
        Events: Events,
        on: globalEvents,
        liveQuery,
        extendObservabilitySet,
        getByKeyPath: getByKeyPath,
        setByKeyPath: setByKeyPath,
        delByKeyPath: delByKeyPath,
        shallowClone: shallowClone,
        deepClone: deepClone,
        getObjectDiff: getObjectDiff,
        cmp,
        asap: asap$1,
        minKey: minKey,
        addons: [],
        connections: connections,
        errnames: errnames,
        dependencies: domDeps,
        semVer: DEXIE_VERSION,
        version: DEXIE_VERSION.split('.')
            .map(n => parseInt(n))
            .reduce((p, c, i) => p + (c / Math.pow(10, i * 2))),
    });
    Dexie.maxKey = getMaxKey(Dexie.dependencies.IDBKeyRange);

    if (typeof dispatchEvent !== 'undefined' && typeof addEventListener !== 'undefined') {
        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, updatedParts => {
            if (!propagatingLocally) {
                let event;
                if (isIEOrEdge) {
                    event = document.createEvent('CustomEvent');
                    event.initCustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, true, true, updatedParts);
                }
                else {
                    event = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {
                        detail: updatedParts
                    });
                }
                propagatingLocally = true;
                dispatchEvent(event);
                propagatingLocally = false;
            }
        });
        addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, ({ detail }) => {
            if (!propagatingLocally) {
                propagateLocally(detail);
            }
        });
    }
    function propagateLocally(updateParts) {
        let wasMe = propagatingLocally;
        try {
            propagatingLocally = true;
            globalEvents.storagemutated.fire(updateParts);
        }
        finally {
            propagatingLocally = wasMe;
        }
    }
    let propagatingLocally = false;

    if (typeof BroadcastChannel !== 'undefined') {
        const bc = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);
        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (changedParts) => {
            if (!propagatingLocally) {
                bc.postMessage(changedParts);
            }
        });
        bc.onmessage = (ev) => {
            if (ev.data)
                propagateLocally(ev.data);
        };
    }
    else if (typeof self !== 'undefined' && typeof navigator !== 'undefined') {
        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (changedParts) => {
            try {
                if (!propagatingLocally) {
                    if (typeof localStorage !== 'undefined') {
                        localStorage.setItem(STORAGE_MUTATED_DOM_EVENT_NAME, JSON.stringify({
                            trig: Math.random(),
                            changedParts,
                        }));
                    }
                    if (typeof self['clients'] === 'object') {
                        [...self['clients'].matchAll({ includeUncontrolled: true })].forEach((client) => client.postMessage({
                            type: STORAGE_MUTATED_DOM_EVENT_NAME,
                            changedParts,
                        }));
                    }
                }
            }
            catch (_a) { }
        });
        if (typeof addEventListener !== 'undefined') {
            addEventListener('storage', (ev) => {
                if (ev.key === STORAGE_MUTATED_DOM_EVENT_NAME) {
                    const data = JSON.parse(ev.newValue);
                    if (data)
                        propagateLocally(data.changedParts);
                }
            });
        }
        const swContainer = self.document && navigator.serviceWorker;
        if (swContainer) {
            swContainer.addEventListener('message', propagateMessageLocally);
        }
    }
    function propagateMessageLocally({ data }) {
        if (data && data.type === STORAGE_MUTATED_DOM_EVENT_NAME) {
            propagateLocally(data.changedParts);
        }
    }

    DexiePromise.rejectionMapper = mapError;
    setDebug(debug, dexieStackFrameFilter);

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function getDefaultExportFromCjs (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function createCommonjsModule(fn) {
      var module = { exports: {} };
    	return fn(module, module.exports), module.exports;
    }

    /*
    * iziToast | v1.4.0
    * http://izitoast.marcelodolce.com
    * by Marcelo Dolce.
    */

    var iziToast = createCommonjsModule(function (module, exports) {
    (function (root, factory) {
    	{
    		module.exports = factory(root);
    	}
    })(typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : window || commonjsGlobal.window || commonjsGlobal.global, function (root) {

    	//
    	// Variables
    	//
    	var $iziToast = {},
    		PLUGIN_NAME = 'iziToast';
    		document.querySelector('body');
    		var ISMOBILE = (/Mobi/.test(navigator.userAgent)) ? true : false,
    		ISCHROME = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor),
    		ISFIREFOX = typeof InstallTrigger !== 'undefined',
    		ACCEPTSTOUCH = 'ontouchstart' in document.documentElement,
    		POSITIONS = ['bottomRight','bottomLeft','bottomCenter','topRight','topLeft','topCenter','center'],
    		THEMES = {
    			info: {
    				color: 'blue',
    				icon: 'ico-info'
    			},
    			success: {
    				color: 'green',
    				icon: 'ico-success'
    			},
    			warning: {
    				color: 'orange',
    				icon: 'ico-warning'
    			},
    			error: {
    				color: 'red',
    				icon: 'ico-error'
    			},
    			question: {
    				color: 'yellow',
    				icon: 'ico-question'
    			}
    		},
    		MOBILEWIDTH = 568,
    		CONFIG = {};

    	$iziToast.children = {};

    	// Default settings
    	var defaults = {
    		id: null, 
    		class: '',
    		title: '',
    		titleColor: '',
    		titleSize: '',
    		titleLineHeight: '',
    		message: '',
    		messageColor: '',
    		messageSize: '',
    		messageLineHeight: '',
    		backgroundColor: '',
    		theme: 'light', // dark
    		color: '', // blue, red, green, yellow
    		icon: '',
    		iconText: '',
    		iconColor: '',
    		iconUrl: null,
    		image: '',
    		imageWidth: 50,
    		maxWidth: null,
    		zindex: null,
    		layout: 1,
    		balloon: false,
    		close: true,
    		closeOnEscape: false,
    		closeOnClick: false,
    		displayMode: 0,
    		position: 'bottomRight', // bottomRight, bottomLeft, topRight, topLeft, topCenter, bottomCenter, center
    		target: '',
    		targetFirst: true,
    		timeout: 5000,
    		rtl: false,
    		animateInside: true,
    		drag: true,
    		pauseOnHover: true,
    		resetOnHover: false,
    		progressBar: true,
    		progressBarColor: '',
    		progressBarEasing: 'linear',
    		overlay: false,
    		overlayClose: false,
    		overlayColor: 'rgba(0, 0, 0, 0.6)',
    		transitionIn: 'fadeInUp', // bounceInLeft, bounceInRight, bounceInUp, bounceInDown, fadeIn, fadeInDown, fadeInUp, fadeInLeft, fadeInRight, flipInX
    		transitionOut: 'fadeOut', // fadeOut, fadeOutUp, fadeOutDown, fadeOutLeft, fadeOutRight, flipOutX
    		transitionInMobile: 'fadeInUp',
    		transitionOutMobile: 'fadeOutDown',
    		buttons: {},
    		inputs: {},
    		onOpening: function () {},
    		onOpened: function () {},
    		onClosing: function () {},
    		onClosed: function () {}
    	};

    	//
    	// Methods
    	//


    	/**
    	 * Polyfill for remove() method
    	 */
    	if(!('remove' in Element.prototype)) {
    	    Element.prototype.remove = function() {
    	        if(this.parentNode) {
    	            this.parentNode.removeChild(this);
    	        }
    	    };
    	}

    	/*
         * Polyfill for CustomEvent for IE >= 9
         * https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent#Polyfill
         */
        if(typeof window.CustomEvent !== 'function') {
            var CustomEventPolyfill = function (event, params) {
                params = params || { bubbles: false, cancelable: false, detail: undefined };
                var evt = document.createEvent('CustomEvent');
                evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
                return evt;
            };

            CustomEventPolyfill.prototype = window.Event.prototype;

            window.CustomEvent = CustomEventPolyfill;
        }

    	/**
    	 * A simple forEach() implementation for Arrays, Objects and NodeLists
    	 * @private
    	 * @param {Array|Object|NodeList} collection Collection of items to iterate
    	 * @param {Function} callback Callback function for each iteration
    	 * @param {Array|Object|NodeList} scope Object/NodeList/Array that forEach is iterating over (aka `this`)
    	 */
    	var forEach = function (collection, callback, scope) {
    		if(Object.prototype.toString.call(collection) === '[object Object]') {
    			for (var prop in collection) {
    				if(Object.prototype.hasOwnProperty.call(collection, prop)) {
    					callback.call(scope, collection[prop], prop, collection);
    				}
    			}
    		} else {
    			if(collection){
    				for (var i = 0, len = collection.length; i < len; i++) {
    					callback.call(scope, collection[i], i, collection);
    				}
    			}
    		}
    	};

    	/**
    	 * Merge defaults with user options
    	 * @private
    	 * @param {Object} defaults Default settings
    	 * @param {Object} options User options
    	 * @returns {Object} Merged values of defaults and options
    	 */
    	var extend = function (defaults, options) {
    		var extended = {};
    		forEach(defaults, function (value, prop) {
    			extended[prop] = defaults[prop];
    		});
    		forEach(options, function (value, prop) {
    			extended[prop] = options[prop];
    		});
    		return extended;
    	};


    	/**
    	 * Create a fragment DOM elements
    	 * @private
    	 */
    	var createFragElem = function(htmlStr) {
    		var frag = document.createDocumentFragment(),
    			temp = document.createElement('div');
    		temp.innerHTML = htmlStr;
    		while (temp.firstChild) {
    			frag.appendChild(temp.firstChild);
    		}
    		return frag;
    	};


    	/**
    	 * Generate new ID
    	 * @private
    	 */
    	var generateId = function(params) {
    		var newId = btoa(encodeURIComponent(params));
    		return newId.replace(/=/g, "");
    	};


    	/**
    	 * Check if is a color
    	 * @private
    	 */
    	var isColor = function(color){
    		if( color.substring(0,1) == '#' || color.substring(0,3) == 'rgb' || color.substring(0,3) == 'hsl' ){
    			return true;
    		} else {
    			return false;
    		}
    	};


    	/**
    	 * Check if is a Base64 string
    	 * @private
    	 */
    	var isBase64 = function(str) {
    	    try {
    	        return btoa(atob(str)) == str;
    	    } catch (err) {
    	        return false;
    	    }
    	};


    	/**
    	 * Drag method of toasts
    	 * @private
    	 */
    	var drag = function() {
    	    
    	    return {
    	        move: function(toast, instance, settings, xpos) {

    	        	var opacity,
    	        		opacityRange = 0.3,
    	        		distance = 180;
    	            
    	            if(xpos !== 0){
    	            	
    	            	toast.classList.add(PLUGIN_NAME+'-dragged');

    	            	toast.style.transform = 'translateX('+xpos + 'px)';

    		            if(xpos > 0){
    		            	opacity = (distance-xpos) / distance;
    		            	if(opacity < opacityRange){
    							instance.hide(extend(settings, { transitionOut: 'fadeOutRight', transitionOutMobile: 'fadeOutRight' }), toast, 'drag');
    						}
    		            } else {
    		            	opacity = (distance+xpos) / distance;
    		            	if(opacity < opacityRange){
    							instance.hide(extend(settings, { transitionOut: 'fadeOutLeft', transitionOutMobile: 'fadeOutLeft' }), toast, 'drag');
    						}
    		            }
    					toast.style.opacity = opacity;
    			
    					if(opacity < opacityRange){

    						if(ISCHROME || ISFIREFOX)
    							toast.style.left = xpos+'px';

    						toast.parentNode.style.opacity = opacityRange;

    		                this.stopMoving(toast, null);
    					}
    	            }

    				
    	        },
    	        startMoving: function(toast, instance, settings, e) {

    	            e = e || window.event;
    	            var posX = ((ACCEPTSTOUCH) ? e.touches[0].clientX : e.clientX),
    	                toastLeft = toast.style.transform.replace('px)', '');
    	                toastLeft = toastLeft.replace('translateX(', '');
    	            var offsetX = posX - toastLeft;

    				if(settings.transitionIn){
    					toast.classList.remove(settings.transitionIn);
    				}
    				if(settings.transitionInMobile){
    					toast.classList.remove(settings.transitionInMobile);
    				}
    				toast.style.transition = '';

    	            if(ACCEPTSTOUCH) {
    	                document.ontouchmove = function(e) {
    	                    e.preventDefault();
    	                    e = e || window.event;
    	                    var posX = e.touches[0].clientX,
    	                        finalX = posX - offsetX;
                            drag.move(toast, instance, settings, finalX);
    	                };
    	            } else {
    	                document.onmousemove = function(e) {
    	                    e.preventDefault();
    	                    e = e || window.event;
    	                    var posX = e.clientX,
    	                        finalX = posX - offsetX;
                            drag.move(toast, instance, settings, finalX);
    	                };
    	            }

    	        },
    	        stopMoving: function(toast, e) {

    	            if(ACCEPTSTOUCH) {
    	                document.ontouchmove = function() {};
    	            } else {
    	            	document.onmousemove = function() {};
    	            }

    				toast.style.opacity = '';
    				toast.style.transform = '';

    	            if(toast.classList.contains(PLUGIN_NAME+'-dragged')){
    	            	
    	            	toast.classList.remove(PLUGIN_NAME+'-dragged');

    					toast.style.transition = 'transform 0.4s ease, opacity 0.4s ease';
    					setTimeout(function() {
    						toast.style.transition = '';
    					}, 400);
    	            }

    	        }
    	    };

    	}();





    	$iziToast.setSetting = function (ref, option, value) {

    		$iziToast.children[ref][option] = value;

    	};


    	$iziToast.getSetting = function (ref, option) {

    		return $iziToast.children[ref][option];

    	};


    	/**
    	 * Destroy the current initialization.
    	 * @public
    	 */
    	$iziToast.destroy = function () {

    		forEach(document.querySelectorAll('.'+PLUGIN_NAME+'-overlay'), function(element, index) {
    			element.remove();
    		});

    		forEach(document.querySelectorAll('.'+PLUGIN_NAME+'-wrapper'), function(element, index) {
    			element.remove();
    		});

    		forEach(document.querySelectorAll('.'+PLUGIN_NAME), function(element, index) {
    			element.remove();
    		});

    		this.children = {};

    		// Remove event listeners
    		document.removeEventListener(PLUGIN_NAME+'-opened', {}, false);
    		document.removeEventListener(PLUGIN_NAME+'-opening', {}, false);
    		document.removeEventListener(PLUGIN_NAME+'-closing', {}, false);
    		document.removeEventListener(PLUGIN_NAME+'-closed', {}, false);
    		document.removeEventListener('keyup', {}, false);

    		// Reset variables
    		CONFIG = {};
    	};

    	/**
    	 * Initialize Plugin
    	 * @public
    	 * @param {Object} options User settings
    	 */
    	$iziToast.settings = function (options) {

    		// Destroy any existing initializations
    		$iziToast.destroy();

    		CONFIG = options;
    		defaults = extend(defaults, options || {});
    	};


    	/**
    	 * Building themes functions.
    	 * @public
    	 * @param {Object} options User settings
    	 */
    	forEach(THEMES, function (theme, name) {

    		$iziToast[name] = function (options) {

    			var settings = extend(CONFIG, options || {});
    			settings = extend(theme, settings || {});

    			this.show(settings);
    		};

    	});


    	/**
    	 * Do the calculation to move the progress bar
    	 * @private
    	 */
    	$iziToast.progress = function (options, $toast, callback) {


    		var that = this,
    			ref = $toast.getAttribute('data-iziToast-ref'),
    			settings = extend(this.children[ref], options || {}),
    			$elem = $toast.querySelector('.'+PLUGIN_NAME+'-progressbar div');

    	    return {
    	        start: function() {

    	        	if(typeof settings.time.REMAINING == 'undefined'){

    	        		$toast.classList.remove(PLUGIN_NAME+'-reseted');

    		        	if($elem !== null){
    						$elem.style.transition = 'width '+ settings.timeout +'ms '+settings.progressBarEasing;
    						$elem.style.width = '0%';
    					}

    		        	settings.time.START = new Date().getTime();
    		        	settings.time.END = settings.time.START + settings.timeout;
    					settings.time.TIMER = setTimeout(function() {

    						clearTimeout(settings.time.TIMER);

    						if(!$toast.classList.contains(PLUGIN_NAME+'-closing')){

    							that.hide(settings, $toast, 'timeout');

    							if(typeof callback === 'function'){
    								callback.apply(that);
    							}
    						}

    					}, settings.timeout);			
    		        	that.setSetting(ref, 'time', settings.time);
    	        	}
    	        },
    	        pause: function() {

    	        	if(typeof settings.time.START !== 'undefined' && !$toast.classList.contains(PLUGIN_NAME+'-paused') && !$toast.classList.contains(PLUGIN_NAME+'-reseted')){

            			$toast.classList.add(PLUGIN_NAME+'-paused');

    					settings.time.REMAINING = settings.time.END - new Date().getTime();

    					clearTimeout(settings.time.TIMER);

    					that.setSetting(ref, 'time', settings.time);

    					if($elem !== null){
    						var computedStyle = window.getComputedStyle($elem),
    							propertyWidth = computedStyle.getPropertyValue('width');

    						$elem.style.transition = 'none';
    						$elem.style.width = propertyWidth;					
    					}

    					if(typeof callback === 'function'){
    						setTimeout(function() {
    							callback.apply(that);						
    						}, 10);
    					}
            		}
    	        },
    	        resume: function() {

    				if(typeof settings.time.REMAINING !== 'undefined'){

    					$toast.classList.remove(PLUGIN_NAME+'-paused');

    		        	if($elem !== null){
    						$elem.style.transition = 'width '+ settings.time.REMAINING +'ms '+settings.progressBarEasing;
    						$elem.style.width = '0%';
    					}

    		        	settings.time.END = new Date().getTime() + settings.time.REMAINING;
    					settings.time.TIMER = setTimeout(function() {

    						clearTimeout(settings.time.TIMER);

    						if(!$toast.classList.contains(PLUGIN_NAME+'-closing')){

    							that.hide(settings, $toast, 'timeout');

    							if(typeof callback === 'function'){
    								callback.apply(that);
    							}
    						}


    					}, settings.time.REMAINING);

    					that.setSetting(ref, 'time', settings.time);
    				} else {
    					this.start();
    				}
    	        },
    	        reset: function(){

    				clearTimeout(settings.time.TIMER);

    				delete settings.time.REMAINING;

    				that.setSetting(ref, 'time', settings.time);

    				$toast.classList.add(PLUGIN_NAME+'-reseted');

    				$toast.classList.remove(PLUGIN_NAME+'-paused');

    				if($elem !== null){
    					$elem.style.transition = 'none';
    					$elem.style.width = '100%';
    				}

    				if(typeof callback === 'function'){
    					setTimeout(function() {
    						callback.apply(that);						
    					}, 10);
    				}
    	        }
    	    };

    	};


    	/**
    	 * Close the specific Toast
    	 * @public
    	 * @param {Object} options User settings
    	 */
    	$iziToast.hide = function (options, $toast, closedBy) {

    		if(typeof $toast != 'object'){
    			$toast = document.querySelector($toast);
    		}		

    		var that = this,
    			settings = extend(this.children[$toast.getAttribute('data-iziToast-ref')], options || {});
    			settings.closedBy = closedBy || null;

    		delete settings.time.REMAINING;

    		$toast.classList.add(PLUGIN_NAME+'-closing');

    		// Overlay
    		(function(){

    			var $overlay = document.querySelector('.'+PLUGIN_NAME+'-overlay');
    			if($overlay !== null){
    				var refs = $overlay.getAttribute('data-iziToast-ref');		
    					refs = refs.split(',');
    				var index = refs.indexOf(String(settings.ref));

    				if(index !== -1){
    					refs.splice(index, 1);			
    				}
    				$overlay.setAttribute('data-iziToast-ref', refs.join());

    				if(refs.length === 0){
    					$overlay.classList.remove('fadeIn');
    					$overlay.classList.add('fadeOut');
    					setTimeout(function() {
    						$overlay.remove();
    					}, 700);
    				}
    			}

    		})();

    		if(settings.transitionIn){
    			$toast.classList.remove(settings.transitionIn);
    		} 

    		if(settings.transitionInMobile){
    			$toast.classList.remove(settings.transitionInMobile);
    		}

    		if(ISMOBILE || window.innerWidth <= MOBILEWIDTH){
    			if(settings.transitionOutMobile)
    				$toast.classList.add(settings.transitionOutMobile);
    		} else {
    			if(settings.transitionOut)
    				$toast.classList.add(settings.transitionOut);
    		}
    		var H = $toast.parentNode.offsetHeight;
    				$toast.parentNode.style.height = H+'px';
    				$toast.style.pointerEvents = 'none';
    		
    		if(!ISMOBILE || window.innerWidth > MOBILEWIDTH){
    			$toast.parentNode.style.transitionDelay = '0.2s';
    		}

    		try {
    			var event = new CustomEvent(PLUGIN_NAME+'-closing', {detail: settings, bubbles: true, cancelable: true});
    			document.dispatchEvent(event);
    		} catch(ex){
    			console.warn(ex);
    		}

    		setTimeout(function() {
    			
    			$toast.parentNode.style.height = '0px';
    			$toast.parentNode.style.overflow = '';

    			setTimeout(function(){
    				
    				delete that.children[settings.ref];

    				$toast.parentNode.remove();

    				try {
    					var event = new CustomEvent(PLUGIN_NAME+'-closed', {detail: settings, bubbles: true, cancelable: true});
    					document.dispatchEvent(event);
    				} catch(ex){
    					console.warn(ex);
    				}

    				if(typeof settings.onClosed !== 'undefined'){
    					settings.onClosed.apply(null, [settings, $toast, closedBy]);
    				}

    			}, 1000);
    		}, 200);


    		if(typeof settings.onClosing !== 'undefined'){
    			settings.onClosing.apply(null, [settings, $toast, closedBy]);
    		}
    	};

    	/**
    	 * Create and show the Toast
    	 * @public
    	 * @param {Object} options User settings
    	 */
    	$iziToast.show = function (options) {

    		var that = this;

    		// Merge user options with defaults
    		var settings = extend(CONFIG, options || {});
    			settings = extend(defaults, settings);
    			settings.time = {};

    		if(settings.id === null){
    			settings.id = generateId(settings.title+settings.message+settings.color);
    		}

    		if(settings.displayMode === 1 || settings.displayMode == 'once'){
    			try {
    				if(document.querySelectorAll('.'+PLUGIN_NAME+'#'+settings.id).length > 0){
    					return false;
    				}
    			} catch (exc) {
    				console.warn('['+PLUGIN_NAME+'] Could not find an element with this selector: '+'#'+settings.id+'. Try to set an valid id.');
    			}
    		}

    		if(settings.displayMode === 2 || settings.displayMode == 'replace'){
    			try {
    				forEach(document.querySelectorAll('.'+PLUGIN_NAME+'#'+settings.id), function(element, index) {
    					that.hide(settings, element, 'replaced');
    				});
    			} catch (exc) {
    				console.warn('['+PLUGIN_NAME+'] Could not find an element with this selector: '+'#'+settings.id+'. Try to set an valid id.');
    			}
    		}

    		settings.ref = new Date().getTime() + Math.floor((Math.random() * 10000000) + 1);

    		$iziToast.children[settings.ref] = settings;

    		var $DOM = {
    			body: document.querySelector('body'),
    			overlay: document.createElement('div'),
    			toast: document.createElement('div'),
    			toastBody: document.createElement('div'),
    			toastTexts: document.createElement('div'),
    			toastCapsule: document.createElement('div'),
    			cover: document.createElement('div'),
    			buttons: document.createElement('div'),
    			inputs: document.createElement('div'),
    			icon: !settings.iconUrl ? document.createElement('i') : document.createElement('img'),
    			wrapper: null
    		};

    		$DOM.toast.setAttribute('data-iziToast-ref', settings.ref);
    		$DOM.toast.appendChild($DOM.toastBody);
    		$DOM.toastCapsule.appendChild($DOM.toast);

    		// CSS Settings
    		(function(){

    			$DOM.toast.classList.add(PLUGIN_NAME);
    			$DOM.toast.classList.add(PLUGIN_NAME+'-opening');
    			$DOM.toastCapsule.classList.add(PLUGIN_NAME+'-capsule');
    			$DOM.toastBody.classList.add(PLUGIN_NAME + '-body');
    			$DOM.toastTexts.classList.add(PLUGIN_NAME + '-texts');

    			if(ISMOBILE || window.innerWidth <= MOBILEWIDTH){
    				if(settings.transitionInMobile)
    					$DOM.toast.classList.add(settings.transitionInMobile);
    			} else {
    				if(settings.transitionIn)
    					$DOM.toast.classList.add(settings.transitionIn);
    			}

    			if(settings.class){
    				var classes = settings.class.split(' ');
    				forEach(classes, function (value, index) {
    					$DOM.toast.classList.add(value);
    				});
    			}

    			if(settings.id){ $DOM.toast.id = settings.id; }

    			if(settings.rtl){
    				$DOM.toast.classList.add(PLUGIN_NAME + '-rtl');
    				$DOM.toast.setAttribute('dir', 'rtl');
    			}

    			if(settings.layout > 1){ $DOM.toast.classList.add(PLUGIN_NAME+'-layout'+settings.layout); }

    			if(settings.balloon){ $DOM.toast.classList.add(PLUGIN_NAME+'-balloon'); }

    			if(settings.maxWidth){
    				if( !isNaN(settings.maxWidth) ){
    					$DOM.toast.style.maxWidth = settings.maxWidth+'px';
    				} else {
    					$DOM.toast.style.maxWidth = settings.maxWidth;
    				}
    			}

    			if(settings.theme !== '' || settings.theme !== 'light') {

    				$DOM.toast.classList.add(PLUGIN_NAME+'-theme-'+settings.theme);
    			}

    			if(settings.color) { //#, rgb, rgba, hsl
    				
    				if( isColor(settings.color) ){
    					$DOM.toast.style.background = settings.color;
    				} else {
    					$DOM.toast.classList.add(PLUGIN_NAME+'-color-'+settings.color);
    				}
    			}

    			if(settings.backgroundColor) {
    				$DOM.toast.style.background = settings.backgroundColor;
    				if(settings.balloon){
    					$DOM.toast.style.borderColor = settings.backgroundColor;				
    				}
    			}
    		})();

    		// Cover image
    		(function(){
    			if(settings.image) {
    				$DOM.cover.classList.add(PLUGIN_NAME + '-cover');
    				$DOM.cover.style.width = settings.imageWidth + 'px';

    				if(isBase64(settings.image.replace(/ /g,''))){
    					$DOM.cover.style.backgroundImage = 'url(data:image/png;base64,' + settings.image.replace(/ /g,'') + ')';
    				} else {
    					$DOM.cover.style.backgroundImage = 'url(' + settings.image + ')';
    				}

    				if(settings.rtl){
    					$DOM.toastBody.style.marginRight = (settings.imageWidth + 10) + 'px';
    				} else {
    					$DOM.toastBody.style.marginLeft = (settings.imageWidth + 10) + 'px';				
    				}
    				$DOM.toast.appendChild($DOM.cover);
    			}
    		})();

    		// Button close
    		(function(){
    			if(settings.close){
    				
    				$DOM.buttonClose = document.createElement('button');
    				$DOM.buttonClose.type = 'button';
    				$DOM.buttonClose.classList.add(PLUGIN_NAME + '-close');
    				$DOM.buttonClose.addEventListener('click', function (e) {
    					e.target;
    					that.hide(settings, $DOM.toast, 'button');
    				});
    				$DOM.toast.appendChild($DOM.buttonClose);
    			} else {
    				if(settings.rtl){
    					$DOM.toast.style.paddingLeft = '18px';
    				} else {
    					$DOM.toast.style.paddingRight = '18px';
    				}
    			}
    		})();

    		// Progress Bar & Timeout
    		(function(){

    			if(settings.progressBar){
    				$DOM.progressBar = document.createElement('div');
    				$DOM.progressBarDiv = document.createElement('div');
    				$DOM.progressBar.classList.add(PLUGIN_NAME + '-progressbar');
    				$DOM.progressBarDiv.style.background = settings.progressBarColor;
    				$DOM.progressBar.appendChild($DOM.progressBarDiv);
    				$DOM.toast.appendChild($DOM.progressBar);
    			}

    			if(settings.timeout) {

    				if(settings.pauseOnHover && !settings.resetOnHover){
    					
    					$DOM.toast.addEventListener('mouseenter', function (e) {
    						that.progress(settings, $DOM.toast).pause();
    					});
    					$DOM.toast.addEventListener('mouseleave', function (e) {
    						that.progress(settings, $DOM.toast).resume();
    					});
    				}

    				if(settings.resetOnHover){

    					$DOM.toast.addEventListener('mouseenter', function (e) {
    						that.progress(settings, $DOM.toast).reset();
    					});
    					$DOM.toast.addEventListener('mouseleave', function (e) {
    						that.progress(settings, $DOM.toast).start();
    					});
    				}
    			}
    		})();

    		// Icon
    		(function(){

    			if(settings.iconUrl) {

    				$DOM.icon.setAttribute('class', PLUGIN_NAME + '-icon');
    				$DOM.icon.setAttribute('src', settings.iconUrl);

    			} else if(settings.icon) {
    				$DOM.icon.setAttribute('class', PLUGIN_NAME + '-icon ' + settings.icon);
    				
    				if(settings.iconText){
    					$DOM.icon.appendChild(document.createTextNode(settings.iconText));
    				}
    				
    				if(settings.iconColor){
    					$DOM.icon.style.color = settings.iconColor;
    				}				
    			}

    			if(settings.icon || settings.iconUrl) {

    				if(settings.rtl){
    					$DOM.toastBody.style.paddingRight = '33px';
    				} else {
    					$DOM.toastBody.style.paddingLeft = '33px';				
    				}

    				$DOM.toastBody.appendChild($DOM.icon);
    			}

    		})();

    		// Title & Message
    		(function(){
    			if(settings.title.length > 0) {

    				$DOM.strong = document.createElement('strong');
    				$DOM.strong.classList.add(PLUGIN_NAME + '-title');
    				$DOM.strong.appendChild(createFragElem(settings.title));
    				$DOM.toastTexts.appendChild($DOM.strong);

    				if(settings.titleColor) {
    					$DOM.strong.style.color = settings.titleColor;
    				}
    				if(settings.titleSize) {
    					if( !isNaN(settings.titleSize) ){
    						$DOM.strong.style.fontSize = settings.titleSize+'px';
    					} else {
    						$DOM.strong.style.fontSize = settings.titleSize;
    					}
    				}
    				if(settings.titleLineHeight) {
    					if( !isNaN(settings.titleSize) ){
    						$DOM.strong.style.lineHeight = settings.titleLineHeight+'px';
    					} else {
    						$DOM.strong.style.lineHeight = settings.titleLineHeight;
    					}
    				}
    			}

    			if(settings.message.length > 0) {

    				$DOM.p = document.createElement('p');
    				$DOM.p.classList.add(PLUGIN_NAME + '-message');
    				$DOM.p.appendChild(createFragElem(settings.message));
    				$DOM.toastTexts.appendChild($DOM.p);

    				if(settings.messageColor) {
    					$DOM.p.style.color = settings.messageColor;
    				}
    				if(settings.messageSize) {
    					if( !isNaN(settings.titleSize) ){
    						$DOM.p.style.fontSize = settings.messageSize+'px';
    					} else {
    						$DOM.p.style.fontSize = settings.messageSize;
    					}
    				}
    				if(settings.messageLineHeight) {
    					
    					if( !isNaN(settings.titleSize) ){
    						$DOM.p.style.lineHeight = settings.messageLineHeight+'px';
    					} else {
    						$DOM.p.style.lineHeight = settings.messageLineHeight;
    					}
    				}
    			}

    			if(settings.title.length > 0 && settings.message.length > 0) {
    				if(settings.rtl){
    					$DOM.strong.style.marginLeft = '10px';
    				} else if(settings.layout !== 2 && !settings.rtl) {
    					$DOM.strong.style.marginRight = '10px';	
    				}
    			}
    		})();

    		$DOM.toastBody.appendChild($DOM.toastTexts);

    		// Inputs
    		var $inputs;
    		(function(){
    			if(settings.inputs.length > 0) {

    				$DOM.inputs.classList.add(PLUGIN_NAME + '-inputs');

    				forEach(settings.inputs, function (value, index) {
    					$DOM.inputs.appendChild(createFragElem(value[0]));

    					$inputs = $DOM.inputs.childNodes;

    					$inputs[index].classList.add(PLUGIN_NAME + '-inputs-child');

    					if(value[3]){
    						setTimeout(function() {
    							$inputs[index].focus();
    						}, 300);
    					}

    					$inputs[index].addEventListener(value[1], function (e) {
    						var ts = value[2];
    						return ts(that, $DOM.toast, this, e);
    					});
    				});
    				$DOM.toastBody.appendChild($DOM.inputs);
    			}
    		})();

    		// Buttons
    		(function(){
    			if(settings.buttons.length > 0) {

    				$DOM.buttons.classList.add(PLUGIN_NAME + '-buttons');

    				forEach(settings.buttons, function (value, index) {
    					$DOM.buttons.appendChild(createFragElem(value[0]));

    					var $btns = $DOM.buttons.childNodes;

    					$btns[index].classList.add(PLUGIN_NAME + '-buttons-child');

    					if(value[2]){
    						setTimeout(function() {
    							$btns[index].focus();
    						}, 300);
    					}

    					$btns[index].addEventListener('click', function (e) {
    						e.preventDefault();
    						var ts = value[1];
    						return ts(that, $DOM.toast, this, e, $inputs);
    					});
    				});
    			}
    			$DOM.toastBody.appendChild($DOM.buttons);
    		})();

    		if(settings.message.length > 0 && (settings.inputs.length > 0 || settings.buttons.length > 0)) {
    			$DOM.p.style.marginBottom = '0';
    		}

    		if(settings.inputs.length > 0 || settings.buttons.length > 0){
    			if(settings.rtl){
    				$DOM.toastTexts.style.marginLeft = '10px';
    			} else {
    				$DOM.toastTexts.style.marginRight = '10px';
    			}
    			if(settings.inputs.length > 0 && settings.buttons.length > 0){
    				if(settings.rtl){
    					$DOM.inputs.style.marginLeft = '8px';
    				} else {
    					$DOM.inputs.style.marginRight = '8px';
    				}
    			}
    		}

    		// Wrap
    		(function(){
    			$DOM.toastCapsule.style.visibility = 'hidden';
    			setTimeout(function() {
    				var H = $DOM.toast.offsetHeight;
    				var style = $DOM.toast.currentStyle || window.getComputedStyle($DOM.toast);
    				var marginTop = style.marginTop;
    					marginTop = marginTop.split('px');
    					marginTop = parseInt(marginTop[0]);
    				var marginBottom = style.marginBottom;
    					marginBottom = marginBottom.split('px');
    					marginBottom = parseInt(marginBottom[0]);

    				$DOM.toastCapsule.style.visibility = '';
    				$DOM.toastCapsule.style.height = (H+marginBottom+marginTop)+'px';

    				setTimeout(function() {
    					$DOM.toastCapsule.style.height = 'auto';
    					if(settings.target){
    						$DOM.toastCapsule.style.overflow = 'visible';
    					}
    				}, 500);

    				if(settings.timeout) {
    					that.progress(settings, $DOM.toast).start();
    				}
    			}, 100);
    		})();

    		// Target
    		(function(){
    			var position = settings.position;

    			if(settings.target){

    				$DOM.wrapper = document.querySelector(settings.target);
    				$DOM.wrapper.classList.add(PLUGIN_NAME + '-target');

    				if(settings.targetFirst) {
    					$DOM.wrapper.insertBefore($DOM.toastCapsule, $DOM.wrapper.firstChild);
    				} else {
    					$DOM.wrapper.appendChild($DOM.toastCapsule);
    				}

    			} else {

    				if( POSITIONS.indexOf(settings.position) == -1 ){
    					console.warn('['+PLUGIN_NAME+'] Incorrect position.\nIt can be › ' + POSITIONS);
    					return;
    				}

    				if(ISMOBILE || window.innerWidth <= MOBILEWIDTH){
    					if(settings.position == 'bottomLeft' || settings.position == 'bottomRight' || settings.position == 'bottomCenter'){
    						position = PLUGIN_NAME+'-wrapper-bottomCenter';
    					}
    					else if(settings.position == 'topLeft' || settings.position == 'topRight' || settings.position == 'topCenter'){
    						position = PLUGIN_NAME+'-wrapper-topCenter';
    					}
    					else {
    						position = PLUGIN_NAME+'-wrapper-center';
    					}
    				} else {
    					position = PLUGIN_NAME+'-wrapper-'+position;
    				}
    				$DOM.wrapper = document.querySelector('.' + PLUGIN_NAME + '-wrapper.'+position);

    				if(!$DOM.wrapper) {
    					$DOM.wrapper = document.createElement('div');
    					$DOM.wrapper.classList.add(PLUGIN_NAME + '-wrapper');
    					$DOM.wrapper.classList.add(position);
    					document.body.appendChild($DOM.wrapper);
    				}
    				if(settings.position == 'topLeft' || settings.position == 'topCenter' || settings.position == 'topRight'){
    					$DOM.wrapper.insertBefore($DOM.toastCapsule, $DOM.wrapper.firstChild);
    				} else {
    					$DOM.wrapper.appendChild($DOM.toastCapsule);
    				}
    			}

    			if(!isNaN(settings.zindex)) {
    				$DOM.wrapper.style.zIndex = settings.zindex;
    			} else {
    				console.warn('['+PLUGIN_NAME+'] Invalid zIndex.');
    			}
    		})();

    		// Overlay
    		(function(){

    			if(settings.overlay) {

    				if( document.querySelector('.'+PLUGIN_NAME+'-overlay.fadeIn') !== null ){

    					$DOM.overlay = document.querySelector('.'+PLUGIN_NAME+'-overlay');
    					$DOM.overlay.setAttribute('data-iziToast-ref', $DOM.overlay.getAttribute('data-iziToast-ref') + ',' + settings.ref);

    					if(!isNaN(settings.zindex) && settings.zindex !== null) {
    						$DOM.overlay.style.zIndex = settings.zindex-1;
    					}

    				} else {

    					$DOM.overlay.classList.add(PLUGIN_NAME+'-overlay');
    					$DOM.overlay.classList.add('fadeIn');
    					$DOM.overlay.style.background = settings.overlayColor;
    					$DOM.overlay.setAttribute('data-iziToast-ref', settings.ref);
    					if(!isNaN(settings.zindex) && settings.zindex !== null) {
    						$DOM.overlay.style.zIndex = settings.zindex-1;
    					}
    					document.querySelector('body').appendChild($DOM.overlay);
    				}

    				if(settings.overlayClose) {

    					$DOM.overlay.removeEventListener('click', {});
    					$DOM.overlay.addEventListener('click', function (e) {
    						that.hide(settings, $DOM.toast, 'overlay');
    					});
    				} else {
    					$DOM.overlay.removeEventListener('click', {});
    				}
    			}			
    		})();

    		// Inside animations
    		(function(){
    			if(settings.animateInside){
    				$DOM.toast.classList.add(PLUGIN_NAME+'-animateInside');
    			
    				var animationTimes = [200, 100, 300];
    				if(settings.transitionIn == 'bounceInLeft' || settings.transitionIn == 'bounceInRight'){
    					animationTimes = [400, 200, 400];
    				}

    				if(settings.title.length > 0) {
    					setTimeout(function(){
    						$DOM.strong.classList.add('slideIn');
    					}, animationTimes[0]);
    				}

    				if(settings.message.length > 0) {
    					setTimeout(function(){
    						$DOM.p.classList.add('slideIn');
    					}, animationTimes[1]);
    				}

    				if(settings.icon || settings.iconUrl) {
    					setTimeout(function(){
    						$DOM.icon.classList.add('revealIn');
    					}, animationTimes[2]);
    				}

    				var counter = 150;
    				if(settings.buttons.length > 0 && $DOM.buttons) {

    					setTimeout(function(){

    						forEach($DOM.buttons.childNodes, function(element, index) {

    							setTimeout(function(){
    								element.classList.add('revealIn');
    							}, counter);
    							counter = counter + 150;
    						});

    					}, settings.inputs.length > 0 ? 150 : 0);
    				}

    				if(settings.inputs.length > 0 && $DOM.inputs) {
    					counter = 150;
    					forEach($DOM.inputs.childNodes, function(element, index) {

    						setTimeout(function(){
    							element.classList.add('revealIn');
    						}, counter);
    						counter = counter + 150;
    					});
    				}
    			}
    		})();

    		settings.onOpening.apply(null, [settings, $DOM.toast]);

    		try {
    			var event = new CustomEvent(PLUGIN_NAME + '-opening', {detail: settings, bubbles: true, cancelable: true});
    			document.dispatchEvent(event);
    		} catch(ex){
    			console.warn(ex);
    		}

    		setTimeout(function() {

    			$DOM.toast.classList.remove(PLUGIN_NAME+'-opening');
    			$DOM.toast.classList.add(PLUGIN_NAME+'-opened');

    			try {
    				var event = new CustomEvent(PLUGIN_NAME + '-opened', {detail: settings, bubbles: true, cancelable: true});
    				document.dispatchEvent(event);
    			} catch(ex){
    				console.warn(ex);
    			}

    			settings.onOpened.apply(null, [settings, $DOM.toast]);
    		}, 1000);

    		if(settings.drag){

    			if(ACCEPTSTOUCH) {

    			    $DOM.toast.addEventListener('touchstart', function(e) {
    			        drag.startMoving(this, that, settings, e);
    			    }, false);

    			    $DOM.toast.addEventListener('touchend', function(e) {
    			        drag.stopMoving(this, e);
    			    }, false);
    			} else {

    			    $DOM.toast.addEventListener('mousedown', function(e) {
    			    	e.preventDefault();
    			        drag.startMoving(this, that, settings, e);
    			    }, false);

    			    $DOM.toast.addEventListener('mouseup', function(e) {
    			    	e.preventDefault();
    			        drag.stopMoving(this, e);
    			    }, false);
    			}
    		}

    		if(settings.closeOnEscape) {

    			document.addEventListener('keyup', function (evt) {
    				evt = evt || window.event;
    				if(evt.keyCode == 27) {
    				    that.hide(settings, $DOM.toast, 'esc');
    				}
    			});
    		}

    		if(settings.closeOnClick) {
    			$DOM.toast.addEventListener('click', function (evt) {
    				that.hide(settings, $DOM.toast, 'toast');
    			});
    		}

    		that.toast = $DOM.toast;		
    	};
    	

    	return $iziToast;
    });
    });

    const subscriber_queue = [];
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = new Set();
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (const subscriber of subscribers) {
                        subscriber[1]();
                        subscriber_queue.push(subscriber, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.add(subscriber);
            if (subscribers.size === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                subscribers.delete(subscriber);
                if (subscribers.size === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }

    let isAppIdle = writable(false);
    // List to show within Song List component.
    let songListStore = writable([]);
    let selectedAlbumDir = writable(undefined);
    let albumPlayingDirStore = writable(undefined);
    let currentSongDurationStore = writable(0);
    let currentSongProgressStore = writable(0);
    let playingSongStore = writable(undefined);
    // Number = index of the playbackStore to play
    // Boolean = Start playing right away or not.
    let playbackCursor = writable([0, false]);
    let triggerScrollToSongEvent = writable(0);
    let triggerGroupingChangeEvent = writable([]);
    let isSongShuffleEnabledStore = writable(false);
    let isSongRepeatEnabledStore = writable(false);
    let isPlaybackRepeatEnabledStore = writable(false);
    // List to keep track of songs to play.
    let playbackStore = writable([]);
    let activeSongStore = writable(undefined);
    let selectedSongsStore = writable([]);
    /********************** Config **********************/
    let config = writable(undefined);
    /********************** Database **********************/
    let dbSongsStore = writable([]);
    let dbVersionStore = writable(Date.now());
    /********************** Keyboard Events **********************/
    let keyPressed = writable(undefined);
    let appTitle = writable('Jahmin');
    let elementMap = writable(undefined);
    /********************** ConfigLayout **********************/
    let layoutToShow = writable('Lyrics');
    let mainAudioElement = writable(undefined);
    let altAudioElement = writable(undefined);
    let currentAudioElement = writable(undefined);
    /********************** Song Group **********************/
    let selectedGroups = writable([]);
    // Allows to share with the rest of the app whether the player is playing or not.
    let isPlaying = writable(false);
    /********************** Queue Progress **********************/
    let artCompressQueueLength = writable(0);
    let songSyncQueueProgress = writable({
        isSongUpdating: false,
        maxLength: 0,
        currentLength: 0
    });
    let songListItemElement = writable(undefined);
    let songListTagsValuesStore = writable([]);
    let reloadArts = writable(Math.random());

    let db = undefined;
    function setDB(newDb) {
        db = newDb;
    }
    function getDB() {
        return db;
    }

    function bulkGetSongsFn (ids) {
        return new Promise((resolve, reject) => {
            getDB().songs
                .bulkGet(ids)
                .then(songs => {
                resolve(songs);
            })
                .catch(err => {
                reject(err);
            });
        });
    }

    async function handleContextMenuEvent(e) {
        e.preventDefault();
        const pathsName = e.composedPath().map((path) => path.tagName);
        if (pathsName.includes('ALBUM')) {
            let albumElement = e.composedPath().find((path) => path.tagName === 'ALBUM');
            let albumRootDir = albumElement.getAttribute('rootDir');
            window.ipc.showContextMenu('AlbumContextMenu', {
                albumRootDir
            });
        }
        if (pathsName.includes('SONG-LIST')) {
            let clickedSongItem = e
                .composedPath()
                .find((path) => path.tagName === 'SONG-LIST-ITEM');
            let clickedSongId = clickedSongItem === null || clickedSongItem === void 0 ? void 0 : clickedSongItem.dataset.id;
            let clickedSongData = undefined;
            let albumRootDir;
            let selectedSongsId;
            let selectedSongsData = [];
            selectedAlbumDir.subscribe(_ => (albumRootDir = _))();
            selectedSongsStore.subscribe(_ => (selectedSongsId = _))();
            if (clickedSongId) {
                activeSongStore.set(Number(clickedSongId));
                clickedSongData = await bulkGetSongsFn([Number(clickedSongId)]);
                clickedSongData = clickedSongData[0];
            }
            selectedSongsData = await bulkGetSongsFn(selectedSongsId);
            window.ipc.showContextMenu('SongListContextMenu', {
                albumRootDir,
                selectedSongsData,
                clickedSongData: clickedSongData
            });
        }
        if (pathsName.includes('GROUP-NAME')) {
            let groupNameElement = e
                .composedPath()
                .find((path) => path.tagName === 'GROUP-NAME');
            let groupName = groupNameElement.dataset.name;
            let index = groupNameElement.dataset.index;
            window.ipc.showContextMenu('GroupNameContextMenu', {
                groupName,
                index
            });
        }
    }

    function set(key, value) {
        let headStyleElement = document.querySelector('head style');
        let headStyle = headStyleElement.innerHTML;
        headStyle = headStyle.replace(':root{', '').replace('}', '').replace(/\s+/g, ' ').trim();
        headStyle = headStyle
            .split(';')
            .map(foo => foo.split(':'))
            .filter(style => style.length === 2);
        let styleIndex = headStyle.findIndex(style => style[0].includes(key));
        if (styleIndex !== -1) {
            headStyle[styleIndex] = [`--${key}`, value];
        }
        else {
            headStyle.push([`--${key}`, value]);
        }
        headStyleElement.innerHTML = `
    :root{
      ${headStyle.map(foo => foo.join(':')).join(';')};
    }
  `;
    }
    function get$1(key) {
        return getComputedStyle(document.head).getPropertyValue(`--${key}`);
    }
    var cssVariablesService = {
        set,
        get: get$1
    };

    // import { themeConfig } from '../stores/main.store'
    function runThemeHandler() {
        // Enables SystemBased theme when the app first runs.
        enableSystemBasedTheme(window.matchMedia('(prefers-color-scheme: light)').matches);
        // Listens to system theme change and applies proper theme.
        window
            .matchMedia('(prefers-color-scheme: light)')
            .addEventListener('change', (evt) => enableSystemBasedTheme(evt.matches));
        // Listens to changes in theme from AppearanceOption.
        config.subscribe(config => {
            if (config.userOptions.theme === 'Day') {
                // Sets theme to day
                setHTMLThemeAtb(true);
            }
            else if (config.userOptions.theme === 'SystemBased') {
                // Sets theme to system default
                setHTMLThemeAtb(window.matchMedia('(prefers-color-scheme: light)').matches);
            }
            else {
                // Sets theme to night
                setHTMLThemeAtb(false);
            }
        });
    }
    // Sets SystemBased theme ONLY if enabled in the config file or selected as Option.
    function enableSystemBasedTheme(isDayTheme) {
        config.subscribe(config => {
            if (config.userOptions.theme === 'SystemBased') {
                setHTMLThemeAtb(isDayTheme);
            }
        })();
    }
    // Sets the
    function setHTMLThemeAtb(isDayTheme) {
        document.body.setAttribute('theme', isDayTheme ? 'Day' : 'Night');
    }

    let appIdleDebounce = getAppIdleDebounce();
    function onAppMountedService () {
        iziToast.settings({ position: 'topRight' });
        runThemeHandler();
        window.ipc.sendAppReady();
        // To prevent slow transition of colors when app loads, the transition duration is set to 0ms by default then set to 500ms after 2000ms (Long after the app has finished loading).
        setTimeout(() => {
            cssVariablesService.set('theme-transition-duration', '500ms');
        }, 2000);
        window.addEventListener('keydown', evt => keyPressed.set(evt.key));
        window.addEventListener('keyup', () => keyPressed.set(undefined));
        window.addEventListener('mousemove', () => {
            isAppIdle.set(false);
            clearTimeout(appIdleDebounce);
            appIdleDebounce = getAppIdleDebounce();
        });
        // Prevents scroll with spacebar.
        window.addEventListener('keydown', e => {
            return !(e.code === 'Space' && e.target === document.body);
        });
        window.addEventListener('contextmenu', (e) => handleContextMenuEvent(e));
        window.addEventListener('blur', () => {
            document.querySelectorAll('art-svlt video').forEach((videoElement) => {
                videoElement.pause();
            });
            document.querySelectorAll('art-svlt art-animation').forEach((artElement) => {
                let art = artElement.querySelector('.animated');
                let staticArt = artElement.querySelector('.static');
                art.style.display = 'none';
                staticArt.style.display = 'block';
            });
        });
        window.addEventListener('focus', () => {
            document.querySelectorAll('art-svlt video').forEach((videoElement) => {
                videoElement.play();
            });
            document.querySelectorAll('art-svlt art-animation').forEach((artElement) => {
                let art = artElement.querySelector('.animated');
                let staticArt = artElement.querySelector('.static');
                art.style.display = 'block';
                staticArt.style.display = 'none';
            });
        });
    }
    function getAppIdleDebounce() {
        return setTimeout(() => {
            isAppIdle.set(true);
        }, 60000);
    }

    let dbVersion = Date.now();
    let isVersionUpdating = false;
    function updateVersionFn () {
        dbVersion = Date.now();
        // Prevents the app from refreshing too often.
        if (isVersionUpdating === false) {
            isVersionUpdating = true;
            updateStoreVersion();
        }
    }
    function updateStoreVersion() {
        // Saves the store value locally
        let dbVersionStoreLocal = undefined;
        dbVersionStore.subscribe(value => (dbVersionStoreLocal = value))();
        if (dbVersionStoreLocal !== dbVersion) {
            dbVersionStore.set(dbVersion);
            setTimeout(() => {
                updateStoreVersion();
            }, 250);
        }
        else {
            isVersionUpdating = false;
        }
    }

    function bulkDeleteSongsFn (songsId) {
        return new Promise((resolve, reject) => {
            getDB().songs
                .bulkDelete(songsId)
                .then(() => {
                updateVersionFn();
                getDB().songs.count().then(count => {
                    if (count === 0) {
                        dbSongsStore.set([]);
                        updateVersionFn();
                    }
                });
            })
                .catch(err => {
                console.log(err);
            })
                .finally(() => {
                resolve(undefined);
            });
        });
    }

    function bulkInsertSongsFn (songs) {
        return new Promise((resolve, reject) => {
            getDB().songs
                .bulkAdd(songs)
                .then(() => {
                updateVersionFn();
            })
                .catch(err => {
                console.log(err);
            })
                .finally(() => {
                resolve(undefined);
            });
        });
    }

    var isMergeableObject = function isMergeableObject(value) {
    	return isNonNullObject(value)
    		&& !isSpecial(value)
    };

    function isNonNullObject(value) {
    	return !!value && typeof value === 'object'
    }

    function isSpecial(value) {
    	var stringValue = Object.prototype.toString.call(value);

    	return stringValue === '[object RegExp]'
    		|| stringValue === '[object Date]'
    		|| isReactElement(value)
    }

    // see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
    var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

    function isReactElement(value) {
    	return value.$$typeof === REACT_ELEMENT_TYPE
    }

    function emptyTarget(val) {
    	return Array.isArray(val) ? [] : {}
    }

    function cloneUnlessOtherwiseSpecified(value, options) {
    	return (options.clone !== false && options.isMergeableObject(value))
    		? deepmerge(emptyTarget(value), value, options)
    		: value
    }

    function defaultArrayMerge(target, source, options) {
    	return target.concat(source).map(function(element) {
    		return cloneUnlessOtherwiseSpecified(element, options)
    	})
    }

    function getMergeFunction(key, options) {
    	if (!options.customMerge) {
    		return deepmerge
    	}
    	var customMerge = options.customMerge(key);
    	return typeof customMerge === 'function' ? customMerge : deepmerge
    }

    function getEnumerableOwnPropertySymbols(target) {
    	return Object.getOwnPropertySymbols
    		? Object.getOwnPropertySymbols(target).filter(function(symbol) {
    			return target.propertyIsEnumerable(symbol)
    		})
    		: []
    }

    function getKeys(target) {
    	return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))
    }

    function propertyIsOnObject(object, property) {
    	try {
    		return property in object
    	} catch(_) {
    		return false
    	}
    }

    // Protects from prototype poisoning and unexpected merging up the prototype chain.
    function propertyIsUnsafe(target, key) {
    	return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
    		&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
    			&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.
    }

    function mergeObject(target, source, options) {
    	var destination = {};
    	if (options.isMergeableObject(target)) {
    		getKeys(target).forEach(function(key) {
    			destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
    		});
    	}
    	getKeys(source).forEach(function(key) {
    		if (propertyIsUnsafe(target, key)) {
    			return
    		}

    		if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
    			destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
    		} else {
    			destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
    		}
    	});
    	return destination
    }

    function deepmerge(target, source, options) {
    	options = options || {};
    	options.arrayMerge = options.arrayMerge || defaultArrayMerge;
    	options.isMergeableObject = options.isMergeableObject || isMergeableObject;
    	// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
    	// implementations can use it. The caller may not replace it.
    	options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;

    	var sourceIsArray = Array.isArray(source);
    	var targetIsArray = Array.isArray(target);
    	var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

    	if (!sourceAndTargetTypesMatch) {
    		return cloneUnlessOtherwiseSpecified(source, options)
    	} else if (sourceIsArray) {
    		return options.arrayMerge(target, source, options)
    	} else {
    		return mergeObject(target, source, options)
    	}
    }

    deepmerge.all = function deepmergeAll(array, options) {
    	if (!Array.isArray(array)) {
    		throw new Error('first argument should be an array')
    	}

    	return array.reduce(function(prev, next) {
    		return deepmerge(prev, next, options)
    	}, {})
    };

    var deepmerge_1 = deepmerge;

    var cjs = deepmerge_1;

    function bulkUpdateSongsFn (songs) {
        return new Promise((resolve, reject) => {
            updateVariables(songs);
            // Will contain songs grouped by the same new tags to update.
            let updateGroups = [];
            // Iterates through each song gets the id and new tags to update.
            songs.forEach(({ id, newTags }) => {
                // Stringyfies the new tags to use as key for the updateGroups object array.
                let objectKey = JSON.stringify(newTags);
                // Checks if the updateGroups already contains the object key a.k.a. the stringyfied new tags object.
                let findGroup = updateGroups.find(group => group.id === objectKey);
                // If the group already exists, add the song id to the array of songs id.
                if (findGroup) {
                    findGroup.songsId.push(id);
                }
                else {
                    // If the group doesn't exist, create it.
                    updateGroups.push({
                        id: objectKey,
                        newTags,
                        songsId: [id] // The array of songs id to update.
                    });
                }
            });
            // Since multiple bulk update will run, it needs to wait for all the updates to finish before resolving.
            let bulkUpdatePromises = [];
            // Iterates through each group of songs to update and add the promises to the bulk update promises array.
            updateGroups.forEach(group => {
                bulkUpdatePromises.push(getDB().songs.where('ID').anyOf(group.songsId).modify(group.newTags));
            });
            // When all promises are done, then update version, catch errors and finally resolve.
            Promise.all(bulkUpdatePromises)
                .then(x => {
                updateVersionFn();
            })
                .catch(err => {
                console.log(err);
            })
                .finally(() => {
                resolve(undefined);
            });
        });
    }
    function updateVariables(songs) {
        let songListStoreLocal = undefined;
        songListStore.subscribe(value => (songListStoreLocal = value))();
        songs.forEach(song => {
            let arraySongIndex = songListStoreLocal.findIndex(a => a.ID === song.id);
            if (arraySongIndex !== -1) {
                songListStoreLocal[arraySongIndex] = cjs(songListStoreLocal[arraySongIndex], song.newTags);
            }
        });
        songListStore.set(songListStoreLocal);
    }

    class JahminDb extends Dexie$1 {
        constructor() {
            super('JahminDb');
            this.version(2).stores({
                songs: 'ID,PlayCount,Album,AlbumArtist,Artist,Composer,Genre,Title,Track,Rating,Comment,DiscNumber,Date_Year,Date_Month,Date_Day,SourceFile,Extension,Size,Duration,SampleRate,LastModified,BitRate,BitDepth'
            });
        }
    }
    setDB(new JahminDb());
    let taskQueue = [];
    let isQueueRunning = false;
    function addTaskToQueue(object, taskType) {
        taskQueue.push({
            object,
            taskType
        });
        if (isQueueRunning === false) {
            isQueueRunning = true;
            runQueue();
        }
    }
    async function runQueue() {
        // Groups all the same tasks together.
        let addSongQueue = taskQueue.filter(task => task.taskType === 'insert');
        let deleteSongQueue = taskQueue.filter(task => task.taskType === 'delete');
        let updateSongQueue = taskQueue.filter(task => task.taskType === 'update' || task.taskType === 'external-update');
        // Removes from the task queue all the tasks that have grouped.
        addSongQueue.forEach(task => taskQueue.splice(taskQueue.indexOf(task), 1));
        deleteSongQueue.forEach(task => taskQueue.splice(taskQueue.indexOf(task), 1));
        updateSongQueue.forEach(task => taskQueue.splice(taskQueue.indexOf(task), 1));
        if (addSongQueue.length === 0 && deleteSongQueue.length === 0 && updateSongQueue.length === 0) {
            isQueueRunning = false;
            return;
        }
        if (addSongQueue.length > 0) {
            // Run Bulk Add
            await bulkInsertSongsFn(addSongQueue.map(task => task.object));
        }
        if (deleteSongQueue.length > 0) {
            // Run Bulk Delete
            await bulkDeleteSongsFn(deleteSongQueue.map(task => task.object));
        }
        if (updateSongQueue.length > 0) {
            // Run Bulk Update
            await bulkUpdateSongsFn(updateSongQueue.map(task => task.object));
        }
        setTimeout(() => {
            runQueue();
        }, 250);
    }

    function getAllSongsFn () {
        return new Promise((resolve, reject) => {
            dbSongsStore.subscribe((songs) => {
                if (songs.length === 0) {
                    getDB().songs.toArray().then((songs) => {
                        resolve(songs);
                    });
                }
                else {
                    resolve(songs);
                }
            })();
        });
    }

    function generateId() {
        return BigInt(`${String(Math.random()).substring(2)}${Date.now()}`).toString(36);
    }

    /* src/middlewares/IpcMiddleware.svelte generated by Svelte v3.49.0 */

    function create_fragment$1j(ctx) {
    	const block = {
    		c: noop,
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1j($$self, $$props, $$invalidate) {
    	let $artCompressQueueLength;
    	let $songSyncQueueProgress;
    	validate_store(artCompressQueueLength, 'artCompressQueueLength');
    	component_subscribe($$self, artCompressQueueLength, $$value => $$invalidate(0, $artCompressQueueLength = $$value));
    	validate_store(songSyncQueueProgress, 'songSyncQueueProgress');
    	component_subscribe($$self, songSyncQueueProgress, $$value => $$invalidate(1, $songSyncQueueProgress = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('IpcMiddleware', slots, []);

    	window.ipc.onGetAllSongsFromRenderer(() => {
    		getAllSongsFn().then(songs => {
    			window.ipc.sendAllSongsToMain(songs);
    		});
    	});

    	window.ipc.handleWebStorage((_, response) => {
    		addTaskToQueue(response.data, response.type);
    	});

    	window.ipc.handleNewImageArt((_, data) => {
    		handleNewImageArt(data);
    	});

    	window.ipc.handleNewVideoArt((_, data) => {
    		handleNewVideoArt(data);
    	});

    	window.ipc.handleNewAnimationArt((_, data) => {
    		handleNewAnimationArt(data);
    	});

    	window.ipc.songSyncQueueProgress((_, data) => {
    		set_store_value(songSyncQueueProgress, $songSyncQueueProgress = data, $songSyncQueueProgress);
    	});

    	window.ipc.onArtQueueChange((_, artQueueLength) => {
    		set_store_value(artCompressQueueLength, $artCompressQueueLength = artQueueLength, $artCompressQueueLength);
    	});

    	/**
     * @param data
     * This function get the art source data from the main process and sets the source to the proper element.
     *
     * The data received is:
     * 	· The Path of the animated art.
     * 	· The id of the element requesting the art.
     * 	· (Sometimes) The base64 value of the firt frame of the animated art.
     *
     * One of the logic is to show the animated art the the app is focused and show the static first frame of the animated art when not focused.
     */
    	function handleNewAnimationArt(data) {
    		// Selects the Art Container where to set the art src.
    		let element = document.querySelector(`#${CSS.escape(data.elementId)}`);

    		// If the element returns null, it means that the element is not in the DOM anymore.
    		if (element === null) return;

    		if (data.artPath === null) {
    			element.querySelectorAll('*').forEach(videoElement => videoElement.remove());
    			return;
    		}

    		// Gets the Animated Art Container in the Art Container.
    		let artAnimationElement = element.querySelector('art-animation');

    		// Gets both img elements inside the Animated Art Container.
    		let animatedImgElement = element.querySelector('art-animation img.animated');

    		let staticImgElement = element.querySelector('art-animation img.static');

    		// Removes all the direct image elements (does not remove img elements deeper than the Art Container) from the Art Container.
    		element.querySelectorAll(':scope > img').forEach(imageElement => imageElement.remove());

    		// Removes all video elements from the Art Container.
    		element.querySelectorAll('video').forEach(videoElement => videoElement.remove());

    		// If no Animated Art Container found, create it and append it the the Art Container.
    		if (artAnimationElement === null) {
    			artAnimationElement = document.createElement('art-animation');
    			element.appendChild(artAnimationElement);
    		}

    		// If no Animated Image Element found, create it and append it to the Animated Art Container.
    		if (animatedImgElement === null) {
    			animatedImgElement = document.createElement('img');

    			// This class is used the differentiate between animated and static images.
    			animatedImgElement.classList.add('animated');

    			artAnimationElement.appendChild(animatedImgElement);
    		}

    		// If no Static Image Element found, create it and append it to the Animated Art Container.
    		if (staticImgElement === null) {
    			staticImgElement = document.createElement('img');

    			// When loading the art, don't display the static art if the window is focused.
    			if (document.hasFocus() === true) {
    				staticImgElement.style.display = 'none';
    			}

    			// This class is used the differentiate between animated and static images.
    			staticImgElement.classList.add('static');

    			// Appends the Static Image Element to the Animated Art Container.
    			artAnimationElement.appendChild(staticImgElement);
    		}

    		// If data has artAlt, it means that it contains a base64 static image.
    		// If there is no artAlt, it means that there no static image for this animation yet.
    		// The first art request sends the animation right away (from the main process), then, the main process gets the first frame of the animation. When the first frame is done, the animation and its first frame (in base64) is sent back and replaced.
    		// Sets the static source of the animation art.
    		if (data === null || data === void 0 ? void 0 : data.artAlt) staticImgElement.src = `data:image/jpg;base64,${data.artAlt}`;

    		// Sets the animated source of the animation art.
    		animatedImgElement.src = `${data.artPath}?time=${generateId()}`;
    	}

    	/**
     * Shows a video as art.
     */
    	function handleNewVideoArt(data) {
    		// Selects the Art Container where to set the art src.
    		let element = document.querySelector(`#${CSS.escape(data.elementId)}`);

    		// If the element returns null, it means that the element is not in the DOM anymore.
    		if (element === null) return;

    		if (data.artPath === null) {
    			element.querySelectorAll('*').forEach(videoElement => videoElement.remove());
    			return;
    		}

    		// Removes everything that is not the video element inside the element.
    		element.querySelectorAll('img').forEach(imageElement => imageElement.remove());

    		element.querySelectorAll('art-animation').forEach(artAnimationElement => artAnimationElement.remove());

    		// Selects the video element in the Art Container.
    		let videoElement = element.querySelector('video');

    		// If no video element create it and the it's loop atribute to true.
    		if (videoElement === null) {
    			videoElement = document.createElement('video');
    			videoElement.loop = true;

    			// Add the video element to the Main Element
    			element.appendChild(videoElement);
    		}

    		// Sets the source of the video art.
    		videoElement.src = `${data.artPath}?time=${generateId()}`;

    		// If the window is in focus, start playing the video.
    		if (document.hasFocus() === true) {
    			// Plays the video art.
    			videoElement.play();
    		}
    	}

    	function handleNewImageArt(data) {
    		// Selects the Art Container where to set the art src.
    		let element = document.querySelector(`#${CSS.escape(data.elementId)}`);

    		// If the element returns null, it means that the element is not in the DOM anymore.
    		if (element === null) return;

    		if (data.artPath === null) {
    			element.querySelectorAll('*').forEach(videoElement => videoElement.remove());
    			return;
    		}

    		element.querySelectorAll('video').forEach(videoElement => videoElement.remove());
    		element.querySelectorAll('art-animation').forEach(artAnimationElement => artAnimationElement.remove());

    		// Selects the direct image element in the Art Container. The Art Container may contain more img elements from potential animated covers, we don't want to select those.
    		let imgElement = element.querySelector('img');

    		// If no image element, create it.
    		if (imgElement === null) {
    			imgElement = document.createElement('img');
    			element.appendChild(imgElement);
    		}

    		// Sets the source of the image art.
    		imgElement.src = `${data.artPath}?time=${generateId()}`;
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<IpcMiddleware> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		addTaskToQueue,
    		getAllSongsFn,
    		generateId,
    		artCompressQueueLength,
    		songSyncQueueProgress,
    		handleNewAnimationArt,
    		handleNewVideoArt,
    		handleNewImageArt,
    		$artCompressQueueLength,
    		$songSyncQueueProgress
    	});

    	return [];
    }

    class IpcMiddleware extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1j, create_fragment$1j, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "IpcMiddleware",
    			options,
    			id: create_fragment$1j.name
    		});
    	}
    }

    function getDirectoryFn (inputString) {
        return (inputString === null || inputString === void 0 ? void 0 : inputString.split('/').slice(0, -1).join('/')) || '';
    }

    function getAlbumSongsFn (rootDir) {
        return new Promise((resolve, reject) => {
            getAllSongsFn().then(songs => {
                resolve(songs.filter(song => getDirectoryFn(song.SourceFile) === rootDir));
            });
        });
    }

    function applyColorSchemeFn (color) {
        cssVariablesService.set('art-hue', color.hue);
        cssVariablesService.set('art-saturation', color.saturation + '%');
        cssVariablesService.set('art-lightness-dark', color.lightnessDark + '%');
        cssVariablesService.set('art-lightness-base', color.lightnessBase + '%');
        cssVariablesService.set('art-lightness-light', color.lightnessLight + '%');
    }

    function getAlbumColors (rootDir, contrast = undefined) {
        return new Promise((resolve, reject) => {
            window.ipc.getAlbumColors(rootDir, contrast).then((color) => {
                if (color === undefined) {
                    color = {
                        hue: 0,
                        lightnessBase: 30,
                        lightnessLight: 45,
                        lightnessDark: 15,
                        saturation: 0
                    };
                }
                resolve(color);
            });
        });
    }

    function scrollToAlbumFn (rootDir, type) {
        const value = {
            'smooth-scroll': 'smooth',
            'not-smooth-scroll': undefined
        }[type];
        let albumElement = document.querySelector(`[rootDir="${rootDir}"]`);
        if (albumElement) {
            if (value === 'smooth') {
                albumElement.scrollIntoView({ block: 'center', behavior: 'smooth' });
            }
            else if (value === undefined) {
                albumElement.scrollIntoView({ block: 'center', behavior: 'auto' });
            }
        }
    }

    function escapeStringFn (data) {
        data = data.replace('#', escape('#'));
        data = data.replace('?', escape('?'));
        return data;
    }

    /*!
     * wavesurfer.js 6.1.0 (2022-04-05)
     * https://wavesurfer-js.org
     * @license BSD-3-Clause
     */

    var wavesurfer_min = createCommonjsModule(function (module, exports) {
    !function(e,t){module.exports=t();}(self,(()=>{return e={427:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=a(r(138)),i=a(r(56));function a(e){return e&&e.__esModule?e:{default:e}}function s(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n);}}var o=function(){function e(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.wave=null,this.waveCtx=null,this.progress=null,this.progressCtx=null,this.start=0,this.end=1,this.id=(0, i.default)(void 0!==this.constructor.name?this.constructor.name.toLowerCase()+"_":"canvasentry_"),this.canvasContextAttributes={};}var t,r;return t=e,(r=[{key:"initWave",value:function(e){this.wave=e,this.waveCtx=this.wave.getContext("2d",this.canvasContextAttributes);}},{key:"initProgress",value:function(e){this.progress=e,this.progressCtx=this.progress.getContext("2d",this.canvasContextAttributes);}},{key:"updateDimensions",value:function(e,t,r,i){this.start=this.wave.offsetLeft/t||0,this.end=this.start+e/t,this.wave.width=r,this.wave.height=i;var a={width:e+"px"};(0, n.default)(this.wave,a),this.hasProgressCanvas&&(this.progress.width=r,this.progress.height=i,(0, n.default)(this.progress,a));}},{key:"clearWave",value:function(){this.waveCtx.clearRect(0,0,this.waveCtx.canvas.width,this.waveCtx.canvas.height),this.hasProgressCanvas&&this.progressCtx.clearRect(0,0,this.progressCtx.canvas.width,this.progressCtx.canvas.height);}},{key:"setFillStyles",value:function(e,t){this.waveCtx.fillStyle=this.getFillStyle(this.waveCtx,e),this.hasProgressCanvas&&(this.progressCtx.fillStyle=this.getFillStyle(this.progressCtx,t));}},{key:"getFillStyle",value:function(e,t){if("string"==typeof t||t instanceof CanvasGradient)return t;var r=e.createLinearGradient(0,0,0,e.canvas.height);return t.forEach((function(e,n){return r.addColorStop(n/t.length,e)})),r}},{key:"applyCanvasTransforms",value:function(e){e&&(this.waveCtx.setTransform(0,1,1,0,0,0),this.hasProgressCanvas&&this.progressCtx.setTransform(0,1,1,0,0,0));}},{key:"fillRects",value:function(e,t,r,n,i){this.fillRectToContext(this.waveCtx,e,t,r,n,i),this.hasProgressCanvas&&this.fillRectToContext(this.progressCtx,e,t,r,n,i);}},{key:"fillRectToContext",value:function(e,t,r,n,i,a){e&&(a?this.drawRoundedRect(e,t,r,n,i,a):e.fillRect(t,r,n,i));}},{key:"drawRoundedRect",value:function(e,t,r,n,i,a){0!==i&&(i<0&&(r-=i*=-1),e.beginPath(),e.moveTo(t+a,r),e.lineTo(t+n-a,r),e.quadraticCurveTo(t+n,r,t+n,r+a),e.lineTo(t+n,r+i-a),e.quadraticCurveTo(t+n,r+i,t+n-a,r+i),e.lineTo(t+a,r+i),e.quadraticCurveTo(t,r+i,t,r+i-a),e.lineTo(t,r+a),e.quadraticCurveTo(t,r,t+a,r),e.closePath(),e.fill());}},{key:"drawLines",value:function(e,t,r,n,i,a){this.drawLineToContext(this.waveCtx,e,t,r,n,i,a),this.hasProgressCanvas&&this.drawLineToContext(this.progressCtx,e,t,r,n,i,a);}},{key:"drawLineToContext",value:function(e,t,r,n,i,a,s){if(e){var o,u,l,c=t.length/2,f=Math.round(c*this.start),h=f,d=Math.round(c*this.end)+1,p=this.wave.width/(d-h-1),v=n+i,y=r/n;for(e.beginPath(),e.moveTo((h-f)*p,v),e.lineTo((h-f)*p,v-Math.round((t[2*h]||0)/y)),o=h;o<d;o++)u=t[2*o]||0,l=Math.round(u/y),e.lineTo((o-f)*p+this.halfPixel,v-l);for(var m=d-1;m>=h;m--)u=t[2*m+1]||0,l=Math.round(u/y),e.lineTo((m-f)*p+this.halfPixel,v-l);e.lineTo((h-f)*p,v-Math.round((t[2*h+1]||0)/y)),e.closePath(),e.fill();}}},{key:"destroy",value:function(){this.waveCtx=null,this.wave=null,this.progressCtx=null,this.progress=null;}},{key:"getImage",value:function(e,t,r){var n=this;return "blob"===r?new Promise((function(r){n.wave.toBlob(r,e,t);})):"dataURL"===r?this.wave.toDataURL(e,t):void 0}}])&&s(t.prototype,r),Object.defineProperty(t,"prototype",{writable:!1}),e}();t.default=o,e.exports=t.default;},276:(e,t,r)=>{function n(e){return n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},n(e)}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var i=function(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!==n(e)&&"function"!=typeof e)return {default:e};var r=a(t);if(r&&r.has(e))return r.get(e);var i={},s=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in e)if("default"!==o&&Object.prototype.hasOwnProperty.call(e,o)){var u=s?Object.getOwnPropertyDescriptor(e,o):null;u&&(u.get||u.set)?Object.defineProperty(i,o,u):i[o]=e[o];}return i.default=e,r&&r.set(e,i),i}(r(241));function a(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,r=new WeakMap;return (a=function(e){return e?r:t})(e)}function s(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n);}}function o(e,t){return o=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e},o(e,t)}function u(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return !1;if(Reflect.construct.sham)return !1;if("function"==typeof Proxy)return !0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return !1}}();return function(){var r,n=c(e);if(t){var i=c(this).constructor;r=Reflect.construct(n,arguments,i);}else r=n.apply(this,arguments);return l(this,r)}}function l(e,t){if(t&&("object"===n(t)||"function"==typeof t))return t;if(void 0!==t)throw new TypeError("Derived constructors may only return object or undefined");return function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e)}function c(e){return c=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)},c(e)}var f=function(e){!function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,"prototype",{writable:!1}),t&&o(e,t);}(l,e);var t,r,a=u(l);function l(e,t){var r;return function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,l),(r=a.call(this)).container=i.withOrientation(e,t.vertical),r.params=t,r.width=0,r.height=t.height*r.params.pixelRatio,r.lastPos=0,r.wrapper=null,r}return t=l,(r=[{key:"style",value:function(e,t){return i.style(e,t)}},{key:"createWrapper",value:function(){this.wrapper=i.withOrientation(this.container.appendChild(document.createElement("wave")),this.params.vertical),this.style(this.wrapper,{display:"block",position:"relative",userSelect:"none",webkitUserSelect:"none",height:this.params.height+"px"}),(this.params.fillParent||this.params.scrollParent)&&this.style(this.wrapper,{width:"100%",cursor:this.params.hideCursor?"none":"auto",overflowX:this.params.hideScrollbar?"hidden":"auto",overflowY:"hidden"}),this.setupWrapperEvents();}},{key:"handleEvent",value:function(e,t){!t&&e.preventDefault();var r,n=i.withOrientation(e.targetTouches?e.targetTouches[0]:e,this.params.vertical).clientX,a=this.wrapper.getBoundingClientRect(),s=this.width,o=this.getWidth(),u=this.getProgressPixels(a,n);return r=!this.params.fillParent&&s<o?u*(this.params.pixelRatio/s)||0:(u+this.wrapper.scrollLeft)/this.wrapper.scrollWidth||0,i.clamp(r,0,1)}},{key:"getProgressPixels",value:function(e,t){return this.params.rtl?e.right-t:t-e.left}},{key:"setupWrapperEvents",value:function(){var e=this;this.wrapper.addEventListener("click",(function(t){var r=i.withOrientation(t,e.params.vertical),n=e.wrapper.offsetHeight-e.wrapper.clientHeight;if(0!==n){var a=e.wrapper.getBoundingClientRect();if(r.clientY>=a.bottom-n)return}e.params.interact&&e.fireEvent("click",t,e.handleEvent(t));})),this.wrapper.addEventListener("dblclick",(function(t){e.params.interact&&e.fireEvent("dblclick",t,e.handleEvent(t));})),this.wrapper.addEventListener("scroll",(function(t){return e.fireEvent("scroll",t)}));}},{key:"drawPeaks",value:function(e,t,r,n){this.setWidth(t)||this.clearWave(),this.params.barWidth?this.drawBars(e,0,r,n):this.drawWave(e,0,r,n);}},{key:"resetScroll",value:function(){null!==this.wrapper&&(this.wrapper.scrollLeft=0);}},{key:"recenter",value:function(e){var t=this.wrapper.scrollWidth*e;this.recenterOnPosition(t,!0);}},{key:"recenterOnPosition",value:function(e,t){var r=this.wrapper.scrollLeft,n=~~(this.wrapper.clientWidth/2),i=this.wrapper.scrollWidth-this.wrapper.clientWidth,a=e-n,s=a-r;if(0!=i){if(!t&&-n<=s&&s<n){var o=this.params.autoCenterRate;o/=n,o*=i,a=r+(s=Math.max(-o,Math.min(o,s)));}(a=Math.max(0,Math.min(i,a)))!=r&&(this.wrapper.scrollLeft=a);}}},{key:"getScrollX",value:function(){var e=0;if(this.wrapper){var t=this.params.pixelRatio;if(e=Math.round(this.wrapper.scrollLeft*t),this.params.scrollParent){var r=~~(this.wrapper.scrollWidth*t-this.getWidth());e=Math.min(r,Math.max(0,e));}}return e}},{key:"getWidth",value:function(){return Math.round(this.container.clientWidth*this.params.pixelRatio)}},{key:"setWidth",value:function(e){if(this.width==e)return !1;if(this.width=e,this.params.fillParent||this.params.scrollParent)this.style(this.wrapper,{width:""});else {var t=~~(this.width/this.params.pixelRatio)+"px";this.style(this.wrapper,{width:t});}return this.updateSize(),!0}},{key:"setHeight",value:function(e){return e!=this.height&&(this.height=e,this.style(this.wrapper,{height:~~(this.height/this.params.pixelRatio)+"px"}),this.updateSize(),!0)}},{key:"progress",value:function(e){var t=1/this.params.pixelRatio,r=Math.round(e*this.width)*t;if(r<this.lastPos||r-this.lastPos>=t){if(this.lastPos=r,this.params.scrollParent&&this.params.autoCenter){var n=~~(this.wrapper.scrollWidth*e);this.recenterOnPosition(n,this.params.autoCenterImmediately);}this.updateProgress(r);}}},{key:"destroy",value:function(){this.unAll(),this.wrapper&&(this.wrapper.parentNode==this.container.domElement&&this.container.removeChild(this.wrapper.domElement),this.wrapper=null);}},{key:"updateCursor",value:function(){}},{key:"updateSize",value:function(){}},{key:"drawBars",value:function(e,t,r,n){}},{key:"drawWave",value:function(e,t,r,n){}},{key:"clearWave",value:function(){}},{key:"updateProgress",value:function(e){}}])&&s(t.prototype,r),Object.defineProperty(t,"prototype",{writable:!1}),l}(i.Observer);t.default=f,e.exports=t.default;},646:(e,t,r)=>{function n(e){return n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},n(e)}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var i=u(r(276)),a=function(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!==n(e)&&"function"!=typeof e)return {default:e};var r=o(t);if(r&&r.has(e))return r.get(e);var i={},a=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var s in e)if("default"!==s&&Object.prototype.hasOwnProperty.call(e,s)){var u=a?Object.getOwnPropertyDescriptor(e,s):null;u&&(u.get||u.set)?Object.defineProperty(i,s,u):i[s]=e[s];}return i.default=e,r&&r.set(e,i),i}(r(241)),s=u(r(427));function o(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,r=new WeakMap;return (o=function(e){return e?r:t})(e)}function u(e){return e&&e.__esModule?e:{default:e}}function l(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n);}}function c(e,t){return c=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e},c(e,t)}function f(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return !1;if(Reflect.construct.sham)return !1;if("function"==typeof Proxy)return !0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return !1}}();return function(){var r,n=d(e);if(t){var i=d(this).constructor;r=Reflect.construct(n,arguments,i);}else r=n.apply(this,arguments);return h(this,r)}}function h(e,t){if(t&&("object"===n(t)||"function"==typeof t))return t;if(void 0!==t)throw new TypeError("Derived constructors may only return object or undefined");return function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e)}function d(e){return d=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)},d(e)}var p=function(e){!function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,"prototype",{writable:!1}),t&&c(e,t);}(o,e);var t,r,i=f(o);function o(e,t){var r;return function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,o),(r=i.call(this,e,t)).maxCanvasWidth=t.maxCanvasWidth,r.maxCanvasElementWidth=Math.round(t.maxCanvasWidth/t.pixelRatio),r.hasProgressCanvas=t.waveColor!=t.progressColor,r.halfPixel=.5/t.pixelRatio,r.canvases=[],r.progressWave=null,r.EntryClass=s.default,r.canvasContextAttributes=t.drawingContextAttributes,r.overlap=2*Math.ceil(t.pixelRatio/2),r.barRadius=t.barRadius||0,r.vertical=t.vertical,r}return t=o,r=[{key:"init",value:function(){this.createWrapper(),this.createElements();}},{key:"createElements",value:function(){this.progressWave=a.withOrientation(this.wrapper.appendChild(document.createElement("wave")),this.params.vertical),this.style(this.progressWave,{position:"absolute",zIndex:3,left:0,top:0,bottom:0,overflow:"hidden",width:"0",display:"none",boxSizing:"border-box",borderRightStyle:"solid",pointerEvents:"none"}),this.addCanvas(),this.updateCursor();}},{key:"updateCursor",value:function(){this.style(this.progressWave,{borderRightWidth:this.params.cursorWidth+"px",borderRightColor:this.params.cursorColor});}},{key:"updateSize",value:function(){for(var e=this,t=Math.round(this.width/this.params.pixelRatio),r=Math.ceil(t/(this.maxCanvasElementWidth+this.overlap));this.canvases.length<r;)this.addCanvas();for(;this.canvases.length>r;)this.removeCanvas();var n=this.maxCanvasWidth+this.overlap,i=this.canvases.length-1;this.canvases.forEach((function(t,r){r==i&&(n=e.width-e.maxCanvasWidth*i),e.updateDimensions(t,n,e.height),t.clearWave();}));}},{key:"addCanvas",value:function(){var e=new this.EntryClass;e.canvasContextAttributes=this.canvasContextAttributes,e.hasProgressCanvas=this.hasProgressCanvas,e.halfPixel=this.halfPixel;var t=this.maxCanvasElementWidth*this.canvases.length,r=a.withOrientation(this.wrapper.appendChild(document.createElement("canvas")),this.params.vertical);if(this.style(r,{position:"absolute",zIndex:2,left:t+"px",top:0,bottom:0,height:"100%",pointerEvents:"none"}),e.initWave(r),this.hasProgressCanvas){var n=a.withOrientation(this.progressWave.appendChild(document.createElement("canvas")),this.params.vertical);this.style(n,{position:"absolute",left:t+"px",top:0,bottom:0,height:"100%"}),e.initProgress(n);}this.canvases.push(e);}},{key:"removeCanvas",value:function(){var e=this.canvases[this.canvases.length-1];e.wave.parentElement.removeChild(e.wave.domElement),this.hasProgressCanvas&&e.progress.parentElement.removeChild(e.progress.domElement),e&&(e.destroy(),e=null),this.canvases.pop();}},{key:"updateDimensions",value:function(e,t,r){var n=Math.round(t/this.params.pixelRatio),i=Math.round(this.width/this.params.pixelRatio);e.updateDimensions(n,i,t,r),this.style(this.progressWave,{display:"block"});}},{key:"clearWave",value:function(){var e=this;a.frame((function(){e.canvases.forEach((function(e){return e.clearWave()}));}))();}},{key:"drawBars",value:function(e,t,r,n){var i=this;return this.prepareDraw(e,t,r,n,(function(e){var t=e.absmax,a=e.hasMinVals,s=(e.height,e.offsetY),o=e.halfH,u=e.peaks,l=e.channelIndex;if(void 0!==r)for(var c=a?2:1,f=u.length/c/i.width,h=n,d=r;d<h;d+=.1){var p=0,v=Math.floor(d*f)*c,y=Math.floor((d+.1)*f)*c;do{var m=Math.abs(u[v]);m>p&&(p=m),v+=c;}while(v<y);var b=Math.round(p/t*o);0==b&&i.params.barMinHeight&&(b=i.params.barMinHeight),i.fillRect(d+i.halfPixel,o-b+s,.1+i.halfPixel,2*b,0,l);}}))}},{key:"drawWave",value:function(e,t,r,n){var i=this;return this.prepareDraw(e,t,r,n,(function(e){var t=e.absmax,a=e.hasMinVals,s=(e.height,e.offsetY),o=e.halfH,u=e.peaks,l=e.channelIndex;if(!a){for(var c=[],f=u.length,h=0;h<f;h++)c[2*h]=u[h],c[2*h+1]=-u[h];u=c;}void 0!==r&&i.drawLine(u,t,o,s,r,n,l),i.fillRect(0,o+s-i.halfPixel,i.width,i.halfPixel,i.barRadius,l);}))}},{key:"drawLine",value:function(e,t,r,n,i,a,s){var o=this,u=this.params.splitChannelsOptions.channelColors[s]||{},l=u.waveColor,c=u.progressColor;this.canvases.forEach((function(s,u){o.setFillStyles(s,l,c),o.applyCanvasTransforms(s,o.params.vertical),s.drawLines(e,t,r,n,i,a);}));}},{key:"fillRect",value:function(e,t,r,n,i,a){for(var s=Math.floor(e/this.maxCanvasWidth),o=Math.min(Math.ceil((e+r)/this.maxCanvasWidth)+1,this.canvases.length),u=s;u<o;u++){var l=this.canvases[u],c=u*this.maxCanvasWidth,f={x1:Math.max(e,u*this.maxCanvasWidth),y1:t,x2:Math.min(e+r,u*this.maxCanvasWidth+l.wave.width),y2:t+n};if(f.x1<f.x2){var h=this.params.splitChannelsOptions.channelColors[a]||{},d=h.waveColor,p=h.progressColor;this.setFillStyles(l,d,p),this.applyCanvasTransforms(l,this.params.vertical),l.fillRects(f.x1-c,f.y1,f.x2-f.x1,f.y2-f.y1,i);}}}},{key:"hideChannel",value:function(e){return this.params.splitChannels&&this.params.splitChannelsOptions.filterChannels.includes(e)}},{key:"prepareDraw",value:function(e,t,r,n,i,s,o){var u=this;return a.frame((function(){if(e[0]instanceof Array){var l=e;if(u.params.splitChannels){var c,f=l.filter((function(e,t){return !u.hideChannel(t)}));return u.params.splitChannelsOptions.overlay||u.setHeight(Math.max(f.length,1)*u.params.height*u.params.pixelRatio),u.params.splitChannelsOptions&&u.params.splitChannelsOptions.relativeNormalization&&(c=a.max(l.map((function(e){return a.absMax(e)})))),l.forEach((function(e,t){return u.prepareDraw(e,t,r,n,i,f.indexOf(e),c)}))}e=l[0];}if(!u.hideChannel(t)){var h=1/u.params.barHeight;u.params.normalize&&(h=void 0===o?a.absMax(e):o);var d=[].some.call(e,(function(e){return e<0})),p=u.params.height*u.params.pixelRatio,v=p/2,y=p*s||0;return u.params.splitChannelsOptions&&u.params.splitChannelsOptions.overlay&&(y=0),i({absmax:h,hasMinVals:d,height:p,offsetY:y,halfH:v,peaks:e,channelIndex:t})}}))()}},{key:"setFillStyles",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.params.waveColor,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.params.progressColor;e.setFillStyles(t,r);}},{key:"applyCanvasTransforms",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];e.applyCanvasTransforms(t);}},{key:"getImage",value:function(e,t,r){if("blob"===r)return Promise.all(this.canvases.map((function(n){return n.getImage(e,t,r)})));if("dataURL"===r){var n=this.canvases.map((function(n){return n.getImage(e,t,r)}));return n.length>1?n:n[0]}}},{key:"updateProgress",value:function(e){this.style(this.progressWave,{width:e+"px"});}}],r&&l(t.prototype,r),Object.defineProperty(t,"prototype",{writable:!1}),o}(i.default);t.default=p,e.exports=t.default;},328:(e,t,r)=>{function n(e){return n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},n(e)}var i;function a(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n);}}function s(){return s="undefined"!=typeof Reflect&&Reflect.get?Reflect.get:function(e,t,r){var n=o(e,t);if(n){var i=Object.getOwnPropertyDescriptor(n,t);return i.get?i.get.call(arguments.length<3?e:r):i.value}},s.apply(this,arguments)}function o(e,t){for(;!Object.prototype.hasOwnProperty.call(e,t)&&null!==(e=f(e)););return e}function u(e,t){return u=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e},u(e,t)}function l(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return !1;if(Reflect.construct.sham)return !1;if("function"==typeof Proxy)return !0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return !1}}();return function(){var r,n=f(e);if(t){var i=f(this).constructor;r=Reflect.construct(n,arguments,i);}else r=n.apply(this,arguments);return c(this,r)}}function c(e,t){if(t&&("object"===n(t)||"function"==typeof t))return t;if(void 0!==t)throw new TypeError("Derived constructors may only return object or undefined");return function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e)}function f(e){return f=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)},f(e)}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var h=function(e){!function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,"prototype",{writable:!1}),t&&u(e,t);}(o,e);var t,r,i=l(o);function o(e){var t;return function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,o),(t=i.call(this,e)).params=e,t.sourceMediaElement=null,t}return t=o,(r=[{key:"init",value:function(){this.setPlaybackRate(this.params.audioRate),this.createTimer(),this.createVolumeNode(),this.createScriptNode(),this.createAnalyserNode();}},{key:"_load",value:function(e,t,r){s(f(o.prototype),"_load",this).call(this,e,t,r),this.createMediaElementSource(e);}},{key:"createMediaElementSource",value:function(e){this.sourceMediaElement=this.ac.createMediaElementSource(e),this.sourceMediaElement.connect(this.analyser);}},{key:"play",value:function(e,t){return this.resumeAudioContext(),s(f(o.prototype),"play",this).call(this,e,t)}},{key:"destroy",value:function(){s(f(o.prototype),"destroy",this).call(this),this.destroyWebAudio();}}])&&a(t.prototype,r),Object.defineProperty(t,"prototype",{writable:!1}),o}(((i=r(743))&&i.__esModule?i:{default:i}).default);t.default=h,e.exports=t.default;},743:(e,t,r)=>{function n(e){return n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},n(e)}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var i,a=(i=r(379))&&i.__esModule?i:{default:i},s=function(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!==n(e)&&"function"!=typeof e)return {default:e};var r=o(t);if(r&&r.has(e))return r.get(e);var i={},a=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var s in e)if("default"!==s&&Object.prototype.hasOwnProperty.call(e,s)){var u=a?Object.getOwnPropertyDescriptor(e,s):null;u&&(u.get||u.set)?Object.defineProperty(i,s,u):i[s]=e[s];}return i.default=e,r&&r.set(e,i),i}(r(241));function o(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,r=new WeakMap;return (o=function(e){return e?r:t})(e)}function u(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n);}}function l(){return l="undefined"!=typeof Reflect&&Reflect.get?Reflect.get:function(e,t,r){var n=c(e,t);if(n){var i=Object.getOwnPropertyDescriptor(n,t);return i.get?i.get.call(arguments.length<3?e:r):i.value}},l.apply(this,arguments)}function c(e,t){for(;!Object.prototype.hasOwnProperty.call(e,t)&&null!==(e=p(e)););return e}function f(e,t){return f=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e},f(e,t)}function h(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return !1;if(Reflect.construct.sham)return !1;if("function"==typeof Proxy)return !0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return !1}}();return function(){var r,n=p(e);if(t){var i=p(this).constructor;r=Reflect.construct(n,arguments,i);}else r=n.apply(this,arguments);return d(this,r)}}function d(e,t){if(t&&("object"===n(t)||"function"==typeof t))return t;if(void 0!==t)throw new TypeError("Derived constructors may only return object or undefined");return function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e)}function p(e){return p=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)},p(e)}var v=function(e){!function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,"prototype",{writable:!1}),t&&f(e,t);}(a,e);var t,r,i=h(a);function a(e){var t;return function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,a),(t=i.call(this,e)).params=e,t.media={currentTime:0,duration:0,paused:!0,playbackRate:1,play:function(){},pause:function(){},volume:0},t.mediaType=e.mediaType.toLowerCase(),t.elementPosition=e.elementPosition,t.peaks=null,t.playbackRate=1,t.volume=1,t.isMuted=!1,t.buffer=null,t.onPlayEnd=null,t.mediaListeners={},t}return t=a,(r=[{key:"init",value:function(){this.setPlaybackRate(this.params.audioRate),this.createTimer();}},{key:"_setupMediaListeners",value:function(){var e=this;this.mediaListeners.error=function(){e.fireEvent("error","Error loading media element");},this.mediaListeners.canplay=function(){e.fireEvent("canplay");},this.mediaListeners.ended=function(){e.fireEvent("finish");},this.mediaListeners.play=function(){e.fireEvent("play");},this.mediaListeners.pause=function(){e.fireEvent("pause");},this.mediaListeners.seeked=function(t){e.fireEvent("seek");},this.mediaListeners.volumechange=function(t){e.isMuted=e.media.muted,e.isMuted?e.volume=0:e.volume=e.media.volume,e.fireEvent("volume");},Object.keys(this.mediaListeners).forEach((function(t){e.media.removeEventListener(t,e.mediaListeners[t]),e.media.addEventListener(t,e.mediaListeners[t]);}));}},{key:"createTimer",value:function(){var e=this;this.on("play",(function t(){e.isPaused()||(e.fireEvent("audioprocess",e.getCurrentTime()),s.frame(t)());})),this.on("pause",(function(){e.fireEvent("audioprocess",e.getCurrentTime());}));}},{key:"load",value:function(e,t,r,n){var i=document.createElement(this.mediaType);i.controls=this.params.mediaControls,i.autoplay=this.params.autoplay||!1,i.preload=null==n?"auto":n,i.src=e,i.style.width="100%";var a=t.querySelector(this.mediaType);a&&t.removeChild(a),t.appendChild(i),this._load(i,r,n);}},{key:"loadElt",value:function(e,t){e.controls=this.params.mediaControls,e.autoplay=this.params.autoplay||!1,this._load(e,t,e.preload);}},{key:"_load",value:function(e,t,r){if(!(e instanceof HTMLMediaElement)||void 0===e.addEventListener)throw new Error("media parameter is not a valid media element");"function"!=typeof e.load||t&&"none"==r||e.load(),this.media=e,this._setupMediaListeners(),this.peaks=t,this.onPlayEnd=null,this.buffer=null,this.isMuted=e.muted,this.setPlaybackRate(this.playbackRate),this.setVolume(this.volume);}},{key:"isPaused",value:function(){return !this.media||this.media.paused}},{key:"getDuration",value:function(){if(this.explicitDuration)return this.explicitDuration;var e=(this.buffer||this.media).duration;return e>=1/0&&(e=this.media.seekable.end(0)),e}},{key:"getCurrentTime",value:function(){return this.media&&this.media.currentTime}},{key:"getPlayedPercents",value:function(){return this.getCurrentTime()/this.getDuration()||0}},{key:"getPlaybackRate",value:function(){return this.playbackRate||this.media.playbackRate}},{key:"setPlaybackRate",value:function(e){this.playbackRate=e||1,this.media.playbackRate=this.playbackRate;}},{key:"seekTo",value:function(e){null==e||isNaN(e)||(this.media.currentTime=e),this.clearPlayEnd();}},{key:"play",value:function(e,t){this.seekTo(e);var r=this.media.play();return t&&this.setPlayEnd(t),r}},{key:"pause",value:function(){var e;return this.media&&(e=this.media.pause()),this.clearPlayEnd(),e}},{key:"setPlayEnd",value:function(e){var t=this;this.clearPlayEnd(),this._onPlayEnd=function(r){r>=e&&(t.pause(),t.seekTo(e));},this.on("audioprocess",this._onPlayEnd);}},{key:"clearPlayEnd",value:function(){this._onPlayEnd&&(this.un("audioprocess",this._onPlayEnd),this._onPlayEnd=null);}},{key:"getPeaks",value:function(e,t,r){return this.buffer?l(p(a.prototype),"getPeaks",this).call(this,e,t,r):this.peaks||[]}},{key:"setSinkId",value:function(e){return e?this.media.setSinkId?this.media.setSinkId(e):Promise.reject(new Error("setSinkId is not supported in your browser")):Promise.reject(new Error("Invalid deviceId: "+e))}},{key:"getVolume",value:function(){return this.volume}},{key:"setVolume",value:function(e){this.volume=e,this.media.volume!==this.volume&&(this.media.volume=this.volume);}},{key:"setMute",value:function(e){this.isMuted=this.media.muted=e;}},{key:"destroy",value:function(){var e=this;this.pause(),this.unAll(),this.destroyed=!0,Object.keys(this.mediaListeners).forEach((function(t){e.media&&e.media.removeEventListener(t,e.mediaListeners[t]);})),this.params.removeMediaElementOnDestroy&&this.media&&this.media.parentNode&&this.media.parentNode.removeChild(this.media),this.media=null;}}])&&u(t.prototype,r),Object.defineProperty(t,"prototype",{writable:!1}),a}(a.default);t.default=v,e.exports=t.default;},227:(e,t)=>{function r(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n);}}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=function(){function e(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.clearPeakCache();}var t,n;return t=e,(n=[{key:"clearPeakCache",value:function(){this.peakCacheRanges=[],this.peakCacheLength=-1;}},{key:"addRangeToPeakCache",value:function(e,t,r){e!=this.peakCacheLength&&(this.clearPeakCache(),this.peakCacheLength=e);for(var n=[],i=0;i<this.peakCacheRanges.length&&this.peakCacheRanges[i]<t;)i++;for(i%2==0&&n.push(t);i<this.peakCacheRanges.length&&this.peakCacheRanges[i]<=r;)n.push(this.peakCacheRanges[i]),i++;i%2==0&&n.push(r),n=n.filter((function(e,t,r){return 0==t?e!=r[t+1]:t==r.length-1?e!=r[t-1]:e!=r[t-1]&&e!=r[t+1]})),this.peakCacheRanges=this.peakCacheRanges.concat(n),this.peakCacheRanges=this.peakCacheRanges.sort((function(e,t){return e-t})).filter((function(e,t,r){return 0==t?e!=r[t+1]:t==r.length-1?e!=r[t-1]:e!=r[t-1]&&e!=r[t+1]}));var a=[];for(i=0;i<n.length;i+=2)a.push([n[i],n[i+1]]);return a}},{key:"getCacheRanges",value:function(){var e,t=[];for(e=0;e<this.peakCacheRanges.length;e+=2)t.push([this.peakCacheRanges[e],this.peakCacheRanges[e+1]]);return t}}])&&r(t.prototype,n),Object.defineProperty(t,"prototype",{writable:!1}),e}();t.default=n,e.exports=t.default;},765:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){var t=(0, n.default)(e),r=(0, i.default)(e);return -r>t?-r:t};var n=a(r(178)),i=a(r(706));function a(e){return e&&e.__esModule?e:{default:e}}e.exports=t.default;},694:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,r){return Math.min(Math.max(t,e),r)},e.exports=t.default;},342:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){if(!e)throw new Error("fetch options missing");if(!e.url)throw new Error("fetch url missing");var t=new i.default,r=new Headers,n=new Request(e.url);t.controller=new AbortController,e&&e.requestHeaders&&e.requestHeaders.forEach((function(e){r.append(e.key,e.value);}));var a=e.responseType||"json",o={method:e.method||"GET",headers:r,mode:e.mode||"cors",credentials:e.credentials||"same-origin",cache:e.cache||"default",redirect:e.redirect||"follow",referrer:e.referrer||"client",signal:t.controller.signal};return fetch(n,o).then((function(e){t.response=e;var r=!0;e.body||(r=!1);var n=e.headers.get("content-length");return null===n&&(r=!1),r?(t.onProgress=function(e){t.fireEvent("progress",e);},new Response(new ReadableStream(new s(t,n,e)),o)):e})).then((function(e){var t;if(e.ok)switch(a){case"arraybuffer":return e.arrayBuffer();case"json":return e.json();case"blob":return e.blob();case"text":return e.text();default:t="Unknown responseType: "+a;}throw t||(t="HTTP error status: "+e.status),new Error(t)})).then((function(e){t.fireEvent("success",e);})).catch((function(e){t.fireEvent("error",e);})),t.fetchRequest=n,t};var n,i=(n=r(399))&&n.__esModule?n:{default:n};function a(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n);}}var s=function(){function e(t,r,n){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.instance=t,this.instance._reader=n.body.getReader(),this.total=parseInt(r,10),this.loaded=0;}var t,r;return t=e,(r=[{key:"start",value:function(e){var t=this;!function r(){t.instance._reader.read().then((function(n){var i=n.done,a=n.value;if(i)return 0===t.total&&t.instance.onProgress.call(t.instance,{loaded:t.loaded,total:t.total,lengthComputable:!1}),void e.close();t.loaded+=a.byteLength,t.instance.onProgress.call(t.instance,{loaded:t.loaded,total:t.total,lengthComputable:!(0===t.total)}),e.enqueue(a),r();})).catch((function(t){e.error(t);}));}();}}])&&a(t.prototype,r),Object.defineProperty(t,"prototype",{writable:!1}),e}();e.exports=t.default;},412:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){return function(){for(var t=arguments.length,r=new Array(t),n=0;n<t;n++)r[n]=arguments[n];return (0, i.default)((function(){return e.apply(void 0,r)}))}};var n,i=(n=r(779))&&n.__esModule?n:{default:n};e.exports=t.default;},56:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){return void 0===e&&(e="wavesurfer_"),e+Math.random().toString(32).substring(2)},e.exports=t.default;},241:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),Object.defineProperty(t,"Observer",{enumerable:!0,get:function(){return o.default}}),Object.defineProperty(t,"absMax",{enumerable:!0,get:function(){return s.default}}),Object.defineProperty(t,"clamp",{enumerable:!0,get:function(){return p.default}}),Object.defineProperty(t,"debounce",{enumerable:!0,get:function(){return f.default}}),Object.defineProperty(t,"fetchFile",{enumerable:!0,get:function(){return d.default}}),Object.defineProperty(t,"frame",{enumerable:!0,get:function(){return c.default}}),Object.defineProperty(t,"getId",{enumerable:!0,get:function(){return n.default}}),Object.defineProperty(t,"ignoreSilenceMode",{enumerable:!0,get:function(){return y.default}}),Object.defineProperty(t,"max",{enumerable:!0,get:function(){return i.default}}),Object.defineProperty(t,"min",{enumerable:!0,get:function(){return a.default}}),Object.defineProperty(t,"preventClick",{enumerable:!0,get:function(){return h.default}}),Object.defineProperty(t,"requestAnimationFrame",{enumerable:!0,get:function(){return l.default}}),Object.defineProperty(t,"style",{enumerable:!0,get:function(){return u.default}}),Object.defineProperty(t,"withOrientation",{enumerable:!0,get:function(){return v.default}});var n=m(r(56)),i=m(r(178)),a=m(r(706)),s=m(r(765)),o=m(r(399)),u=m(r(138)),l=m(r(779)),c=m(r(412)),f=m(r(296)),h=m(r(529)),d=m(r(342)),p=m(r(694)),v=m(r(713)),y=m(r(457));function m(e){return e&&e.__esModule?e:{default:e}}},178:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){var t=-1/0;return Object.keys(e).forEach((function(r){e[r]>t&&(t=e[r]);})),t},e.exports=t.default;},706:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){var t=Number(1/0);return Object.keys(e).forEach((function(r){e[r]<t&&(t=e[r]);})),t},e.exports=t.default;},399:(e,t)=>{function r(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n);}}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=function(){function e(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this._disabledEventEmissions=[],this.handlers=null;}var t,n;return t=e,n=[{key:"on",value:function(e,t){var r=this;this.handlers||(this.handlers={});var n=this.handlers[e];return n||(n=this.handlers[e]=[]),n.push(t),{name:e,callback:t,un:function(e,t){return r.un(e,t)}}}},{key:"un",value:function(e,t){if(this.handlers){var r,n=this.handlers[e];if(n)if(t)for(r=n.length-1;r>=0;r--)n[r]==t&&n.splice(r,1);else n.length=0;}}},{key:"unAll",value:function(){this.handlers=null;}},{key:"once",value:function(e,t){var r=this;return this.on(e,(function n(){for(var i=arguments.length,a=new Array(i),s=0;s<i;s++)a[s]=arguments[s];t.apply(r,a),setTimeout((function(){r.un(e,n);}),0);}))}},{key:"setDisabledEventEmissions",value:function(e){this._disabledEventEmissions=e;}},{key:"_isDisabledEventEmission",value:function(e){return this._disabledEventEmissions&&this._disabledEventEmissions.includes(e)}},{key:"fireEvent",value:function(e){for(var t=arguments.length,r=new Array(t>1?t-1:0),n=1;n<t;n++)r[n-1]=arguments[n];if(this.handlers&&!this._isDisabledEventEmission(e)){var i=this.handlers[e];i&&i.forEach((function(e){e.apply(void 0,r);}));}}}],n&&r(t.prototype,n),Object.defineProperty(t,"prototype",{writable:!1}),e}();t.default=n,e.exports=t.default;},713:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function e(t,r){return t[i]?t:new Proxy(t,{get:function(t,a,s){if(a===i)return !0;if("domElement"===a)return t;if("style"===a)return e(t.style,r);if("canvas"===a)return e(t.canvas,r);if("getBoundingClientRect"===a)return function(){return e(t.getBoundingClientRect.apply(t,arguments),r)};if("getContext"===a)return function(){return e(t.getContext.apply(t,arguments),r)};var o=t[n(a,r)];return "function"==typeof o?o.bind(t):o},set:function(e,t,i){return e[n(t,r)]=i,!0}})};var r={width:"height",height:"width",overflowX:"overflowY",overflowY:"overflowX",clientWidth:"clientHeight",clientHeight:"clientWidth",clientX:"clientY",clientY:"clientX",scrollWidth:"scrollHeight",scrollLeft:"scrollTop",offsetLeft:"offsetTop",offsetTop:"offsetLeft",offsetHeight:"offsetWidth",offsetWidth:"offsetHeight",left:"top",right:"bottom",top:"left",bottom:"right",borderRightStyle:"borderBottomStyle",borderRightWidth:"borderBottomWidth",borderRightColor:"borderBottomColor"};function n(e,t){return Object.prototype.hasOwnProperty.call(r,e)&&t?r[e]:e}var i=Symbol("isProxy");e.exports=t.default;},529:(e,t)=>{function r(e){e.stopPropagation(),document.body.removeEventListener("click",r,!0);}Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){document.body.addEventListener("click",r,!0);},e.exports=t.default;},779:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var r=(window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(e,t){return setTimeout(e,1e3/60)}).bind(window);t.default=r,e.exports=t.default;},457:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(){var e=document.createElement("div");e.innerHTML='<audio x-webkit-airplay="deny"></audio>';var t=e.children.item(0);t.src="data:audio/mpeg;base64,//uQxAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAACAAACcQCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA//////////////////////////////////////////////////////////////////8AAABhTEFNRTMuMTAwA8MAAAAAAAAAABQgJAUHQQAB9AAAAnGMHkkIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//sQxAADgnABGiAAQBCqgCRMAAgEAH///////////////7+n/9FTuQsQH//////2NG0jWUGlio5gLQTOtIoeR2WX////X4s9Atb/JRVCbBUpeRUq//////////////////9RUi0f2jn/+xDECgPCjAEQAABN4AAANIAAAAQVTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVQ==",t.preload="auto",t.type="audio/mpeg",t.disableRemotePlayback=!0,t.play(),t.remove(),e.remove();},e.exports=t.default;},138:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){return Object.keys(t).forEach((function(r){e.style[r]!==t[r]&&(e.style[r]=t[r]);})),e},e.exports=t.default;},631:(e,t,r)=>{function n(e){return n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},n(e)}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var i=function(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!==n(e)&&"function"!=typeof e)return {default:e};var r=f(t);if(r&&r.has(e))return r.get(e);var i={},a=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var s in e)if("default"!==s&&Object.prototype.hasOwnProperty.call(e,s)){var o=a?Object.getOwnPropertyDescriptor(e,s):null;o&&(o.get||o.set)?Object.defineProperty(i,s,o):i[s]=e[s];}return i.default=e,r&&r.set(e,i),i}(r(241)),a=c(r(646)),s=c(r(379)),o=c(r(743)),u=c(r(227)),l=c(r(328));function c(e){return e&&e.__esModule?e:{default:e}}function f(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,r=new WeakMap;return (f=function(e){return e?r:t})(e)}function h(e,t){return h=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e},h(e,t)}function d(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return !1;if(Reflect.construct.sham)return !1;if("function"==typeof Proxy)return !0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return !1}}();return function(){var r,n=y(e);if(t){var i=y(this).constructor;r=Reflect.construct(n,arguments,i);}else r=n.apply(this,arguments);return p(this,r)}}function p(e,t){if(t&&("object"===n(t)||"function"==typeof t))return t;if(void 0!==t)throw new TypeError("Derived constructors may only return object or undefined");return v(e)}function v(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function y(e){return y=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)},y(e)}function m(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function b(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function g(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n);}}function A(e,t,r){return t&&g(e.prototype,t),r&&g(e,r),Object.defineProperty(e,"prototype",{writable:!1}),e}var k=function(e){!function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,"prototype",{writable:!1}),t&&h(e,t);}(r,e);var t=d(r);function r(e){var n;if(b(this,r),m(v(n=t.call(this)),"defaultParams",{audioContext:null,audioScriptProcessor:null,audioRate:1,autoCenter:!0,autoCenterRate:5,autoCenterImmediately:!1,backend:"WebAudio",backgroundColor:null,barHeight:1,barRadius:0,barGap:null,barMinHeight:null,container:null,cursorColor:"#333",cursorWidth:1,dragSelection:!0,drawingContextAttributes:{desynchronized:!1},duration:null,fillParent:!0,forceDecode:!1,height:128,hideScrollbar:!1,hideCursor:!1,ignoreSilenceMode:!1,interact:!0,loopSelection:!0,maxCanvasWidth:4e3,mediaContainer:null,mediaControls:!1,mediaType:"audio",minPxPerSec:20,normalize:!1,partialRender:!1,pixelRatio:window.devicePixelRatio||screen.deviceXDPI/screen.logicalXDPI,plugins:[],progressColor:"#555",removeMediaElementOnDestroy:!0,renderer:a.default,responsive:!1,rtl:!1,scrollParent:!1,skipLength:2,splitChannels:!1,splitChannelsOptions:{overlay:!1,channelColors:{},filterChannels:[],relativeNormalization:!1},vertical:!1,waveColor:"#999",xhr:{}}),m(v(n),"backends",{MediaElement:o.default,WebAudio:s.default,MediaElementWebAudio:l.default}),m(v(n),"util",i),n.params=Object.assign({},n.defaultParams,e),n.params.splitChannelsOptions=Object.assign({},n.defaultParams.splitChannelsOptions,e.splitChannelsOptions),n.container="string"==typeof e.container?document.querySelector(n.params.container):n.params.container,!n.container)throw new Error("Container element not found");if(null==n.params.mediaContainer?n.mediaContainer=n.container:"string"==typeof n.params.mediaContainer?n.mediaContainer=document.querySelector(n.params.mediaContainer):n.mediaContainer=n.params.mediaContainer,!n.mediaContainer)throw new Error("Media Container element not found");if(n.params.maxCanvasWidth<=1)throw new Error("maxCanvasWidth must be greater than 1");if(n.params.maxCanvasWidth%2==1)throw new Error("maxCanvasWidth must be an even number");if(!0===n.params.rtl&&(!0===n.params.vertical?i.style(n.container,{transform:"rotateX(180deg)"}):i.style(n.container,{transform:"rotateY(180deg)"})),n.params.backgroundColor&&n.setBackgroundColor(n.params.backgroundColor),n.savedVolume=0,n.isMuted=!1,n.tmpEvents=[],n.currentRequest=null,n.arraybuffer=null,n.drawer=null,n.backend=null,n.peakCache=null,"function"!=typeof n.params.renderer)throw new Error("Renderer parameter is invalid");n.Drawer=n.params.renderer,"AudioElement"==n.params.backend&&(n.params.backend="MediaElement"),"WebAudio"!=n.params.backend&&"MediaElementWebAudio"!==n.params.backend||s.default.prototype.supportsWebAudio.call(null)||(n.params.backend="MediaElement"),n.Backend=n.backends[n.params.backend],n.initialisedPluginList={},n.isDestroyed=!1,n.isReady=!1;var u=0;return n._onResize=i.debounce((function(){u==n.drawer.wrapper.clientWidth||n.params.scrollParent||(u=n.drawer.wrapper.clientWidth)&&n.drawer.fireEvent("redraw");}),"number"==typeof n.params.responsive?n.params.responsive:100),p(n,v(n))}return A(r,[{key:"init",value:function(){return this.registerPlugins(this.params.plugins),this.createDrawer(),this.createBackend(),this.createPeakCache(),this}},{key:"registerPlugins",value:function(e){var t=this;return e.forEach((function(e){return t.addPlugin(e)})),e.forEach((function(e){e.deferInit||t.initPlugin(e.name);})),this.fireEvent("plugins-registered",e),this}},{key:"getActivePlugins",value:function(){return this.initialisedPluginList}},{key:"addPlugin",value:function(e){var t=this;if(!e.name)throw new Error("Plugin does not have a name!");if(!e.instance)throw new Error("Plugin ".concat(e.name," does not have an instance property!"));e.staticProps&&Object.keys(e.staticProps).forEach((function(r){t[r]=e.staticProps[r];}));var r=e.instance;return Object.getOwnPropertyNames(i.Observer.prototype).forEach((function(e){r.prototype[e]=i.Observer.prototype[e];})),this[e.name]=new r(e.params||{},this),this.fireEvent("plugin-added",e.name),this}},{key:"initPlugin",value:function(e){if(!this[e])throw new Error("Plugin ".concat(e," has not been added yet!"));return this.initialisedPluginList[e]&&this.destroyPlugin(e),this[e].init(),this.initialisedPluginList[e]=!0,this.fireEvent("plugin-initialised",e),this}},{key:"destroyPlugin",value:function(e){if(!this[e])throw new Error("Plugin ".concat(e," has not been added yet and cannot be destroyed!"));if(!this.initialisedPluginList[e])throw new Error("Plugin ".concat(e," is not active and cannot be destroyed!"));if("function"!=typeof this[e].destroy)throw new Error("Plugin ".concat(e," does not have a destroy function!"));return this[e].destroy(),delete this.initialisedPluginList[e],this.fireEvent("plugin-destroyed",e),this}},{key:"destroyAllPlugins",value:function(){var e=this;Object.keys(this.initialisedPluginList).forEach((function(t){return e.destroyPlugin(t)}));}},{key:"createDrawer",value:function(){var e=this;this.drawer=new this.Drawer(this.container,this.params),this.drawer.init(),this.fireEvent("drawer-created",this.drawer),!1!==this.params.responsive&&(window.addEventListener("resize",this._onResize,!0),window.addEventListener("orientationchange",this._onResize,!0)),this.drawer.on("redraw",(function(){e.drawBuffer(),e.drawer.progress(e.backend.getPlayedPercents());})),this.drawer.on("click",(function(t,r){setTimeout((function(){return e.seekTo(r)}),0);})),this.drawer.on("scroll",(function(t){e.params.partialRender&&e.drawBuffer(),e.fireEvent("scroll",t);}));}},{key:"createBackend",value:function(){var e=this;this.backend&&this.backend.destroy(),this.backend=new this.Backend(this.params),this.backend.init(),this.fireEvent("backend-created",this.backend),this.backend.on("finish",(function(){e.drawer.progress(e.backend.getPlayedPercents()),e.fireEvent("finish");})),this.backend.on("play",(function(){return e.fireEvent("play")})),this.backend.on("pause",(function(){return e.fireEvent("pause")})),this.backend.on("audioprocess",(function(t){e.drawer.progress(e.backend.getPlayedPercents()),e.fireEvent("audioprocess",t);})),"MediaElement"!==this.params.backend&&"MediaElementWebAudio"!==this.params.backend||(this.backend.on("seek",(function(){e.drawer.progress(e.backend.getPlayedPercents());})),this.backend.on("volume",(function(){var t=e.getVolume();e.fireEvent("volume",t),e.backend.isMuted!==e.isMuted&&(e.isMuted=e.backend.isMuted,e.fireEvent("mute",e.isMuted));})));}},{key:"createPeakCache",value:function(){this.params.partialRender&&(this.peakCache=new u.default);}},{key:"getDuration",value:function(){return this.backend.getDuration()}},{key:"getCurrentTime",value:function(){return this.backend.getCurrentTime()}},{key:"setCurrentTime",value:function(e){e>=this.getDuration()?this.seekTo(1):this.seekTo(e/this.getDuration());}},{key:"play",value:function(e,t){var r=this;return this.params.ignoreSilenceMode&&i.ignoreSilenceMode(),this.fireEvent("interaction",(function(){return r.play(e,t)})),this.backend.play(e,t)}},{key:"setPlayEnd",value:function(e){this.backend.setPlayEnd(e);}},{key:"pause",value:function(){if(!this.backend.isPaused())return this.backend.pause()}},{key:"playPause",value:function(){return this.backend.isPaused()?this.play():this.pause()}},{key:"isPlaying",value:function(){return !this.backend.isPaused()}},{key:"skipBackward",value:function(e){this.skip(-e||-this.params.skipLength);}},{key:"skipForward",value:function(e){this.skip(e||this.params.skipLength);}},{key:"skip",value:function(e){var t=this.getDuration()||1,r=this.getCurrentTime()||0;r=Math.max(0,Math.min(t,r+(e||0))),this.seekAndCenter(r/t);}},{key:"seekAndCenter",value:function(e){this.seekTo(e),this.drawer.recenter(e);}},{key:"seekTo",value:function(e){var t=this;if("number"!=typeof e||!isFinite(e)||e<0||e>1)throw new Error("Error calling wavesurfer.seekTo, parameter must be a number between 0 and 1!");this.fireEvent("interaction",(function(){return t.seekTo(e)}));var r="WebAudio"===this.params.backend,n=this.backend.isPaused();r&&!n&&this.backend.pause();var i=this.params.scrollParent;this.params.scrollParent=!1,this.backend.seekTo(e*this.getDuration()),this.drawer.progress(e),r&&!n&&this.backend.play(),this.params.scrollParent=i,this.fireEvent("seek",e);}},{key:"stop",value:function(){this.pause(),this.seekTo(0),this.drawer.progress(0);}},{key:"setSinkId",value:function(e){return this.backend.setSinkId(e)}},{key:"setVolume",value:function(e){this.backend.setVolume(e),this.fireEvent("volume",e);}},{key:"getVolume",value:function(){return this.backend.getVolume()}},{key:"setPlaybackRate",value:function(e){this.backend.setPlaybackRate(e);}},{key:"getPlaybackRate",value:function(){return this.backend.getPlaybackRate()}},{key:"toggleMute",value:function(){this.setMute(!this.isMuted);}},{key:"setMute",value:function(e){e!==this.isMuted?(this.backend.setMute?(this.backend.setMute(e),this.isMuted=e):e?(this.savedVolume=this.backend.getVolume(),this.backend.setVolume(0),this.isMuted=!0,this.fireEvent("volume",0)):(this.backend.setVolume(this.savedVolume),this.isMuted=!1,this.fireEvent("volume",this.savedVolume)),this.fireEvent("mute",this.isMuted)):this.fireEvent("mute",this.isMuted);}},{key:"getMute",value:function(){return this.isMuted}},{key:"getFilters",value:function(){return this.backend.filters||[]}},{key:"toggleScroll",value:function(){this.params.scrollParent=!this.params.scrollParent,this.drawBuffer();}},{key:"toggleInteraction",value:function(){this.params.interact=!this.params.interact;}},{key:"getWaveColor",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;return this.params.splitChannelsOptions.channelColors[e]?this.params.splitChannelsOptions.channelColors[e].waveColor:this.params.waveColor}},{key:"setWaveColor",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;this.params.splitChannelsOptions.channelColors[t]?this.params.splitChannelsOptions.channelColors[t].waveColor=e:this.params.waveColor=e,this.drawBuffer();}},{key:"getProgressColor",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;return this.params.splitChannelsOptions.channelColors[e]?this.params.splitChannelsOptions.channelColors[e].progressColor:this.params.progressColor}},{key:"setProgressColor",value:function(e,t){this.params.splitChannelsOptions.channelColors[t]?this.params.splitChannelsOptions.channelColors[t].progressColor=e:this.params.progressColor=e,this.drawBuffer();}},{key:"getBackgroundColor",value:function(){return this.params.backgroundColor}},{key:"setBackgroundColor",value:function(e){this.params.backgroundColor=e,i.style(this.container,{background:this.params.backgroundColor});}},{key:"getCursorColor",value:function(){return this.params.cursorColor}},{key:"setCursorColor",value:function(e){this.params.cursorColor=e,this.drawer.updateCursor();}},{key:"getHeight",value:function(){return this.params.height}},{key:"setHeight",value:function(e){this.params.height=e,this.drawer.setHeight(e*this.params.pixelRatio),this.drawBuffer();}},{key:"setFilteredChannels",value:function(e){this.params.splitChannelsOptions.filterChannels=e,this.drawBuffer();}},{key:"drawBuffer",value:function(){var e,t=Math.round(this.getDuration()*this.params.minPxPerSec*this.params.pixelRatio),r=this.drawer.getWidth(),n=t,i=0,a=Math.max(i+r,n);if(this.params.fillParent&&(!this.params.scrollParent||t<r)&&(i=0,a=n=r),this.params.partialRender){var s,o=this.peakCache.addRangeToPeakCache(n,i,a);for(s=0;s<o.length;s++)e=this.backend.getPeaks(n,o[s][0],o[s][1]),this.drawer.drawPeaks(e,n,o[s][0],o[s][1]);}else e=this.backend.getPeaks(n,i,a),this.drawer.drawPeaks(e,n,i,a);this.fireEvent("redraw",e,n);}},{key:"zoom",value:function(e){e?(this.params.minPxPerSec=e,this.params.scrollParent=!0):(this.params.minPxPerSec=this.defaultParams.minPxPerSec,this.params.scrollParent=!1),this.drawBuffer(),this.drawer.progress(this.backend.getPlayedPercents()),this.drawer.recenter(this.getCurrentTime()/this.getDuration()),this.fireEvent("zoom",e);}},{key:"loadArrayBuffer",value:function(e){var t=this;this.decodeArrayBuffer(e,(function(e){t.isDestroyed||t.loadDecodedBuffer(e);}));}},{key:"loadDecodedBuffer",value:function(e){this.backend.load(e),this.drawBuffer(),this.isReady=!0,this.fireEvent("ready");}},{key:"loadBlob",value:function(e){var t=this,r=new FileReader;r.addEventListener("progress",(function(e){return t.onProgress(e)})),r.addEventListener("load",(function(e){return t.loadArrayBuffer(e.target.result)})),r.addEventListener("error",(function(){return t.fireEvent("error","Error reading file")})),r.readAsArrayBuffer(e),this.empty();}},{key:"load",value:function(e,t,r,n){if(!e)throw new Error("url parameter cannot be empty");if(this.empty(),r){var i={"Preload is not 'auto', 'none' or 'metadata'":-1===["auto","metadata","none"].indexOf(r),"Peaks are not provided":!t,"Backend is not of type 'MediaElement' or 'MediaElementWebAudio'":-1===["MediaElement","MediaElementWebAudio"].indexOf(this.params.backend),"Url is not of type string":"string"!=typeof e},a=Object.keys(i).filter((function(e){return i[e]}));a.length&&(console.warn("Preload parameter of wavesurfer.load will be ignored because:\n\t- "+a.join("\n\t- ")),r=null);}switch("WebAudio"===this.params.backend&&e instanceof HTMLMediaElement&&(e=e.src),this.params.backend){case"WebAudio":return this.loadBuffer(e,t,n);case"MediaElement":case"MediaElementWebAudio":return this.loadMediaElement(e,t,r,n)}}},{key:"loadBuffer",value:function(e,t,r){var n=this,i=function(t){return t&&n.tmpEvents.push(n.once("ready",t)),n.getArrayBuffer(e,(function(e){return n.loadArrayBuffer(e)}))};if(!t)return i();this.backend.setPeaks(t,r),this.drawBuffer(),this.fireEvent("waveform-ready"),this.tmpEvents.push(this.once("interaction",i));}},{key:"loadMediaElement",value:function(e,t,r,n){var i=this,a=e;if("string"==typeof e)this.backend.load(a,this.mediaContainer,t,r);else {var s=e;this.backend.loadElt(s,t),a=s.src;}this.tmpEvents.push(this.backend.once("canplay",(function(){i.backend.destroyed||(i.drawBuffer(),i.isReady=!0,i.fireEvent("ready"));})),this.backend.once("error",(function(e){return i.fireEvent("error",e)}))),t&&(this.backend.setPeaks(t,n),this.drawBuffer(),this.fireEvent("waveform-ready")),t&&!this.params.forceDecode||!this.backend.supportsWebAudio()||this.getArrayBuffer(a,(function(e){i.decodeArrayBuffer(e,(function(e){i.backend.buffer=e,i.backend.setPeaks(null),i.drawBuffer(),i.fireEvent("waveform-ready");}));}));}},{key:"decodeArrayBuffer",value:function(e,t){var r=this;this.isDestroyed||(this.arraybuffer=e,this.backend.decodeArrayBuffer(e,(function(n){r.isDestroyed||r.arraybuffer!=e||(t(n),r.arraybuffer=null);}),(function(){return r.fireEvent("error","Error decoding audiobuffer")})));}},{key:"getArrayBuffer",value:function(e,t){var r=this,n=Object.assign({url:e,responseType:"arraybuffer"},this.params.xhr),a=i.fetchFile(n);return this.currentRequest=a,this.tmpEvents.push(a.on("progress",(function(e){r.onProgress(e);})),a.on("success",(function(e){t(e),r.currentRequest=null;})),a.on("error",(function(e){r.fireEvent("error",e),r.currentRequest=null;}))),a}},{key:"onProgress",value:function(e){var t;t=e.lengthComputable?e.loaded/e.total:e.loaded/(e.loaded+1e6),this.fireEvent("loading",Math.round(100*t),e.target);}},{key:"exportPCM",value:function(e,t,r,n,i){e=e||1024,n=n||0,t=t||1e4,r=r||!1;var a=this.backend.getPeaks(e,n,i),s=[].map.call(a,(function(e){return Math.round(e*t)/t}));return new Promise((function(e,t){if(!r){var n=new Blob([JSON.stringify(s)],{type:"application/json;charset=utf-8"}),i=URL.createObjectURL(n);window.open(i),URL.revokeObjectURL(i);}e(s);}))}},{key:"exportImage",value:function(e,t,r){return e||(e="image/png"),t||(t=1),r||(r="dataURL"),this.drawer.getImage(e,t,r)}},{key:"cancelAjax",value:function(){this.currentRequest&&this.currentRequest.controller&&(this.currentRequest._reader&&this.currentRequest._reader.cancel().catch((function(e){})),this.currentRequest.controller.abort(),this.currentRequest=null);}},{key:"clearTmpEvents",value:function(){this.tmpEvents.forEach((function(e){return e.un()}));}},{key:"empty",value:function(){this.backend.isPaused()||(this.stop(),this.backend.disconnectSource()),this.isReady=!1,this.cancelAjax(),this.clearTmpEvents(),this.drawer.progress(0),this.drawer.setWidth(0),this.drawer.drawPeaks({length:this.drawer.getWidth()},0);}},{key:"destroy",value:function(){this.destroyAllPlugins(),this.fireEvent("destroy"),this.cancelAjax(),this.clearTmpEvents(),this.unAll(),!1!==this.params.responsive&&(window.removeEventListener("resize",this._onResize,!0),window.removeEventListener("orientationchange",this._onResize,!0)),this.backend&&(this.backend.destroy(),this.backend=null),this.drawer&&this.drawer.destroy(),this.isDestroyed=!0,this.isReady=!1,this.arraybuffer=null;}}],[{key:"create",value:function(e){return new r(e).init()}}]),r}(i.Observer);t.default=k,m(k,"VERSION","6.1.0"),m(k,"util",i),e.exports=t.default;},379:(e,t,r)=>{function n(e){return n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},n(e)}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var i=function(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!==n(e)&&"function"!=typeof e)return {default:e};var r=a(t);if(r&&r.has(e))return r.get(e);var i={},s=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in e)if("default"!==o&&Object.prototype.hasOwnProperty.call(e,o)){var u=s?Object.getOwnPropertyDescriptor(e,o):null;u&&(u.get||u.set)?Object.defineProperty(i,o,u):i[o]=e[o];}return i.default=e,r&&r.set(e,i),i}(r(241));function a(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,r=new WeakMap;return (a=function(e){return e?r:t})(e)}function s(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n);}}function o(e,t){return o=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e},o(e,t)}function u(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return !1;if(Reflect.construct.sham)return !1;if("function"==typeof Proxy)return !0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return !1}}();return function(){var r,n=f(e);if(t){var i=f(this).constructor;r=Reflect.construct(n,arguments,i);}else r=n.apply(this,arguments);return l(this,r)}}function l(e,t){if(t&&("object"===n(t)||"function"==typeof t))return t;if(void 0!==t)throw new TypeError("Derived constructors may only return object or undefined");return c(e)}function c(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function f(e){return f=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)},f(e)}function h(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}var d="playing",p="paused",v="finished",y=function(e){!function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),Object.defineProperty(e,"prototype",{writable:!1}),t&&o(e,t);}(a,e);var t,r,i=u(a);function a(e){var t,r,n;return function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,a),h(c(n=i.call(this)),"audioContext",null),h(c(n),"offlineAudioContext",null),h(c(n),"stateBehaviors",(h(t={},d,{init:function(){this.addOnAudioProcess();},getPlayedPercents:function(){var e=this.getDuration();return this.getCurrentTime()/e||0},getCurrentTime:function(){return this.startPosition+this.getPlayedTime()}}),h(t,p,{init:function(){this.removeOnAudioProcess();},getPlayedPercents:function(){var e=this.getDuration();return this.getCurrentTime()/e||0},getCurrentTime:function(){return this.startPosition}}),h(t,v,{init:function(){this.removeOnAudioProcess(),this.fireEvent("finish");},getPlayedPercents:function(){return 1},getCurrentTime:function(){return this.getDuration()}}),t)),n.params=e,n.ac=e.audioContext||(n.supportsWebAudio()?n.getAudioContext():{}),n.lastPlay=n.ac.currentTime,n.startPosition=0,n.scheduledPause=null,n.states=(h(r={},d,Object.create(n.stateBehaviors.playing)),h(r,p,Object.create(n.stateBehaviors.paused)),h(r,v,Object.create(n.stateBehaviors.finished)),r),n.buffer=null,n.filters=[],n.gainNode=null,n.mergedPeaks=null,n.offlineAc=null,n.peaks=null,n.playbackRate=1,n.analyser=null,n.scriptNode=null,n.source=null,n.splitPeaks=[],n.state=null,n.explicitDuration=e.duration,n.sinkStreamDestination=null,n.sinkAudioElement=null,n.destroyed=!1,n}return t=a,r=[{key:"supportsWebAudio",value:function(){return !(!window.AudioContext&&!window.webkitAudioContext)}},{key:"getAudioContext",value:function(){return window.WaveSurferAudioContext||(window.WaveSurferAudioContext=new(window.AudioContext||window.webkitAudioContext)),window.WaveSurferAudioContext}},{key:"getOfflineAudioContext",value:function(e){return window.WaveSurferOfflineAudioContext||(window.WaveSurferOfflineAudioContext=new(window.OfflineAudioContext||window.webkitOfflineAudioContext)(1,2,e)),window.WaveSurferOfflineAudioContext}},{key:"init",value:function(){this.createVolumeNode(),this.createScriptNode(),this.createAnalyserNode(),this.setState(p),this.setPlaybackRate(this.params.audioRate),this.setLength(0);}},{key:"disconnectFilters",value:function(){this.filters&&(this.filters.forEach((function(e){e&&e.disconnect();})),this.filters=null,this.analyser.connect(this.gainNode));}},{key:"setState",value:function(e){this.state!==this.states[e]&&(this.state=this.states[e],this.state.init.call(this));}},{key:"setFilter",value:function(){for(var e=arguments.length,t=new Array(e),r=0;r<e;r++)t[r]=arguments[r];this.setFilters(t);}},{key:"setFilters",value:function(e){this.disconnectFilters(),e&&e.length&&(this.filters=e,this.analyser.disconnect(),e.reduce((function(e,t){return e.connect(t),t}),this.analyser).connect(this.gainNode));}},{key:"createScriptNode",value:function(){this.params.audioScriptProcessor?this.scriptNode=this.params.audioScriptProcessor:this.ac.createScriptProcessor?this.scriptNode=this.ac.createScriptProcessor(a.scriptBufferSize):this.scriptNode=this.ac.createJavaScriptNode(a.scriptBufferSize),this.scriptNode.connect(this.ac.destination);}},{key:"addOnAudioProcess",value:function(){var e=this;this.scriptNode.onaudioprocess=function(){var t=e.getCurrentTime();t>=e.getDuration()?(e.setState(v),e.fireEvent("pause")):t>=e.scheduledPause?e.pause():e.state===e.states.playing&&e.fireEvent("audioprocess",t);};}},{key:"removeOnAudioProcess",value:function(){this.scriptNode.onaudioprocess=null;}},{key:"createAnalyserNode",value:function(){this.analyser=this.ac.createAnalyser(),this.analyser.connect(this.gainNode);}},{key:"createVolumeNode",value:function(){this.ac.createGain?this.gainNode=this.ac.createGain():this.gainNode=this.ac.createGainNode(),this.gainNode.connect(this.ac.destination);}},{key:"setSinkId",value:function(e){return e?(this.sinkAudioElement||(this.sinkAudioElement=new window.Audio,this.sinkAudioElement.autoplay=!0),this.sinkAudioElement.setSinkId?(this.sinkStreamDestination||(this.sinkStreamDestination=this.ac.createMediaStreamDestination()),this.gainNode.disconnect(),this.gainNode.connect(this.sinkStreamDestination),this.sinkAudioElement.srcObject=this.sinkStreamDestination.stream,this.sinkAudioElement.setSinkId(e)):Promise.reject(new Error("setSinkId is not supported in your browser"))):Promise.reject(new Error("Invalid deviceId: "+e))}},{key:"setVolume",value:function(e){this.gainNode.gain.setValueAtTime(e,this.ac.currentTime);}},{key:"getVolume",value:function(){return this.gainNode.gain.value}},{key:"decodeArrayBuffer",value:function(e,t,r){this.offlineAc||(this.offlineAc=this.getOfflineAudioContext(this.ac&&this.ac.sampleRate?this.ac.sampleRate:44100)),"webkitAudioContext"in window?this.offlineAc.decodeAudioData(e,(function(e){return t(e)}),r):this.offlineAc.decodeAudioData(e).then((function(e){return t(e)})).catch((function(e){return r(e)}));}},{key:"setPeaks",value:function(e,t){null!=t&&(this.explicitDuration=t),this.peaks=e;}},{key:"setLength",value:function(e){if(!this.mergedPeaks||e!=2*this.mergedPeaks.length-1+2){this.splitPeaks=[],this.mergedPeaks=[];var t,r=this.buffer?this.buffer.numberOfChannels:1;for(t=0;t<r;t++)this.splitPeaks[t]=[],this.splitPeaks[t][2*(e-1)]=0,this.splitPeaks[t][2*(e-1)+1]=0;this.mergedPeaks[2*(e-1)]=0,this.mergedPeaks[2*(e-1)+1]=0;}}},{key:"getPeaks",value:function(e,t,r){if(this.peaks)return this.peaks;if(!this.buffer)return [];if(t=t||0,r=r||e-1,this.setLength(e),!this.buffer)return this.params.splitChannels?this.splitPeaks:this.mergedPeaks;if(!this.buffer.length){var n=this.createBuffer(1,4096,this.sampleRate);this.buffer=n.buffer;}var i,a=this.buffer.length/e,s=~~(a/10)||1,o=this.buffer.numberOfChannels;for(i=0;i<o;i++){var u=this.splitPeaks[i],l=this.buffer.getChannelData(i),c=void 0;for(c=t;c<=r;c++){var f=~~(c*a),h=~~(f+a),d=l[f],p=d,v=void 0;for(v=f;v<h;v+=s){var y=l[v];y>p&&(p=y),y<d&&(d=y);}u[2*c]=p,u[2*c+1]=d,(0==i||p>this.mergedPeaks[2*c])&&(this.mergedPeaks[2*c]=p),(0==i||d<this.mergedPeaks[2*c+1])&&(this.mergedPeaks[2*c+1]=d);}}return this.params.splitChannels?this.splitPeaks:this.mergedPeaks}},{key:"getPlayedPercents",value:function(){return this.state.getPlayedPercents.call(this)}},{key:"disconnectSource",value:function(){this.source&&this.source.disconnect();}},{key:"destroyWebAudio",value:function(){this.disconnectFilters(),this.disconnectSource(),this.gainNode.disconnect(),this.scriptNode.disconnect(),this.analyser.disconnect(),this.params.closeAudioContext&&("function"==typeof this.ac.close&&"closed"!=this.ac.state&&this.ac.close(),this.ac=null,this.params.audioContext?this.params.audioContext=null:window.WaveSurferAudioContext=null,window.WaveSurferOfflineAudioContext=null),this.sinkStreamDestination&&(this.sinkAudioElement.pause(),this.sinkAudioElement.srcObject=null,this.sinkStreamDestination.disconnect(),this.sinkStreamDestination=null);}},{key:"destroy",value:function(){this.isPaused()||this.pause(),this.unAll(),this.buffer=null,this.destroyed=!0,this.destroyWebAudio();}},{key:"load",value:function(e){this.startPosition=0,this.lastPlay=this.ac.currentTime,this.buffer=e,this.createSource();}},{key:"createSource",value:function(){this.disconnectSource(),this.source=this.ac.createBufferSource(),this.source.start=this.source.start||this.source.noteGrainOn,this.source.stop=this.source.stop||this.source.noteOff,this.setPlaybackRate(this.playbackRate),this.source.buffer=this.buffer,this.source.connect(this.analyser);}},{key:"resumeAudioContext",value:function(){"suspended"==this.ac.state&&this.ac.resume&&this.ac.resume();}},{key:"isPaused",value:function(){return this.state!==this.states.playing}},{key:"getDuration",value:function(){return this.explicitDuration?this.explicitDuration:this.buffer?this.buffer.duration:0}},{key:"seekTo",value:function(e,t){if(this.buffer)return this.scheduledPause=null,null==e&&(e=this.getCurrentTime())>=this.getDuration()&&(e=0),null==t&&(t=this.getDuration()),this.startPosition=e,this.lastPlay=this.ac.currentTime,this.state===this.states.finished&&this.setState(p),{start:e,end:t}}},{key:"getPlayedTime",value:function(){return (this.ac.currentTime-this.lastPlay)*this.playbackRate}},{key:"play",value:function(e,t){if(this.buffer){this.createSource();var r=this.seekTo(e,t);e=r.start,t=r.end,this.scheduledPause=t,this.source.start(0,e),this.resumeAudioContext(),this.setState(d),this.fireEvent("play");}}},{key:"pause",value:function(){this.scheduledPause=null,this.startPosition+=this.getPlayedTime();try{this.source&&this.source.stop(0);}catch(e){}this.setState(p),this.fireEvent("pause");}},{key:"getCurrentTime",value:function(){return this.state.getCurrentTime.call(this)}},{key:"getPlaybackRate",value:function(){return this.playbackRate}},{key:"setPlaybackRate",value:function(e){this.playbackRate=e||1,this.source&&this.source.playbackRate.setValueAtTime(this.playbackRate,this.ac.currentTime);}},{key:"setPlayEnd",value:function(e){this.scheduledPause=e;}}],r&&s(t.prototype,r),Object.defineProperty(t,"prototype",{writable:!1}),a}(i.Observer);t.default=y,h(y,"scriptBufferSize",256),e.exports=t.default;},296:e=>{function t(e,t,r){var n,i,a,s,o;function u(){var l=Date.now()-s;l<t&&l>=0?n=setTimeout(u,t-l):(n=null,r||(o=e.apply(a,i),a=i=null));}null==t&&(t=100);var l=function(){a=this,i=arguments,s=Date.now();var l=r&&!n;return n||(n=setTimeout(u,t)),l&&(o=e.apply(a,i),a=i=null),o};return l.clear=function(){n&&(clearTimeout(n),n=null);},l.flush=function(){n&&(o=e.apply(a,i),a=i=null,clearTimeout(n),n=null);},l}t.debounce=t,e.exports=t;}},t={},r=function r(n){var i=t[n];if(void 0!==i)return i.exports;var a=t[n]={exports:{}};return e[n](a,a.exports,r),a.exports}(631),r;var e,t,r;}));

    });

    var WaveSurfer = /*@__PURE__*/getDefaultExportFromCjs(wavesurfer_min);

    let waveformTransitionDuration = Number(getComputedStyle(document.body).getPropertyValue('--waveform-transition-duration').replace('ms', ''));
    let waveSurfer = undefined;
    function getNewWaveSurfer(color) {
        let waveSurfer = WaveSurfer.create({
            container: '#waveform-data',
            waveColor: 'transparent',
            cursorColor: 'transparent',
            progressColor: 'transparent',
            normalize: true,
            responsive: true,
            hideScrollbar: true,
            barWidth: 1,
            barGap: null,
            barMinHeight: 1 / 3
        });
        waveSurfer.setWaveColor(color);
        waveSurfer.setHeight(64);
        return waveSurfer;
    }
    let lastSongSourceFile = '';
    async function setWaveSource(sourceFile, rootDir, duration) {
        if (sourceFile === lastSongSourceFile) {
            return;
        }
        else {
            lastSongSourceFile = sourceFile;
        }
        let peaks = await window.ipc.getPeaks(sourceFile);
        let color = await getAlbumColors(rootDir);
        cssVariablesService.set('waveform-opacity', '0');
        setTimeout(() => {
            if (waveSurfer !== undefined) {
                waveSurfer.empty();
                waveSurfer.destroy();
                waveSurfer.unAll();
                waveSurfer = undefined;
            }
            waveSurfer = getNewWaveSurfer(`hsl(${color.hue},${color.saturation}%,${color.lightnessDark}%)`);
            waveSurfer.load(escapeStringFn(sourceFile), peaks, undefined, duration);
            if (peaks) {
                cssVariablesService.set('waveform-opacity', '1');
            }
            else {
                waveSurfer.on('redraw', () => {
                    cssVariablesService.set('waveform-opacity', '1');
                    waveSurfer.exportPCM(1024, undefined, true, undefined).then(newPeaks => {
                        window.ipc.savePeaks(sourceFile, newPeaks);
                    });
                });
            }
        }, waveformTransitionDuration);
    }

    let songToPlayUrlStore = writable([undefined, { playNow: false }]);
    let currentPlayerTime = writable(undefined);

    function shuffleArrayFn (inputArray) {
        let arrayCopy = [...inputArray].map(item => {
            return {
                randomValue: Math.random(),
                data: item
            };
        });
        arrayCopy.sort((a, b) => {
            return a.randomValue - b.randomValue;
        });
        return arrayCopy.map(item => {
            return item.data;
        });
    }

    async function setNewPlaybackFn (rootDir, playbackSongs, songIdToPlay, { playNow }) {
        let songToPlay = songIdToPlay !== undefined ? playbackSongs.find(song => song.ID === songIdToPlay) : playbackSongs[0];
        if (songToPlay === undefined)
            return;
        let isSongShuffleEnabled = false;
        isSongShuffleEnabledStore.subscribe(_ => (isSongShuffleEnabled = _))();
        if (isSongShuffleEnabled) {
            let shuffledArray = shuffleArrayFn(playbackSongs);
            songToPlay = shuffledArray[0];
            playbackStore.set(shuffledArray);
        }
        else {
            playbackStore.set(playbackSongs);
        }
        playingSongStore.set(songToPlay);
        currentSongDurationStore.set(songToPlay.Duration);
        currentSongProgressStore.set(0);
        setWaveSource(songToPlay.SourceFile, rootDir, songToPlay.Duration);
        albumPlayingDirStore.set(rootDir);
        songToPlayUrlStore.set([songToPlay.SourceFile, { playNow }]);
        triggerScrollToSongEvent.set(songToPlay.ID);
        getAlbumColors(rootDir).then(color => {
            applyColorSchemeFn(color);
        });
    }

    var sortSongsArrayFn = (songs, tag, order) => {
        let songsArrayCopy = [...songs];
        if (['Duration', 'Track', 'Size', 'Sample Rate', 'Rating', 'Disc #', 'BitRate', 'PlayCount'].includes(tag)) {
            if (order === 'asc') {
                songsArrayCopy.sort((a, b) => Number(a[tag] || 0) - Number(b[tag] || 0));
            }
            else {
                songsArrayCopy.sort((a, b) => Number(b[tag] || 0) - Number(a[tag || 0]));
            }
        }
        if (['Artist', 'Comment', 'Composer', 'Extension', 'Genre', 'Title'].includes(tag)) {
            if (order === 'asc') {
                songsArrayCopy.sort((a, b) => String(a[tag]).localeCompare(String(b[tag]), undefined, { numeric: true }));
            }
            else {
                songs = songsArrayCopy.sort((a, b) => String(b[tag]).localeCompare(String(a[tag]), undefined, { numeric: true }));
            }
        }
        if (['Date'].includes(tag)) {
            if (order === 'asc') {
                songsArrayCopy.sort((a, b) => {
                    let dateA = Date.UTC(a.Date_Year, (a.Date_Month | 1) - 1, a.Date_Day | 1);
                    let dateB = Date.UTC(b.Date_Year, (b.Date_Month | 1) - 1, b.Date_Day | 1);
                    return dateA - dateB;
                });
            }
            else {
                songsArrayCopy.sort((a, b) => {
                    let dateA = Date.UTC(a.Date_Year, (a.Date_Month | 1) - 1, a.Date_Day | 1);
                    let dateB = Date.UTC(b.Date_Year, (b.Date_Month | 1) - 1, b.Date_Day | 1);
                    return dateB - dateA;
                });
            }
        }
        return songsArrayCopy;
    };

    /* src/middlewares/PlayerMiddleware.svelte generated by Svelte v3.49.0 */

    function create_fragment$1i(ctx) {
    	const block = {
    		c: noop,
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1i($$self, $$props, $$invalidate) {
    	let $songListStore;
    	let $config;
    	let $selectedAlbumDir;
    	validate_store(songListStore, 'songListStore');
    	component_subscribe($$self, songListStore, $$value => $$invalidate(0, $songListStore = $$value));
    	validate_store(config, 'config');
    	component_subscribe($$self, config, $$value => $$invalidate(1, $config = $$value));
    	validate_store(selectedAlbumDir, 'selectedAlbumDir');
    	component_subscribe($$self, selectedAlbumDir, $$value => $$invalidate(2, $selectedAlbumDir = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PlayerMiddleware', slots, []);
    	let firstGroupByAssign = true;

    	/* 	$: {
        if (firstGroupByAssign === true) {
            firstGroupByAssign = false
        } else {
            getAlbums($selectedGroupByStore, $selectedGroupByValueStore)
        }
    } */
    	// function getAlbums(groupBy: string, groupByValue: string) {
    	// 	getAlbumsIPC(groupBy, groupByValue).then(result => ($albumListStore = result))
    	// }
    	function loadPreviousState() {
    		let lastPlayedSongId = Number(localStorage.getItem('LastPlayedSongId'));
    		let lastPlayedDir = localStorage.getItem('LastPlayedDir');

    		getAlbumSongsFn(lastPlayedDir).then(songs => {
    			if (songs.length === 0) {
    				set_store_value(selectedAlbumDir, $selectedAlbumDir = undefined, $selectedAlbumDir);

    				getAlbumColors(undefined).then(color => {
    					applyColorSchemeFn(color);
    				});

    				return;
    			} else {
    				set_store_value(selectedAlbumDir, $selectedAlbumDir = lastPlayedDir, $selectedAlbumDir);
    			}

    			set_store_value(songListStore, $songListStore = sortSongsArrayFn(songs, $config.userOptions.sortBy, $config.userOptions.sortOrder), $songListStore);
    			setNewPlaybackFn(lastPlayedDir, $songListStore, lastPlayedSongId, { playNow: false });
    			scrollToAlbumFn(lastPlayedDir, 'smooth-scroll');
    		});
    	}

    	onMount(() => {
    		loadPreviousState();
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PlayerMiddleware> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		getAlbumSongsFn,
    		applyColorSchemeFn,
    		getAlbumColorsFn: getAlbumColors,
    		scrollToAlbumFn,
    		setNewPlaybackFn,
    		sortSongsArrayFn,
    		selectedAlbumDir,
    		songListStore,
    		config,
    		firstGroupByAssign,
    		loadPreviousState,
    		$songListStore,
    		$config,
    		$selectedAlbumDir
    	});

    	$$self.$inject_state = $$props => {
    		if ('firstGroupByAssign' in $$props) firstGroupByAssign = $$props.firstGroupByAssign;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [];
    }

    class PlayerMiddleware extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1i, create_fragment$1i, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PlayerMiddleware",
    			options,
    			id: create_fragment$1i.name
    		});
    	}
    }

    let context = writable(undefined);
    let sourceAltAudio = writable(undefined);
    let sourceMainAudio = writable(undefined);
    let equalizer = writable({});
    let selectedEqName = writable(undefined);
    let equalizerProfiles = writable([]);
    let equalizerNameStore = writable('');
    let isEqualizerOn = writable(true);
    let isEqualizerDirty = writable(false);

    /* src/middlewares/EqualizerMiddleware.svelte generated by Svelte v3.49.0 */

    function create_fragment$1h(ctx) {
    	const block = {
    		c: noop,
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1h($$self, $$props, $$invalidate) {
    	let $selectedEqName;
    	let $equalizerProfiles;
    	let $config;
    	let $equalizer;
    	let $context;
    	let $sourceAltAudio;
    	let $sourceMainAudio;
    	validate_store(selectedEqName, 'selectedEqName');
    	component_subscribe($$self, selectedEqName, $$value => $$invalidate(1, $selectedEqName = $$value));
    	validate_store(equalizerProfiles, 'equalizerProfiles');
    	component_subscribe($$self, equalizerProfiles, $$value => $$invalidate(3, $equalizerProfiles = $$value));
    	validate_store(config, 'config');
    	component_subscribe($$self, config, $$value => $$invalidate(4, $config = $$value));
    	validate_store(equalizer, 'equalizer');
    	component_subscribe($$self, equalizer, $$value => $$invalidate(5, $equalizer = $$value));
    	validate_store(context, 'context');
    	component_subscribe($$self, context, $$value => $$invalidate(2, $context = $$value));
    	validate_store(sourceAltAudio, 'sourceAltAudio');
    	component_subscribe($$self, sourceAltAudio, $$value => $$invalidate(6, $sourceAltAudio = $$value));
    	validate_store(sourceMainAudio, 'sourceMainAudio');
    	component_subscribe($$self, sourceMainAudio, $$value => $$invalidate(7, $sourceMainAudio = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('EqualizerMiddleware', slots, []);
    	let equalizerGainValues = [32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384];
    	let isFirstSelectedEqIdChange = true;

    	// Loads the equalizer for both the main and alt audio player.
    	async function loadEqualizer() {
    		return new Promise((resolve, reject) => {
    				let audioNodeMainAudio = undefined;
    				let audioNodeAltAudio = undefined;

    				for (const [index, equalizerGainValue] of equalizerGainValues.entries()) {
    					const biquadFilter = $context.createBiquadFilter();
    					biquadFilter.type = 'peaking';
    					biquadFilter.frequency.value = equalizerGainValue;
    					biquadFilter.gain.value = 0;
    					set_store_value(equalizer, $equalizer[equalizerGainValue] = biquadFilter, $equalizer);

    					// Connects the equalizer filters to the audio node.
    					if (index === 0) {
    						// If the index is 0, then the audio node is opened and ready from source.
    						audioNodeMainAudio = $sourceMainAudio.connect(biquadFilter);

    						audioNodeAltAudio = $sourceAltAudio.connect(biquadFilter);
    					} else if (index === equalizerGainValues.length - 1) {
    						// If the index is the last, then the audio node is closed and ready to be connected to the destination.
    						audioNodeMainAudio = audioNodeMainAudio.connect(biquadFilter);

    						audioNodeMainAudio = audioNodeMainAudio.connect($context.destination);
    						audioNodeAltAudio = audioNodeAltAudio.connect(biquadFilter);
    						audioNodeAltAudio = audioNodeAltAudio.connect($context.destination);
    					} else {
    						// If the index is not 0 or the last, then the audio node is connected to the next filter.
    						audioNodeMainAudio = audioNodeMainAudio.connect(biquadFilter);

    						audioNodeAltAudio = audioNodeAltAudio.connect(biquadFilter);
    					}
    				}

    				resolve();
    			});
    	}

    	function changeEqualizer() {
    		let foundEqualizerProfile = $equalizerProfiles.find(x => x.name === $selectedEqName);

    		if (foundEqualizerProfile) {
    			for (const frequency in foundEqualizerProfile.values) {
    				set_store_value(equalizer, $equalizer[frequency].gain.value = foundEqualizerProfile.values[frequency], $equalizer);
    			}

    			equalizer.set($equalizer);

    			// Save ID to config file
    			window.ipc.saveConfig({
    				userOptions: {
    					equalizerName: foundEqualizerProfile.name
    				}
    			});
    		}
    	}

    	function getAudioFilters() {
    		return new Promise((resolve, reject) => {
    				window.ipc.getEqualizers().then(equalizers => {
    					set_store_value(equalizerProfiles, $equalizerProfiles = equalizers, $equalizerProfiles);
    					let equalizerFound = equalizers.find(x => x.name === $config.userOptions.equalizerName);

    					if (equalizerFound) {
    						set_store_value(equalizerProfiles, $equalizerProfiles = $equalizerProfiles.sort((a, b) => a.name.localeCompare(b.name)), $equalizerProfiles);

    						// Moves the previously used equalizer to the top of the list.
    						let index = $equalizerProfiles.findIndex(x => x.name === equalizerFound.name);

    						$equalizerProfiles.unshift($equalizerProfiles.splice(index, 1)[0]);
    						set_store_value(selectedEqName, $selectedEqName = equalizerFound.name, $selectedEqName);
    					} else {
    						let defaultEqualizerFound = equalizers.find(x => x.name === 'Default');

    						if (defaultEqualizerFound) {
    							set_store_value(selectedEqName, $selectedEqName = defaultEqualizerFound.name, $selectedEqName);
    						}
    					}

    					resolve();
    				});
    			});
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<EqualizerMiddleware> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		context,
    		equalizerProfiles,
    		selectedEqName,
    		sourceMainAudio,
    		sourceAltAudio,
    		equalizer,
    		config,
    		equalizerGainValues,
    		isFirstSelectedEqIdChange,
    		loadEqualizer,
    		changeEqualizer,
    		getAudioFilters,
    		$selectedEqName,
    		$equalizerProfiles,
    		$config,
    		$equalizer,
    		$context,
    		$sourceAltAudio,
    		$sourceMainAudio
    	});

    	$$self.$inject_state = $$props => {
    		if ('equalizerGainValues' in $$props) equalizerGainValues = $$props.equalizerGainValues;
    		if ('isFirstSelectedEqIdChange' in $$props) $$invalidate(0, isFirstSelectedEqIdChange = $$props.isFirstSelectedEqIdChange);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$context*/ 4) {
    			{
    				if ($context !== undefined) {
    					getAudioFilters().then(() => {
    						loadEqualizer().then(() => changeEqualizer());
    					});
    				}
    			}
    		}

    		if ($$self.$$.dirty & /*$selectedEqName, isFirstSelectedEqIdChange*/ 3) {
    			{
    				if ($selectedEqName !== undefined) {
    					if (isFirstSelectedEqIdChange === false) {
    						changeEqualizer();
    					} else {
    						$$invalidate(0, isFirstSelectedEqIdChange = false);
    					}
    				}
    			}
    		}
    	};

    	return [isFirstSelectedEqIdChange, $selectedEqName, $context];
    }

    class EqualizerMiddleware extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1h, create_fragment$1h, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EqualizerMiddleware",
    			options,
    			id: create_fragment$1h.name
    		});
    	}
    }

    function incrementPlayCountFn (id) {
        getDB()
            .songs.where('ID')
            .equals(id)
            .first()
            .then((song) => {
            song.PlayCount = song.PlayCount !== undefined ? song.PlayCount + 1 : 1;
            getDB()
                .songs.put(song)
                .then(() => updateVersionFn());
            // Updates the song list to reflect the new play count changes.
            let songListStoreLocal = undefined;
            songListStore.subscribe(value => (songListStoreLocal = value))();
            let songFound = songListStoreLocal.find(storeSong => storeSong.ID === song.ID);
            if (songFound) {
                songFound.PlayCount = song.PlayCount;
                songListStore.set(songListStoreLocal);
            }
        });
    }

    function findNextValidSongFn (currentSongIndex, songList) {
        // Creates a copy of the playback array.
        let playbackArrayCopy = [...songList];
        // Cuts the array from the index to the end, to find the next enabled song beyond the current song in the playback.
        let cutArray = playbackArrayCopy.splice(currentSongIndex + 1);
        // Finds the first enabled song in the array.
        let nextSong = cutArray.find(song => song.isEnabled !== false);
        return nextSong;
    }

    function hash$3(str) {
      var hash = 5381,
          i    = str.length;

      while(i) {
        hash = (hash * 33) ^ str.charCodeAt(--i);
      }

      /* JavaScript does bitwise operations (like XOR, above) on 32-bit signed
       * integers. Since we want the results to be always positive, convert the
       * signed int to an unsigned by doing an unsigned bitshift. */
      return hash >>> 0;
    }

    var stringHash = hash$3;

    function hash$2(stringToHash, format = 'text') {
        if (stringToHash === undefined) {
            return undefined;
        }
        if (format === 'text') {
            return stringHash(stringToHash).toString(36);
        }
        else {
            return stringHash(stringToHash);
        }
    }

    function success(message) {
        return iziToast.success({
            message,
            messageColor: '#fff',
            backgroundColor: 'var(--color-hl-blue)',
            icon: '',
        });
    }
    function error(message) {
        return iziToast.error({
            message,
            messageColor: '#fff',
            backgroundColor: 'var(--color-hl-2)',
            icon: '',
        });
    }
    var notifyService = {
        error,
        success
    };

    function encodeURLFn (url) {
        if (url === undefined)
            return undefined;
        url = encodeURI(url);
        url = url.replace('#', '%23');
        return url;
    }

    /* src/layouts/AudioPlayer.svelte generated by Svelte v3.49.0 */
    const file$1b = "src/layouts/AudioPlayer.svelte";

    function create_fragment$1g(ctx) {
    	let audio0;
    	let track0;
    	let t;
    	let audio1;
    	let track1;

    	const block = {
    		c: function create() {
    			audio0 = element("audio");
    			track0 = element("track");
    			t = space();
    			audio1 = element("audio");
    			track1 = element("track");
    			attr_dev(track0, "kind", "captions");
    			add_location(track0, file$1b, 224, 1, 10197);
    			attr_dev(audio0, "id", "main");
    			attr_dev(audio0, "class", "svelte-pj0r38");
    			add_location(audio0, file$1b, 223, 0, 10178);
    			attr_dev(track1, "kind", "captions");
    			add_location(track1, file$1b, 228, 1, 10251);
    			attr_dev(audio1, "id", "alt");
    			attr_dev(audio1, "class", "svelte-pj0r38");
    			add_location(audio1, file$1b, 227, 0, 10233);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, audio0, anchor);
    			append_dev(audio0, track0);
    			insert_dev(target, t, anchor);
    			insert_dev(target, audio1, anchor);
    			append_dev(audio1, track1);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(audio0);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(audio1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1g($$self, $$props, $$invalidate) {
    	let $mainAudioElement;
    	let $currentAudioElement;
    	let $altAudioElement;
    	let $playbackStore;
    	let $isPlaybackRepeatEnabledStore;
    	let $isSongRepeatEnabledStore;
    	let $songToPlayUrlStore;
    	let $currentSongProgressStore;
    	let $currentPlayerTime;
    	let $currentSongDurationStore;
    	let $albumPlayingDirStore;
    	let $playingSongStore;
    	let $isPlaying;
    	let $context;
    	let $sourceAltAudio;
    	let $sourceMainAudio;
    	let $isSongShuffleEnabledStore;
    	validate_store(mainAudioElement, 'mainAudioElement');
    	component_subscribe($$self, mainAudioElement, $$value => $$invalidate(1, $mainAudioElement = $$value));
    	validate_store(currentAudioElement, 'currentAudioElement');
    	component_subscribe($$self, currentAudioElement, $$value => $$invalidate(10, $currentAudioElement = $$value));
    	validate_store(altAudioElement, 'altAudioElement');
    	component_subscribe($$self, altAudioElement, $$value => $$invalidate(2, $altAudioElement = $$value));
    	validate_store(playbackStore, 'playbackStore');
    	component_subscribe($$self, playbackStore, $$value => $$invalidate(3, $playbackStore = $$value));
    	validate_store(isPlaybackRepeatEnabledStore, 'isPlaybackRepeatEnabledStore');
    	component_subscribe($$self, isPlaybackRepeatEnabledStore, $$value => $$invalidate(4, $isPlaybackRepeatEnabledStore = $$value));
    	validate_store(isSongRepeatEnabledStore, 'isSongRepeatEnabledStore');
    	component_subscribe($$self, isSongRepeatEnabledStore, $$value => $$invalidate(5, $isSongRepeatEnabledStore = $$value));
    	validate_store(songToPlayUrlStore, 'songToPlayUrlStore');
    	component_subscribe($$self, songToPlayUrlStore, $$value => $$invalidate(6, $songToPlayUrlStore = $$value));
    	validate_store(currentSongProgressStore, 'currentSongProgressStore');
    	component_subscribe($$self, currentSongProgressStore, $$value => $$invalidate(11, $currentSongProgressStore = $$value));
    	validate_store(currentPlayerTime, 'currentPlayerTime');
    	component_subscribe($$self, currentPlayerTime, $$value => $$invalidate(12, $currentPlayerTime = $$value));
    	validate_store(currentSongDurationStore, 'currentSongDurationStore');
    	component_subscribe($$self, currentSongDurationStore, $$value => $$invalidate(13, $currentSongDurationStore = $$value));
    	validate_store(albumPlayingDirStore, 'albumPlayingDirStore');
    	component_subscribe($$self, albumPlayingDirStore, $$value => $$invalidate(14, $albumPlayingDirStore = $$value));
    	validate_store(playingSongStore, 'playingSongStore');
    	component_subscribe($$self, playingSongStore, $$value => $$invalidate(15, $playingSongStore = $$value));
    	validate_store(isPlaying, 'isPlaying');
    	component_subscribe($$self, isPlaying, $$value => $$invalidate(16, $isPlaying = $$value));
    	validate_store(context, 'context');
    	component_subscribe($$self, context, $$value => $$invalidate(7, $context = $$value));
    	validate_store(sourceAltAudio, 'sourceAltAudio');
    	component_subscribe($$self, sourceAltAudio, $$value => $$invalidate(17, $sourceAltAudio = $$value));
    	validate_store(sourceMainAudio, 'sourceMainAudio');
    	component_subscribe($$self, sourceMainAudio, $$value => $$invalidate(18, $sourceMainAudio = $$value));
    	validate_store(isSongShuffleEnabledStore, 'isSongShuffleEnabledStore');
    	component_subscribe($$self, isSongShuffleEnabledStore, $$value => $$invalidate(8, $isSongShuffleEnabledStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('AudioPlayer', slots, []);
    	const smoothTimeMs = 250 / 1000;

    	let audioElements = {
    		main: {
    			domElement: undefined,
    			isPlaying: false,
    			isPreloaded: false,
    			isPreloading: false
    		},
    		alt: {
    			domElement: undefined,
    			isPlaying: false,
    			isPreloaded: false,
    			isPreloading: false
    		}
    	};

    	let isMounted = false;

    	function listenPlaybackChangers() {
    		if (isMounted === false) return;
    		preLoadNextSong($playbackStore.findIndex(song => song.ID === +$currentAudioElement.getAttribute('data-song-id')), $playbackStore);
    	}

    	// Functions
    	function checkIfIsPlaying() {
    		if (audioElements.main.isPlaying === true || audioElements.alt.isPlaying === true) {
    			set_store_value(isPlaying, $isPlaying = true, $isPlaying);
    		} else {
    			set_store_value(isPlaying, $isPlaying = false, $isPlaying);
    		}
    	}

    	function playSong(songUrl, { playNow }) {
    		if (songUrl) {
    			set_store_value(songToPlayUrlStore, $songToPlayUrlStore = undefined, $songToPlayUrlStore);
    			let song = $playbackStore.find(song => song.SourceFile === songUrl);

    			if (song === undefined) {
    				return;
    			}

    			// If the song is disabled, finds the next enabled song to play.
    			if (song.isEnabled === false) {
    				// Gets the current song index in the playlist.
    				let currentSongIndex = $playbackStore.findIndex(song => song.SourceFile === songUrl);

    				let nextSong = findNextValidSongFn(currentSongIndex, $playbackStore);

    				if (nextSong !== undefined) {
    					// If an enabled song is found, play it.
    					return playSong(nextSong.SourceFile, { playNow });
    				} else {
    					// If no enabled songs found, notify the user.
    					return notifyService.error('No enabled songs found');
    				}
    			}

    			updateCurrentSongData(song);
    			setCurrentAudioElement($mainAudioElement);

    			// Sets the new song to play.
    			$mainAudioElement.setAttribute('data-song-id', String(hash$2(songUrl, 'number')));

    			set_store_value(mainAudioElement, $mainAudioElement.src = encodeURLFn(songUrl), $mainAudioElement);

    			// Stops the next audio element from playing.
    			$altAudioElement.setAttribute('data-song-id', '');

    			set_store_value(altAudioElement, $altAudioElement.src = '', $altAudioElement);

    			if (playNow) {
    				// Starts playing the song.
    				$mainAudioElement.play().catch(error => {
    					
    				});

    				$$invalidate(0, audioElements.main.isPlaying = true, audioElements);
    				$$invalidate(0, audioElements.main.isPreloaded = true, audioElements);
    				$$invalidate(0, audioElements.main.isPreloading = false, audioElements);
    				$$invalidate(0, audioElements.alt.isPlaying = false, audioElements);
    				$$invalidate(0, audioElements.alt.isPreloaded = false, audioElements);
    				$$invalidate(0, audioElements.alt.isPreloading = false, audioElements);
    			}
    		}
    	}

    	function updateCurrentSongData(song) {
    		set_store_value(playingSongStore, $playingSongStore = song, $playingSongStore);
    		setWaveSource(song.SourceFile, $albumPlayingDirStore, song.Duration);
    		localStorage.setItem('LastPlayedSongId', String(song.ID));
    		localStorage.setItem('LastPlayedDir', String(getDirectoryFn(song.SourceFile)));
    	}

    	function setCurrentAudioElement(audioElement) {
    		set_store_value(currentAudioElement, $currentAudioElement = audioElement, $currentAudioElement);
    		$currentAudioElement.addEventListener('timeupdate', handleTimeUpdate);
    	}

    	function handleTimeUpdate() {
    		// Alt audio name refers to the current alternative player.
    		// If the main audio player is the current one then, the alt audio player is the next one.
    		// If the alt audio player is the current one then, the main audio player is the next one.
    		let altAudioName = this.id === 'main' ? 'alt' : 'main';

    		const currentTime = this.currentTime; /* in seconds */
    		const duration = this.duration; /* in seconds */
    		set_store_value(currentSongDurationStore, $currentSongDurationStore = duration, $currentSongDurationStore);
    		set_store_value(currentSongProgressStore, $currentSongProgressStore = currentTime, $currentSongProgressStore);

    		// Update time only if the current audio element is playing.
    		if (audioElements[this.id].isPlaying === true) {
    			set_store_value(currentPlayerTime, $currentPlayerTime = currentTime, $currentPlayerTime);
    		}

    		////////// Audio Preloads Here \\\\\\\\\\
    		// If the current time is greater than one second, then the next audio element is preloaded.
    		if (audioElements[altAudioName].isPreloading === false && audioElements[altAudioName].isPreloaded === false) {
    			$$invalidate(0, audioElements[altAudioName].isPreloading = true, audioElements);
    			let currentSongIndex = $playbackStore.findIndex(song => song.ID === +this.getAttribute('data-song-id'));
    			preLoadNextSong(currentSongIndex, $playbackStore);
    		}

    		////////// Audio Pre Plays Here \\\\\\\\\\
    		// If the current alt audio element is not yet playing and the current time is greater than the duration minus the smooth time, then the next song is played.
    		if (audioElements[altAudioName].isPlaying === false && currentTime >= duration - smoothTimeMs) {
    			let song = $playbackStore.find(song => song.ID === +audioElements[altAudioName].domElement.getAttribute('data-song-id'));

    			audioElements[altAudioName].domElement.play().then(() => {
    				set_store_value(currentSongProgressStore, $currentSongProgressStore = 0, $currentSongProgressStore);
    				setCurrentAudioElement(audioElements[altAudioName].domElement);
    				$$invalidate(0, audioElements[altAudioName].isPlaying = true, audioElements);
    				updateCurrentSongData(song);
    			}).catch(err => {
    				let previousPlayedSong = $playbackStore.find(song => song.ID === +audioElements[this.id].domElement.getAttribute('data-song-id'));

    				if (previousPlayedSong) {
    					$$invalidate(0, audioElements[this.id].isPlaying = false, audioElements);
    					set_store_value(songToPlayUrlStore, $songToPlayUrlStore = [previousPlayedSong.SourceFile, { playNow: false }], $songToPlayUrlStore);
    				}
    			});
    		}
    	}

    	function preLoadNextSong(songIndex, songList) {
    		let nextAudioElementId = $currentAudioElement.id === 'main' ? 'alt' : 'main';
    		let nextSongToPlay = undefined;

    		if ($isSongRepeatEnabledStore === true) {
    			// If Song Repeat Enabled
    			nextSongToPlay = songList[songIndex];
    		} else if ($isPlaybackRepeatEnabledStore === true) {
    			// If Playback Repeat Enabled
    			// If there is no more songs in playback list, then the first song in the list is played.
    			nextSongToPlay = findNextValidSongFn(songIndex, songList) || findNextValidSongFn(-1, songList);
    		} else {
    			// Song Repeat Disabled && If Playback Repeat Disabled
    			nextSongToPlay = findNextValidSongFn(songIndex, songList);
    		}

    		audioElements[nextAudioElementId].domElement.setAttribute('data-song-id', (nextSongToPlay === null || nextSongToPlay === void 0
    		? void 0
    		: nextSongToPlay.ID) || '');

    		$$invalidate(
    			0,
    			audioElements[nextAudioElementId].domElement.src = encodeURLFn(nextSongToPlay === null || nextSongToPlay === void 0
    			? void 0
    			: nextSongToPlay.SourceFile) || '',
    			audioElements
    		);
    	}

    	function hookEventListeners() {
    		$mainAudioElement.addEventListener('pause', () => {
    			$$invalidate(0, audioElements.main.isPlaying = false, audioElements);
    		});

    		$mainAudioElement.addEventListener('play', () => {
    			$$invalidate(0, audioElements.main.isPlaying = true, audioElements);
    		});

    		$altAudioElement.addEventListener('pause', () => {
    			$$invalidate(0, audioElements.alt.isPlaying = false, audioElements);
    		});

    		$altAudioElement.addEventListener('play', () => {
    			$$invalidate(0, audioElements.alt.isPlaying = true, audioElements);
    		});

    		$mainAudioElement.addEventListener('ended', () => {
    			incrementPlayCountFn($playbackStore.find(song => song.ID === +audioElements.main.domElement.getAttribute('data-song-id')).ID);
    			$$invalidate(0, audioElements.main.isPlaying = false, audioElements);
    			$$invalidate(0, audioElements.main.isPreloaded = false, audioElements);
    			$$invalidate(0, audioElements.main.isPreloading = false, audioElements);
    		});

    		$altAudioElement.addEventListener('ended', () => {
    			incrementPlayCountFn($playbackStore.find(song => song.ID === +audioElements.alt.domElement.getAttribute('data-song-id')).ID);
    			$$invalidate(0, audioElements.alt.isPlaying = false, audioElements);
    			$$invalidate(0, audioElements.alt.isPreloaded = false, audioElements);
    			$$invalidate(0, audioElements.alt.isPreloading = false, audioElements);
    		});

    		$mainAudioElement.addEventListener('canplaythrough', e => {
    			$$invalidate(0, audioElements.main.isPreloaded = true, audioElements);
    			$$invalidate(0, audioElements.main.isPreloading = false, audioElements);
    		});

    		$altAudioElement.addEventListener('canplaythrough', e => {
    			$$invalidate(0, audioElements.alt.isPreloaded = true, audioElements);
    			$$invalidate(0, audioElements.alt.isPreloading = false, audioElements);
    		});
    	}

    	onMount(() => {
    		set_store_value(mainAudioElement, $mainAudioElement = document.querySelector('audio#main'), $mainAudioElement);
    		set_store_value(altAudioElement, $altAudioElement = document.querySelector('audio#alt'), $altAudioElement);
    		$$invalidate(0, audioElements.main.domElement = $mainAudioElement, audioElements);
    		$$invalidate(0, audioElements.alt.domElement = $altAudioElement, audioElements);
    		set_store_value(currentAudioElement, $currentAudioElement = $mainAudioElement, $currentAudioElement);
    		hookEventListeners();
    		isMounted = true;
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AudioPlayer> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		incrementPlayCountFn,
    		findNextValidSongFn,
    		getDirectoryFn,
    		hash: hash$2,
    		notifyService,
    		setWaveSource,
    		context,
    		sourceAltAudio,
    		sourceMainAudio,
    		currentAudioElement,
    		mainAudioElement,
    		altAudioElement,
    		playbackStore,
    		playingSongStore,
    		isPlaying,
    		albumPlayingDirStore,
    		isSongRepeatEnabledStore,
    		isPlaybackRepeatEnabledStore,
    		currentSongDurationStore,
    		currentSongProgressStore,
    		isSongShuffleEnabledStore,
    		currentPlayerTime,
    		songToPlayUrlStore,
    		encodeURLFn,
    		smoothTimeMs,
    		audioElements,
    		isMounted,
    		listenPlaybackChangers,
    		checkIfIsPlaying,
    		playSong,
    		updateCurrentSongData,
    		setCurrentAudioElement,
    		handleTimeUpdate,
    		preLoadNextSong,
    		hookEventListeners,
    		$mainAudioElement,
    		$currentAudioElement,
    		$altAudioElement,
    		$playbackStore,
    		$isPlaybackRepeatEnabledStore,
    		$isSongRepeatEnabledStore,
    		$songToPlayUrlStore,
    		$currentSongProgressStore,
    		$currentPlayerTime,
    		$currentSongDurationStore,
    		$albumPlayingDirStore,
    		$playingSongStore,
    		$isPlaying,
    		$context,
    		$sourceAltAudio,
    		$sourceMainAudio,
    		$isSongShuffleEnabledStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('audioElements' in $$props) $$invalidate(0, audioElements = $$props.audioElements);
    		if ('isMounted' in $$props) isMounted = $$props.isMounted;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$isSongShuffleEnabledStore, $isSongRepeatEnabledStore, $isPlaybackRepeatEnabledStore, $playbackStore*/ 312) {
    			{
    				listenPlaybackChangers();
    			}
    		}

    		if ($$self.$$.dirty & /*$mainAudioElement, $context, $altAudioElement*/ 134) {
    			{
    				if ($mainAudioElement !== undefined && $context === undefined) {
    					set_store_value(context, $context = new window.AudioContext(), $context);

    					// Source for the main audio element.
    					set_store_value(sourceMainAudio, $sourceMainAudio = $context.createMediaElementSource($mainAudioElement), $sourceMainAudio);

    					// Source for the alt audio element.
    					set_store_value(sourceAltAudio, $sourceAltAudio = $context.createMediaElementSource($altAudioElement), $sourceAltAudio);
    				}
    			}
    		}

    		if ($$self.$$.dirty & /*$songToPlayUrlStore*/ 64) {
    			playSong($songToPlayUrlStore[0], $songToPlayUrlStore[1]); /* Song Url to Play */ /* Play now boolean */
    		}

    		if ($$self.$$.dirty & /*audioElements*/ 1) {
    			{
    				if (audioElements) {
    					checkIfIsPlaying();
    				}
    			}
    		}
    	};

    	return [
    		audioElements,
    		$mainAudioElement,
    		$altAudioElement,
    		$playbackStore,
    		$isPlaybackRepeatEnabledStore,
    		$isSongRepeatEnabledStore,
    		$songToPlayUrlStore,
    		$context,
    		$isSongShuffleEnabledStore
    	];
    }

    class AudioPlayer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1g, create_fragment$1g, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AudioPlayer",
    			options,
    			id: create_fragment$1g.name
    		});
    	}
    }

    /* src/icons/CogIcon.svelte generated by Svelte v3.49.0 */

    const file$1a = "src/icons/CogIcon.svelte";

    function create_fragment$1f(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$1a, 6, 2, 154);
    			attr_dev(path1, "d", "M9.954 2.21a9.99 9.99 0 0 1 4.091-.002A3.993 3.993 0 0 0 16 5.07a3.993 3.993 0 0 0 3.457.261A9.99 9.99 0 0 1 21.5 8.876 3.993 3.993 0 0 0 20 12c0 1.264.586 2.391 1.502 3.124a10.043 10.043 0 0 1-2.046 3.543 3.993 3.993 0 0 0-3.456.261 3.993 3.993 0 0 0-1.954 2.86 9.99 9.99 0 0 1-4.091.004A3.993 3.993 0 0 0 8 18.927a3.993 3.993 0 0 0-3.457-.26A9.99 9.99 0 0 1 2.5 15.121 3.993 3.993 0 0 0 4 11.999a3.993 3.993 0 0 0-1.502-3.124 10.043 10.043 0 0 1 2.046-3.543A3.993 3.993 0 0 0 8 5.071a3.993 3.993 0 0 0 1.954-2.86zM12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6z");
    			add_location(path1, file$1a, 6, 40, 192);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "style", /*style*/ ctx[0]);
    			add_location(svg, file$1a, 5, 0, 84);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*style*/ 1) {
    				attr_dev(svg, "style", /*style*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1f($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CogIcon', slots, []);
    	let { style } = $$props;
    	const writable_props = ['style'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CogIcon> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	$$self.$capture_state = () => ({ style });

    	$$self.$inject_state = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [style];
    }

    class CogIcon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1f, create_fragment$1f, safe_not_equal, { style: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CogIcon",
    			options,
    			id: create_fragment$1f.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*style*/ ctx[0] === undefined && !('style' in props)) {
    			console.warn("<CogIcon> was created without expected prop 'style'");
    		}
    	}

    	get style() {
    		throw new Error("<CogIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<CogIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/icons/PlaybackIcon.svelte generated by Svelte v3.49.0 */

    const file$19 = "src/icons/PlaybackIcon.svelte";

    function create_fragment$1e(ctx) {
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M22 18v2H2v-2h20zM2 3.5l8 5-8 5v-10zM22 11v2H12v-2h10zm0-7v2H12V4h10z");
    			add_location(path, file$19, 6, 2, 154);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "style", /*style*/ ctx[0]);
    			add_location(svg, file$19, 5, 0, 84);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*style*/ 1) {
    				attr_dev(svg, "style", /*style*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1e($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PlaybackIcon', slots, []);
    	let { style } = $$props;
    	const writable_props = ['style'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PlaybackIcon> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	$$self.$capture_state = () => ({ style });

    	$$self.$inject_state = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [style];
    }

    class PlaybackIcon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1e, create_fragment$1e, safe_not_equal, { style: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PlaybackIcon",
    			options,
    			id: create_fragment$1e.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*style*/ ctx[0] === undefined && !('style' in props)) {
    			console.warn("<PlaybackIcon> was created without expected prop 'style'");
    		}
    	}

    	get style() {
    		throw new Error("<PlaybackIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<PlaybackIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/icons/PlayListIcon.svelte generated by Svelte v3.49.0 */

    const file$18 = "src/icons/PlayListIcon.svelte";

    function create_fragment$1d(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$18, 6, 2, 154);
    			attr_dev(path1, "d", "M2 18h10v2H2v-2zm0-7h14v2H2v-2zm0-7h20v2H2V4zm17 11.17V9h5v2h-3v7a3 3 0 1 1-2-2.83z");
    			add_location(path1, file$18, 6, 40, 192);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "style", /*style*/ ctx[0]);
    			add_location(svg, file$18, 5, 0, 84);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*style*/ 1) {
    				attr_dev(svg, "style", /*style*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1d($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PlayListIcon', slots, []);
    	let { style } = $$props;
    	const writable_props = ['style'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PlayListIcon> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	$$self.$capture_state = () => ({ style });

    	$$self.$inject_state = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [style];
    }

    class PlayListIcon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1d, create_fragment$1d, safe_not_equal, { style: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PlayListIcon",
    			options,
    			id: create_fragment$1d.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*style*/ ctx[0] === undefined && !('style' in props)) {
    			console.warn("<PlayListIcon> was created without expected prop 'style'");
    		}
    	}

    	get style() {
    		throw new Error("<PlayListIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<PlayListIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/icons/SpeakIcon.svelte generated by Svelte v3.49.0 */

    const file$17 = "src/icons/SpeakIcon.svelte";

    function create_fragment$1c(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$17, 6, 2, 159);
    			attr_dev(path1, "d", "M1 22a8 8 0 1 1 16 0H1zm8-9c-3.315 0-6-2.685-6-6s2.685-6 6-6 6 2.685 6 6-2.685 6-6 6zm9.246-9.816A9.97 9.97 0 0 1 19 7a9.97 9.97 0 0 1-.754 3.816l-1.677-1.22A7.99 7.99 0 0 0 17 7a7.99 7.99 0 0 0-.43-2.596l1.676-1.22zm3.302-2.4A13.942 13.942 0 0 1 23 7c0 2.233-.523 4.344-1.452 6.216l-1.645-1.196A11.955 11.955 0 0 0 21 7c0-1.792-.393-3.493-1.097-5.02L21.548.784z");
    			add_location(path1, file$17, 6, 40, 197);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "style", /*style*/ ctx[0]);
    			add_location(svg, file$17, 5, 0, 89);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*style*/ 1) {
    				attr_dev(svg, "style", /*style*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1c($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SpeakIcon', slots, []);
    	let { style = '' } = $$props;
    	const writable_props = ['style'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SpeakIcon> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	$$self.$capture_state = () => ({ style });

    	$$self.$inject_state = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [style];
    }

    class SpeakIcon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1c, create_fragment$1c, safe_not_equal, { style: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SpeakIcon",
    			options,
    			id: create_fragment$1c.name
    		});
    	}

    	get style() {
    		throw new Error("<SpeakIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<SpeakIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/layouts/Navigation.svelte generated by Svelte v3.49.0 */
    const file$16 = "src/layouts/Navigation.svelte";

    function create_fragment$1b(ctx) {
    	let navigation_svlt;
    	let nav_button0;
    	let playlisticon;
    	let t0;
    	let nav_button1;
    	let playbackicon;
    	let t1;
    	let nav_button2;
    	let speakicon;
    	let t2;
    	let separator;
    	let t3;
    	let nav_button3;
    	let cogicon;
    	let current;
    	let mounted;
    	let dispose;

    	playlisticon = new PlayListIcon({
    			props: {
    				style: "" + ((/*$layoutToShow*/ ctx[0] === 'Library'
    				? `fill:hsl(var(--art-hue), var(--art-saturation), 80%);`
    				: 'fill:hsl(var(--art-hue), var(--art-saturation), 10%);') + ";height: var(--icon-size);width: var(--icon-size);padding: .5rem;")
    			},
    			$$inline: true
    		});

    	playbackicon = new PlaybackIcon({
    			props: {
    				style: "" + ((/*$layoutToShow*/ ctx[0] === 'Playback'
    				? `fill:hsl(var(--art-hue), var(--art-saturation), 80%);`
    				: 'fill:hsl(var(--art-hue), var(--art-saturation), 10%);') + ";height: var(--icon-size);width: var(--icon-size);padding: .5rem;")
    			},
    			$$inline: true
    		});

    	speakicon = new SpeakIcon({
    			props: {
    				style: "" + ((/*$layoutToShow*/ ctx[0] === 'Lyrics'
    				? `fill:hsl(var(--art-hue), var(--art-saturation), 80%);`
    				: 'fill:hsl(var(--art-hue), var(--art-saturation), 10%);') + ";height: var(--icon-size);width: var(--icon-size);padding: .5rem;")
    			},
    			$$inline: true
    		});

    	cogicon = new CogIcon({
    			props: {
    				style: "" + ((/*$layoutToShow*/ ctx[0] === 'Config'
    				? `fill:hsl(var(--art-hue), var(--art-saturation), 80%);`
    				: 'fill:hsl(var(--art-hue), var(--art-saturation), 10%);') + ";height: var(--icon-size);width: var(--icon-size);padding: .5rem;")
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			navigation_svlt = element("navigation-svlt");
    			nav_button0 = element("nav-button");
    			create_component(playlisticon.$$.fragment);
    			t0 = space();
    			nav_button1 = element("nav-button");
    			create_component(playbackicon.$$.fragment);
    			t1 = space();
    			nav_button2 = element("nav-button");
    			create_component(speakicon.$$.fragment);
    			t2 = space();
    			separator = element("separator");
    			t3 = space();
    			nav_button3 = element("nav-button");
    			create_component(cogicon.$$.fragment);
    			set_custom_element_data(nav_button0, "class", "svelte-utche0");
    			add_location(nav_button0, file$16, 8, 1, 332);
    			set_custom_element_data(nav_button1, "class", "svelte-utche0");
    			add_location(nav_button1, file$16, 15, 1, 657);
    			set_custom_element_data(nav_button2, "class", "svelte-utche0");
    			add_location(nav_button2, file$16, 22, 1, 984);
    			add_location(separator, file$16, 29, 1, 1304);
    			set_custom_element_data(nav_button3, "class", "configButton svelte-utche0");
    			add_location(nav_button3, file$16, 30, 1, 1319);
    			set_custom_element_data(navigation_svlt, "class", "dark-theme svelte-utche0");
    			add_location(navigation_svlt, file$16, 7, 0, 294);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, navigation_svlt, anchor);
    			append_dev(navigation_svlt, nav_button0);
    			mount_component(playlisticon, nav_button0, null);
    			append_dev(navigation_svlt, t0);
    			append_dev(navigation_svlt, nav_button1);
    			mount_component(playbackicon, nav_button1, null);
    			append_dev(navigation_svlt, t1);
    			append_dev(navigation_svlt, nav_button2);
    			mount_component(speakicon, nav_button2, null);
    			append_dev(navigation_svlt, t2);
    			append_dev(navigation_svlt, separator);
    			append_dev(navigation_svlt, t3);
    			append_dev(navigation_svlt, nav_button3);
    			mount_component(cogicon, nav_button3, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(nav_button0, "click", /*click_handler*/ ctx[1], false, false, false),
    					listen_dev(nav_button1, "click", /*click_handler_1*/ ctx[2], false, false, false),
    					listen_dev(nav_button2, "click", /*click_handler_2*/ ctx[3], false, false, false),
    					listen_dev(nav_button3, "click", /*click_handler_3*/ ctx[4], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const playlisticon_changes = {};

    			if (dirty & /*$layoutToShow*/ 1) playlisticon_changes.style = "" + ((/*$layoutToShow*/ ctx[0] === 'Library'
    			? `fill:hsl(var(--art-hue), var(--art-saturation), 80%);`
    			: 'fill:hsl(var(--art-hue), var(--art-saturation), 10%);') + ";height: var(--icon-size);width: var(--icon-size);padding: .5rem;");

    			playlisticon.$set(playlisticon_changes);
    			const playbackicon_changes = {};

    			if (dirty & /*$layoutToShow*/ 1) playbackicon_changes.style = "" + ((/*$layoutToShow*/ ctx[0] === 'Playback'
    			? `fill:hsl(var(--art-hue), var(--art-saturation), 80%);`
    			: 'fill:hsl(var(--art-hue), var(--art-saturation), 10%);') + ";height: var(--icon-size);width: var(--icon-size);padding: .5rem;");

    			playbackicon.$set(playbackicon_changes);
    			const speakicon_changes = {};

    			if (dirty & /*$layoutToShow*/ 1) speakicon_changes.style = "" + ((/*$layoutToShow*/ ctx[0] === 'Lyrics'
    			? `fill:hsl(var(--art-hue), var(--art-saturation), 80%);`
    			: 'fill:hsl(var(--art-hue), var(--art-saturation), 10%);') + ";height: var(--icon-size);width: var(--icon-size);padding: .5rem;");

    			speakicon.$set(speakicon_changes);
    			const cogicon_changes = {};

    			if (dirty & /*$layoutToShow*/ 1) cogicon_changes.style = "" + ((/*$layoutToShow*/ ctx[0] === 'Config'
    			? `fill:hsl(var(--art-hue), var(--art-saturation), 80%);`
    			: 'fill:hsl(var(--art-hue), var(--art-saturation), 10%);') + ";height: var(--icon-size);width: var(--icon-size);padding: .5rem;");

    			cogicon.$set(cogicon_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(playlisticon.$$.fragment, local);
    			transition_in(playbackicon.$$.fragment, local);
    			transition_in(speakicon.$$.fragment, local);
    			transition_in(cogicon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(playlisticon.$$.fragment, local);
    			transition_out(playbackicon.$$.fragment, local);
    			transition_out(speakicon.$$.fragment, local);
    			transition_out(cogicon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(navigation_svlt);
    			destroy_component(playlisticon);
    			destroy_component(playbackicon);
    			destroy_component(speakicon);
    			destroy_component(cogicon);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1b($$self, $$props, $$invalidate) {
    	let $layoutToShow;
    	validate_store(layoutToShow, 'layoutToShow');
    	component_subscribe($$self, layoutToShow, $$value => $$invalidate(0, $layoutToShow = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Navigation', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Navigation> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => set_store_value(layoutToShow, $layoutToShow = 'Library', $layoutToShow);
    	const click_handler_1 = () => set_store_value(layoutToShow, $layoutToShow = 'Playback', $layoutToShow);
    	const click_handler_2 = () => set_store_value(layoutToShow, $layoutToShow = 'Lyrics', $layoutToShow);
    	const click_handler_3 = () => set_store_value(layoutToShow, $layoutToShow = 'Config', $layoutToShow);

    	$$self.$capture_state = () => ({
    		CogIcon,
    		PlaybackIcon,
    		PlayListIcon,
    		SpeakIcon,
    		layoutToShow,
    		$layoutToShow
    	});

    	return [
    		$layoutToShow,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3
    	];
    }

    class Navigation extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1b, create_fragment$1b, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Navigation",
    			options,
    			id: create_fragment$1b.name
    		});
    	}
    }

    let currentAudioElementSubscription$1 = currentAudioElement.subscribe(value => {
        if (value !== undefined) {
            currentAudioElementSubscription$1();
        }
    });
    function nextSongFn () {
        let playbackStoreValue;
        let songPlayingLocal = undefined;
        playbackStore.subscribe(value => (playbackStoreValue = value))();
        playingSongStore.subscribe(value => (songPlayingLocal = value))();
        let currentSongIndex = playbackStoreValue.findIndex(song => song.ID === songPlayingLocal.ID);
        let nextSongIndex = currentSongIndex + 1;
        let nextSong = playbackStoreValue[nextSongIndex];
        if (nextSong === undefined) {
            let currentSong = playbackStoreValue[currentSongIndex];
            currentSongProgressStore.set(0);
            songToPlayUrlStore.set([currentSong.SourceFile, { playNow: false }]);
        }
        else {
            songToPlayUrlStore.set([nextSong.SourceFile, { playNow: true }]);
            triggerScrollToSongEvent.set(nextSong.ID);
        }
    }

    /* src/layouts/components/NextButton.svelte generated by Svelte v3.49.0 */
    const file$15 = "src/layouts/components/NextButton.svelte";

    function create_fragment$1a(ctx) {
    	let svg;
    	let polygon;
    	let rect;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			polygon = svg_element("polygon");
    			rect = svg_element("rect");
    			attr_dev(polygon, "points", "87,48.25 0,4.75 0,91.75 ");
    			add_location(polygon, file$15, 15, 1, 317);
    			attr_dev(rect, "x", "90");
    			attr_dev(rect, "y", "5");
    			attr_dev(rect, "width", "10");
    			attr_dev(rect, "height", "87");
    			add_location(rect, file$15, 16, 1, 364);
    			attr_dev(svg, "class", "player-button");
    			attr_dev(svg, "version", "1.1");
    			attr_dev(svg, "id", "Layer_1");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
    			attr_dev(svg, "x", "0px");
    			attr_dev(svg, "y", "0px");
    			attr_dev(svg, "viewBox", "0 0 100 100");
    			attr_dev(svg, "xml:space", "preserve");
    			add_location(svg, file$15, 3, 0, 83);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, polygon);
    			append_dev(svg, rect);

    			if (!mounted) {
    				dispose = listen_dev(svg, "click", /*click_handler*/ ctx[0], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1a($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('NextButton', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<NextButton> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => nextSongFn();
    	$$self.$capture_state = () => ({ nextSongFn });
    	return [click_handler];
    }

    class NextButton extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1a, create_fragment$1a, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NextButton",
    			options,
    			id: create_fragment$1a.name
    		});
    	}
    }

    let currentAudioElementLocal = undefined;
    let currentAudioElementSubscription = currentAudioElement.subscribe(value => {
        if (value !== undefined) {
            currentAudioElementLocal = value;
            currentAudioElementSubscription();
        }
    });
    function previousSongFn () {
        let playbackStoreValue;
        let songPlayingLocal = undefined;
        playbackStore.subscribe(value => (playbackStoreValue = value))();
        playingSongStore.subscribe(value => (songPlayingLocal = value))();
        let currentSongIndex = playbackStoreValue.findIndex(song => song.ID === songPlayingLocal.ID);
        let previousSongIndex = currentSongIndex - 1;
        let previousSong = playbackStoreValue[previousSongIndex];
        if (previousSong === undefined && currentAudioElementLocal !== undefined) {
            currentAudioElementLocal.currentTime = 0;
        }
        if (previousSong !== undefined && (currentAudioElementLocal === undefined || currentAudioElementLocal.currentTime <= 2)) {
            songToPlayUrlStore.set([previousSong.SourceFile, { playNow: true }]);
        }
        else {
            if (currentAudioElementLocal !== undefined) {
                currentAudioElementLocal.currentTime = 0;
            }
        }
        if (previousSong !== undefined) {
            triggerScrollToSongEvent.set(previousSong.ID);
        }
    }

    /* src/layouts/components/PreviousButton.svelte generated by Svelte v3.49.0 */
    const file$14 = "src/layouts/components/PreviousButton.svelte";

    function create_fragment$19(ctx) {
    	let svg;
    	let polygon;
    	let rect;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			polygon = svg_element("polygon");
    			rect = svg_element("rect");
    			attr_dev(polygon, "points", "13,48.5 100,92 100,5 ");
    			add_location(polygon, file$14, 15, 1, 329);
    			attr_dev(rect, "x", "0");
    			attr_dev(rect, "y", "4.75");
    			attr_dev(rect, "transform", "matrix(-1 -1.224647e-16 1.224647e-16 -1 10 96.5001)");
    			attr_dev(rect, "width", "10");
    			attr_dev(rect, "height", "87");
    			add_location(rect, file$14, 16, 1, 373);
    			attr_dev(svg, "class", "player-button");
    			attr_dev(svg, "version", "1.1");
    			attr_dev(svg, "id", "Layer_1");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
    			attr_dev(svg, "x", "0px");
    			attr_dev(svg, "y", "0px");
    			attr_dev(svg, "viewBox", "0 0 100 100");
    			attr_dev(svg, "xml:space", "preserve");
    			add_location(svg, file$14, 3, 0, 91);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, polygon);
    			append_dev(svg, rect);

    			if (!mounted) {
    				dispose = listen_dev(svg, "click", /*click_handler*/ ctx[0], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$19.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$19($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PreviousButton', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PreviousButton> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => previousSongFn();
    	$$self.$capture_state = () => ({ previousSongFn });
    	return [click_handler];
    }

    class PreviousButton extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$19, create_fragment$19, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PreviousButton",
    			options,
    			id: create_fragment$19.name
    		});
    	}
    }

    /* src/layouts/components/PlayButton.svelte generated by Svelte v3.49.0 */
    const file$13 = "src/layouts/components/PlayButton.svelte";

    function create_fragment$18(ctx) {
    	let play_pause_button;
    	let left_part;
    	let t;
    	let right_part;
    	let play_pause_button_class_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			play_pause_button = element("play-pause-button");
    			left_part = element("left-part");
    			t = space();
    			right_part = element("right-part");
    			set_style(left_part, "background-color", /*customColor*/ ctx[1]);
    			set_custom_element_data(left_part, "class", "svelte-1l6zm1f");
    			add_location(left_part, file$13, 24, 1, 778);
    			set_style(right_part, "background-color", /*customColor*/ ctx[1]);
    			set_custom_element_data(right_part, "class", "svelte-1l6zm1f");
    			add_location(right_part, file$13, 26, 1, 834);
    			set_style(play_pause_button, "height", /*customSize*/ ctx[0]);
    			set_style(play_pause_button, "width", /*customSize*/ ctx[0]);
    			set_custom_element_data(play_pause_button, "class", play_pause_button_class_value = "" + (null_to_empty(/*$isPlaying*/ ctx[2] ? '' : 'playing') + " svelte-1l6zm1f"));
    			add_location(play_pause_button, file$13, 19, 0, 636);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, play_pause_button, anchor);
    			append_dev(play_pause_button, left_part);
    			append_dev(play_pause_button, t);
    			append_dev(play_pause_button, right_part);

    			if (!mounted) {
    				dispose = listen_dev(play_pause_button, "click", /*click_handler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*customColor*/ 2) {
    				set_style(left_part, "background-color", /*customColor*/ ctx[1]);
    			}

    			if (dirty & /*customColor*/ 2) {
    				set_style(right_part, "background-color", /*customColor*/ ctx[1]);
    			}

    			if (dirty & /*customSize*/ 1) {
    				set_style(play_pause_button, "height", /*customSize*/ ctx[0]);
    			}

    			if (dirty & /*customSize*/ 1) {
    				set_style(play_pause_button, "width", /*customSize*/ ctx[0]);
    			}

    			if (dirty & /*$isPlaying*/ 4 && play_pause_button_class_value !== (play_pause_button_class_value = "" + (null_to_empty(/*$isPlaying*/ ctx[2] ? '' : 'playing') + " svelte-1l6zm1f"))) {
    				set_custom_element_data(play_pause_button, "class", play_pause_button_class_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(play_pause_button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$18.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$18($$self, $$props, $$invalidate) {
    	let $playingSongStore;
    	let $songToPlayUrlStore;
    	let $currentAudioElement;
    	let $isPlaying;
    	validate_store(playingSongStore, 'playingSongStore');
    	component_subscribe($$self, playingSongStore, $$value => $$invalidate(5, $playingSongStore = $$value));
    	validate_store(songToPlayUrlStore, 'songToPlayUrlStore');
    	component_subscribe($$self, songToPlayUrlStore, $$value => $$invalidate(6, $songToPlayUrlStore = $$value));
    	validate_store(currentAudioElement, 'currentAudioElement');
    	component_subscribe($$self, currentAudioElement, $$value => $$invalidate(7, $currentAudioElement = $$value));
    	validate_store(isPlaying, 'isPlaying');
    	component_subscribe($$self, isPlaying, $$value => $$invalidate(2, $isPlaying = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PlayButton', slots, []);
    	let { customSize = 'var(--button-size)' } = $$props;
    	let { customColor = 'var(--art-color-dark)' } = $$props;

    	function togglePlay() {
    		if ($isPlaying) {
    			$currentAudioElement.pause();
    		} else {
    			if ($currentAudioElement !== undefined && $currentAudioElement.src !== '') {
    				$currentAudioElement.play();
    			} else {
    				set_store_value(songToPlayUrlStore, $songToPlayUrlStore = [$playingSongStore.SourceFile, { playNow: true }], $songToPlayUrlStore);
    			}
    		}
    	}

    	const writable_props = ['customSize', 'customColor'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PlayButton> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => togglePlay();

    	$$self.$$set = $$props => {
    		if ('customSize' in $$props) $$invalidate(0, customSize = $$props.customSize);
    		if ('customColor' in $$props) $$invalidate(1, customColor = $$props.customColor);
    	};

    	$$self.$capture_state = () => ({
    		isPlaying,
    		currentAudioElement,
    		playingSongStore,
    		songToPlayUrlStore,
    		customSize,
    		customColor,
    		togglePlay,
    		$playingSongStore,
    		$songToPlayUrlStore,
    		$currentAudioElement,
    		$isPlaying
    	});

    	$$self.$inject_state = $$props => {
    		if ('customSize' in $$props) $$invalidate(0, customSize = $$props.customSize);
    		if ('customColor' in $$props) $$invalidate(1, customColor = $$props.customColor);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [customSize, customColor, $isPlaying, togglePlay, click_handler];
    }

    class PlayButton extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$18, create_fragment$18, safe_not_equal, { customSize: 0, customColor: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PlayButton",
    			options,
    			id: create_fragment$18.name
    		});
    	}

    	get customSize() {
    		throw new Error("<PlayButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set customSize(value) {
    		throw new Error("<PlayButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get customColor() {
    		throw new Error("<PlayButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set customColor(value) {
    		throw new Error("<PlayButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/layouts/components/PlayerProgress.svelte generated by Svelte v3.49.0 */

    const file$12 = "src/layouts/components/PlayerProgress.svelte";

    function create_fragment$17(ctx) {
    	let player_progress;
    	let player_gloss;
    	let t0;
    	let player_progress_fill;
    	let t1;
    	let div;

    	const block = {
    		c: function create() {
    			player_progress = element("player-progress");
    			player_gloss = element("player-gloss");
    			t0 = space();
    			player_progress_fill = element("player-progress-fill");
    			t1 = space();
    			div = element("div");
    			set_custom_element_data(player_gloss, "class", "svelte-1ptvmao");
    			add_location(player_gloss, file$12, 98, 1, 3934);
    			set_custom_element_data(player_progress_fill, "class", "svelte-1ptvmao");
    			add_location(player_progress_fill, file$12, 99, 1, 3952);
    			attr_dev(div, "id", "waveform-data");
    			attr_dev(div, "class", "svelte-1ptvmao");
    			add_location(div, file$12, 100, 1, 3978);
    			set_custom_element_data(player_progress, "class", "svelte-1ptvmao");
    			add_location(player_progress, file$12, 97, 0, 3915);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, player_progress, anchor);
    			append_dev(player_progress, player_gloss);
    			append_dev(player_progress, t0);
    			append_dev(player_progress, player_progress_fill);
    			append_dev(player_progress, t1);
    			append_dev(player_progress, div);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(player_progress);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$17.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$17($$self, $$props, $$invalidate) {
    	let $currentAudioElement;
    	let $playingSongStore;
    	let $currentSongProgressStore;
    	let $currentSongDurationStore;
    	let $isPlaying;
    	validate_store(currentAudioElement, 'currentAudioElement');
    	component_subscribe($$self, currentAudioElement, $$value => $$invalidate(8, $currentAudioElement = $$value));
    	validate_store(playingSongStore, 'playingSongStore');
    	component_subscribe($$self, playingSongStore, $$value => $$invalidate(1, $playingSongStore = $$value));
    	validate_store(currentSongProgressStore, 'currentSongProgressStore');
    	component_subscribe($$self, currentSongProgressStore, $$value => $$invalidate(9, $currentSongProgressStore = $$value));
    	validate_store(currentSongDurationStore, 'currentSongDurationStore');
    	component_subscribe($$self, currentSongDurationStore, $$value => $$invalidate(10, $currentSongDurationStore = $$value));
    	validate_store(isPlaying, 'isPlaying');
    	component_subscribe($$self, isPlaying, $$value => $$invalidate(2, $isPlaying = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PlayerProgress', slots, []);
    	let pauseDebounce = undefined;
    	let playerProgressFillElement = undefined;
    	let playerProgressElement = undefined;
    	let isMouseDown = false;
    	let isMouseIn = false;
    	let skipDurationTimeout = undefined;

    	function hookPlayerProgressEvents() {
    		playerProgressElement.addEventListener('mouseenter', () => isMouseIn = true);

    		playerProgressElement.addEventListener('mouseleave', () => {
    			isMouseIn = false;

    			// Resets also mouse down if the user leaves the area while holding the mouse down then comes back with mouse up the event would still trigger.
    			isMouseDown = false;
    		});

    		playerProgressElement.addEventListener('mousedown', () => isMouseDown = true);
    		playerProgressElement.addEventListener('mouseup', () => isMouseDown = false);

    		playerProgressElement.addEventListener('mousemove', evt => {
    			if (isMouseDown && isMouseIn) applyProgressChange(evt);
    		});

    		playerProgressElement.addEventListener('click', evt => applyProgressChange(evt));
    	}

    	function applyProgressChange(evt) {
    		if ($playingSongStore === undefined) return;
    		$currentAudioElement.pause();
    		let playerProgressElementWidth = playerProgressElement.scrollWidth;
    		let selectedPercent = Math.floor(100 / playerProgressElementWidth * evt.offsetX);
    		if (selectedPercent <= 0) selectedPercent = 0;
    		if (selectedPercent >= 100) selectedPercent = 100;
    		let songPercentTimeInSeconds = $currentSongDurationStore / (100 / selectedPercent) || 0;
    		set_store_value(currentSongProgressStore, $currentSongProgressStore = songPercentTimeInSeconds, $currentSongProgressStore);
    		setProgress(songPercentTimeInSeconds, $playingSongStore.Duration);
    		clearTimeout(pauseDebounce);

    		pauseDebounce = setTimeout(
    			() => {
    				set_store_value(currentAudioElement, $currentAudioElement.currentTime = songPercentTimeInSeconds, $currentAudioElement);

    				$currentAudioElement.play().catch(err => {
    					
    				});
    			},
    			500
    		);
    	}

    	function resumeProgress() {
    		$$invalidate(0, playerProgressFillElement.style.animationPlayState = 'running', playerProgressFillElement);
    	}

    	function stopProgress() {
    		$$invalidate(0, playerProgressFillElement.style.animationPlayState = 'paused', playerProgressFillElement);
    	}

    	function setProgress(songProgress, songDuration) {
    		if (songDuration - songProgress <= 0.5) {
    			if (skipDurationTimeout === undefined) {
    				nextSongFn();

    				skipDurationTimeout = setTimeout(
    					() => {
    						skipDurationTimeout = undefined;
    					},
    					2000
    				);
    			}

    			return;
    		}

    		let songProgressInPercent = 100 / (songDuration / songProgress);
    		$$invalidate(0, playerProgressFillElement.style.animationName = 'reset-fill-progress', playerProgressFillElement);
    		$$invalidate(0, playerProgressFillElement.style.animationDuration = `$0s`, playerProgressFillElement);
    		$$invalidate(0, playerProgressFillElement.style.minWidth = `${songProgressInPercent}%`, playerProgressFillElement);

    		setTimeout(
    			() => {
    				let timeLeft = Math.round(songDuration - songProgress);
    				$$invalidate(0, playerProgressFillElement.style.animationDuration = `${timeLeft}s`, playerProgressFillElement);
    				$$invalidate(0, playerProgressFillElement.style.animationName = 'fill-progress', playerProgressFillElement);
    				resumeProgress();
    			},
    			100
    		);
    	}

    	function setProgressFromNewSong(song) {
    		$$invalidate(0, playerProgressFillElement.style.animationDuration = `0ms`, playerProgressFillElement);
    		$$invalidate(0, playerProgressFillElement.style.animationName = 'reset-fill-progress', playerProgressFillElement);
    		setProgress(0, song.Duration);
    	}

    	onMount(() => {
    		$$invalidate(0, playerProgressFillElement = document.querySelector('player-progress player-progress-fill'));
    		playerProgressElement = document.querySelector('player-progress');
    		hookPlayerProgressEvents();
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PlayerProgress> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		nextSongFn,
    		currentAudioElement,
    		currentSongDurationStore,
    		currentSongProgressStore,
    		isPlaying,
    		playingSongStore,
    		pauseDebounce,
    		playerProgressFillElement,
    		playerProgressElement,
    		isMouseDown,
    		isMouseIn,
    		skipDurationTimeout,
    		hookPlayerProgressEvents,
    		applyProgressChange,
    		resumeProgress,
    		stopProgress,
    		setProgress,
    		setProgressFromNewSong,
    		$currentAudioElement,
    		$playingSongStore,
    		$currentSongProgressStore,
    		$currentSongDurationStore,
    		$isPlaying
    	});

    	$$self.$inject_state = $$props => {
    		if ('pauseDebounce' in $$props) pauseDebounce = $$props.pauseDebounce;
    		if ('playerProgressFillElement' in $$props) $$invalidate(0, playerProgressFillElement = $$props.playerProgressFillElement);
    		if ('playerProgressElement' in $$props) playerProgressElement = $$props.playerProgressElement;
    		if ('isMouseDown' in $$props) isMouseDown = $$props.isMouseDown;
    		if ('isMouseIn' in $$props) isMouseIn = $$props.isMouseIn;
    		if ('skipDurationTimeout' in $$props) skipDurationTimeout = $$props.skipDurationTimeout;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*playerProgressFillElement, $isPlaying*/ 5) {
    			{
    				if (playerProgressFillElement !== undefined) {
    					if ($isPlaying) {
    						resumeProgress();
    					} else {
    						stopProgress();
    					}
    				}
    			}
    		}

    		if ($$self.$$.dirty & /*$playingSongStore*/ 2) {
    			{
    				if ($playingSongStore !== undefined) {
    					setProgressFromNewSong($playingSongStore);
    				}
    			}
    		}
    	};

    	return [playerProgressFillElement, $playingSongStore, $isPlaying];
    }

    class PlayerProgress extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$17, create_fragment$17, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PlayerProgress",
    			options,
    			id: create_fragment$17.name
    		});
    	}
    }

    /* src/layouts/components/PlayerVolumeBar.svelte generated by Svelte v3.49.0 */

    const file$11 = "src/layouts/components/PlayerVolumeBar.svelte";

    function create_fragment$16(ctx) {
    	let volume_bar;
    	let input;
    	let input_step_value;
    	let t0;
    	let background;
    	let t1;
    	let volume_thumb;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			volume_bar = element("volume-bar");
    			input = element("input");
    			t0 = space();
    			background = element("background");
    			t1 = space();
    			volume_thumb = element("volume-thumb");
    			volume_thumb.textContent = "0";
    			attr_dev(input, "type", "range");
    			attr_dev(input, "min", "0");
    			attr_dev(input, "max", "1");
    			attr_dev(input, "step", input_step_value = /*$keyPressed*/ ctx[0] === 'Shift' ? '0.05' : '0.01');
    			attr_dev(input, "class", "svelte-m1gmow");
    			add_location(input, file$11, 50, 1, 1966);
    			attr_dev(background, "class", "svelte-m1gmow");
    			add_location(background, file$11, 59, 1, 2112);
    			set_custom_element_data(volume_thumb, "class", "svelte-m1gmow");
    			add_location(volume_thumb, file$11, 60, 1, 2128);
    			set_custom_element_data(volume_bar, "class", "svelte-m1gmow");
    			add_location(volume_bar, file$11, 49, 0, 1952);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, volume_bar, anchor);
    			append_dev(volume_bar, input);
    			append_dev(volume_bar, t0);
    			append_dev(volume_bar, background);
    			append_dev(volume_bar, t1);
    			append_dev(volume_bar, volume_thumb);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", /*input_handler*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$keyPressed*/ 1 && input_step_value !== (input_step_value = /*$keyPressed*/ ctx[0] === 'Shift' ? '0.05' : '0.01')) {
    				attr_dev(input, "step", input_step_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(volume_bar);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$16.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$16($$self, $$props, $$invalidate) {
    	let $altAudioElement;
    	let $mainAudioElement;
    	let $keyPressed;
    	validate_store(altAudioElement, 'altAudioElement');
    	component_subscribe($$self, altAudioElement, $$value => $$invalidate(3, $altAudioElement = $$value));
    	validate_store(mainAudioElement, 'mainAudioElement');
    	component_subscribe($$self, mainAudioElement, $$value => $$invalidate(4, $mainAudioElement = $$value));
    	validate_store(keyPressed, 'keyPressed');
    	component_subscribe($$self, keyPressed, $$value => $$invalidate(0, $keyPressed = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PlayerVolumeBar', slots, []);
    	let hasVolumeFromStorageLoaded = false;
    	let saveVolumeDebounce = undefined;

    	function loadVolumeFromLocalStorage() {
    		let volumeLS = Number(localStorage.getItem('volume') || NaN);

    		if (volumeLS === undefined || isNaN(volumeLS) || volumeLS > 1 || volumeLS < 0) {
    			volumeLS = 0.25;
    			localStorage.setItem('volume', String(volumeLS));
    		}

    		setAudioElementVolume(volumeLS);
    		updateVolumeBarVisual(volumeLS);
    	}

    	function onVolumeInput(evt) {
    		let volumeBarElement = evt.target;
    		let volume = Number(volumeBarElement.value);
    		setAudioElementVolume(volume);
    		updateVolumeBarVisual(volume);
    		clearTimeout(saveVolumeDebounce);

    		saveVolumeDebounce = setTimeout(
    			() => {
    				localStorage.setItem('volume', String(volume));
    			},
    			1000
    		);
    	}

    	function setAudioElementVolume(newVolume) {
    		set_store_value(mainAudioElement, $mainAudioElement.volume = newVolume, $mainAudioElement);
    		set_store_value(altAudioElement, $altAudioElement.volume = newVolume, $altAudioElement);
    	}

    	function updateVolumeBarVisual(newVolume) {
    		let volumeThumbElement = document.querySelector('volume-bar volume-thumb');

    		if (volumeThumbElement === null) {
    			return;
    		}

    		volumeThumbElement.innerHTML = String(Math.round(newVolume * 100));
    		let volumeBarWidth = document.querySelector('volume-bar').clientWidth;

    		if (volumeBarWidth === 0) {
    			setTimeout(
    				() => {
    					updateVolumeBarVisual(newVolume);
    				},
    				250
    			);

    			return;
    		}

    		let volumeThumbWidth = document.querySelector('volume-bar volume-thumb').clientWidth;
    		cssVariablesService.set('volume-level', `${(volumeBarWidth - volumeThumbWidth) * newVolume}px`);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PlayerVolumeBar> was created with unknown prop '${key}'`);
    	});

    	const input_handler = evt => {
    		onVolumeInput(evt);
    	};

    	$$self.$capture_state = () => ({
    		cssVariablesService,
    		keyPressed,
    		mainAudioElement,
    		altAudioElement,
    		hasVolumeFromStorageLoaded,
    		saveVolumeDebounce,
    		loadVolumeFromLocalStorage,
    		onVolumeInput,
    		setAudioElementVolume,
    		updateVolumeBarVisual,
    		$altAudioElement,
    		$mainAudioElement,
    		$keyPressed
    	});

    	$$self.$inject_state = $$props => {
    		if ('hasVolumeFromStorageLoaded' in $$props) $$invalidate(2, hasVolumeFromStorageLoaded = $$props.hasVolumeFromStorageLoaded);
    		if ('saveVolumeDebounce' in $$props) saveVolumeDebounce = $$props.saveVolumeDebounce;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*hasVolumeFromStorageLoaded, $mainAudioElement, $altAudioElement*/ 28) {
    			if (hasVolumeFromStorageLoaded === false && $mainAudioElement !== undefined && $altAudioElement !== undefined) {
    				$$invalidate(2, hasVolumeFromStorageLoaded = true);
    				loadVolumeFromLocalStorage();
    			}
    		}
    	};

    	return [
    		$keyPressed,
    		onVolumeInput,
    		hasVolumeFromStorageLoaded,
    		$altAudioElement,
    		$mainAudioElement,
    		input_handler
    	];
    }

    class PlayerVolumeBar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$16, create_fragment$16, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PlayerVolumeBar",
    			options,
    			id: create_fragment$16.name
    		});
    	}
    }

    function calculateElementArtSizeFn (element, { keepSquare }) {
        let parentElementSize = element.getBoundingClientRect();
        let height = parentElementSize.height;
        let width = parentElementSize.width;
        if (keepSquare) {
            if (height === 0) {
                height = width;
            }
            else if (width === 0) {
                width = height;
            }
        }
        return {
            height,
            width
        };
    }

    function intersectionObserverFn (elementId, intersectionRoot) {
        return new Promise((resolve, reject) => {
            let elementObserver;
            elementObserver = new IntersectionObserver(entries => {
                if (entries[0].isIntersecting === true) {
                    resolve(true);
                    elementObserver.disconnect();
                }
            }, {
                root: document.querySelector(intersectionRoot),
                threshold: 0,
                rootMargin: '200% 0px 200% 0px'
            });
            elementObserver.observe(document.querySelector(`#${CSS.escape(elementId)}`));
        });
    }

    /* src/components/AlbumArt.svelte generated by Svelte v3.49.0 */
    const file$10 = "src/components/AlbumArt.svelte";

    // (38:0) {#key $reloadArts}
    function create_key_block(ctx) {
    	let art_svlt;

    	const block = {
    		c: function create() {
    			art_svlt = element("art-svlt");
    			set_custom_element_data(art_svlt, "id", /*elementId*/ ctx[0]);
    			set_style(art_svlt, "height", /*elementHeight*/ ctx[3] + "px");
    			set_style(art_svlt, "width", /*elementWidth*/ ctx[2] + "px");
    			set_custom_element_data(art_svlt, "class", "svelte-1v223uh");
    			add_location(art_svlt, file$10, 38, 1, 1268);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, art_svlt, anchor);
    			/*art_svlt_binding*/ ctx[7](art_svlt);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*elementId*/ 1) {
    				set_custom_element_data(art_svlt, "id", /*elementId*/ ctx[0]);
    			}

    			if (dirty & /*elementHeight*/ 8) {
    				set_style(art_svlt, "height", /*elementHeight*/ ctx[3] + "px");
    			}

    			if (dirty & /*elementWidth*/ 4) {
    				set_style(art_svlt, "width", /*elementWidth*/ ctx[2] + "px");
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(art_svlt);
    			/*art_svlt_binding*/ ctx[7](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block.name,
    		type: "key",
    		source: "(38:0) {#key $reloadArts}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$15(ctx) {
    	let previous_key = /*$reloadArts*/ ctx[4];
    	let key_block_anchor;
    	let key_block = create_key_block(ctx);

    	const block = {
    		c: function create() {
    			key_block.c();
    			key_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			key_block.m(target, anchor);
    			insert_dev(target, key_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$reloadArts*/ 16 && safe_not_equal(previous_key, previous_key = /*$reloadArts*/ ctx[4])) {
    				key_block.d(1);
    				key_block = create_key_block(ctx);
    				key_block.c();
    				key_block.m(key_block_anchor.parentNode, key_block_anchor);
    			} else {
    				key_block.p(ctx, dirty);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(key_block_anchor);
    			key_block.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$15.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$15($$self, $$props, $$invalidate) {
    	let $reloadArts;
    	validate_store(reloadArts, 'reloadArts');
    	component_subscribe($$self, reloadArts, $$value => $$invalidate(4, $reloadArts = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('AlbumArt', slots, []);
    	let { intersectionRoot = undefined } = $$props;
    	let { imageSourceLocation = '' } = $$props;
    	let elementId = '';
    	let element = undefined;
    	let elementWidth = 0;
    	let elementHeight = 0;

    	function loadArt(artPath, elementId, intersectionRoot, height, width) {
    		let size = height || width;

    		if (intersectionRoot !== undefined) {
    			intersectionObserverFn(elementId, intersectionRoot).then(() => {
    				window.ipc.handleArt(artPath, elementId, size);
    			});
    		} else {
    			window.ipc.handleArt(artPath, elementId, size);
    		}
    	}

    	const writable_props = ['intersectionRoot', 'imageSourceLocation'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AlbumArt> was created with unknown prop '${key}'`);
    	});

    	function art_svlt_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(1, element);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('intersectionRoot' in $$props) $$invalidate(5, intersectionRoot = $$props.intersectionRoot);
    		if ('imageSourceLocation' in $$props) $$invalidate(6, imageSourceLocation = $$props.imageSourceLocation);
    	};

    	$$self.$capture_state = () => ({
    		calculateElementArtSizeFn,
    		generateId,
    		intersectionObserverFn,
    		reloadArts,
    		intersectionRoot,
    		imageSourceLocation,
    		elementId,
    		element,
    		elementWidth,
    		elementHeight,
    		loadArt,
    		$reloadArts
    	});

    	$$self.$inject_state = $$props => {
    		if ('intersectionRoot' in $$props) $$invalidate(5, intersectionRoot = $$props.intersectionRoot);
    		if ('imageSourceLocation' in $$props) $$invalidate(6, imageSourceLocation = $$props.imageSourceLocation);
    		if ('elementId' in $$props) $$invalidate(0, elementId = $$props.elementId);
    		if ('element' in $$props) $$invalidate(1, element = $$props.element);
    		if ('elementWidth' in $$props) $$invalidate(2, elementWidth = $$props.elementWidth);
    		if ('elementHeight' in $$props) $$invalidate(3, elementHeight = $$props.elementHeight);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*imageSourceLocation*/ 64) {
    			{
    				$$invalidate(0, elementId = generateId());
    			}
    		}

    		if ($$self.$$.dirty & /*element, imageSourceLocation, elementId, intersectionRoot, elementHeight, elementWidth*/ 111) {
    			{
    				if (element !== undefined) {
    					let { height, width } = calculateElementArtSizeFn(element.parentElement, { keepSquare: true });
    					$$invalidate(3, elementHeight = height);
    					$$invalidate(2, elementWidth = width);

    					if (imageSourceLocation) {
    						loadArt(imageSourceLocation, elementId, intersectionRoot, elementHeight, elementWidth);
    					}
    				}
    			}
    		}
    	};

    	return [
    		elementId,
    		element,
    		elementWidth,
    		elementHeight,
    		$reloadArts,
    		intersectionRoot,
    		imageSourceLocation,
    		art_svlt_binding
    	];
    }

    class AlbumArt extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$15, create_fragment$15, safe_not_equal, {
    			intersectionRoot: 5,
    			imageSourceLocation: 6
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AlbumArt",
    			options,
    			id: create_fragment$15.name
    		});
    	}

    	get intersectionRoot() {
    		throw new Error("<AlbumArt>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set intersectionRoot(value) {
    		throw new Error("<AlbumArt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get imageSourceLocation() {
    		throw new Error("<AlbumArt>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set imageSourceLocation(value) {
    		throw new Error("<AlbumArt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function parseDuration(duration) {
        if (duration === undefined || isNaN(duration)) {
            return '00:00';
        }
        if (Math.sign(duration) === -1) {
            return '-00:00';
        }
        if (duration >= 60 * 60 * 24) {
            return `${Math.floor(duration / (60 * 60 * 24))}d ` + new Date(duration * 1000).toISOString().substr(11, 8);
        }
        else if (duration >= 60 * 60) {
            return new Date(duration * 1000).toISOString().substr(11, 8);
        }
        else {
            return new Date(duration * 1000).toISOString().substr(14, 5);
        }
    }

    /* src/layouts/ControlBar.svelte generated by Svelte v3.49.0 */
    const file$$ = "src/layouts/ControlBar.svelte";

    function create_fragment$14(ctx) {
    	let control_bar_svlt;
    	let album_art;
    	let albumart;
    	let t0;
    	let player_buttons;
    	let previousbutton;
    	let t1;
    	let playbutton;
    	let t2;
    	let nextbutton;
    	let t3;
    	let playervolumebar;
    	let t4;
    	let song_duration;
    	let t5_value = /*songTime*/ ctx[0].currentTime + "";
    	let t5;
    	let t6;
    	let t7_value = /*songTime*/ ctx[0].duration + "";
    	let t7;
    	let t8;
    	let playerprogress;
    	let t9;
    	let song_time_left;
    	let t10;
    	let t11_value = /*songTime*/ ctx[0].timeLeft + "";
    	let t11;
    	let current;

    	albumart = new AlbumArt({
    			props: {
    				imageSourceLocation: /*$playingSongStore*/ ctx[1]?.SourceFile,
    				intersectionRoot: undefined
    			},
    			$$inline: true
    		});

    	previousbutton = new PreviousButton({ $$inline: true });
    	playbutton = new PlayButton({ $$inline: true });
    	nextbutton = new NextButton({ $$inline: true });
    	playervolumebar = new PlayerVolumeBar({ $$inline: true });
    	playerprogress = new PlayerProgress({ $$inline: true });

    	const block = {
    		c: function create() {
    			control_bar_svlt = element("control-bar-svlt");
    			album_art = element("album-art");
    			create_component(albumart.$$.fragment);
    			t0 = space();
    			player_buttons = element("player-buttons");
    			create_component(previousbutton.$$.fragment);
    			t1 = space();
    			create_component(playbutton.$$.fragment);
    			t2 = space();
    			create_component(nextbutton.$$.fragment);
    			t3 = space();
    			create_component(playervolumebar.$$.fragment);
    			t4 = space();
    			song_duration = element("song-duration");
    			t5 = text(t5_value);
    			t6 = text("/");
    			t7 = text(t7_value);
    			t8 = space();
    			create_component(playerprogress.$$.fragment);
    			t9 = space();
    			song_time_left = element("song-time-left");
    			t10 = text("-");
    			t11 = text(t11_value);
    			set_custom_element_data(album_art, "class", "svelte-3escra");
    			add_location(album_art, file$$, 44, 1, 1666);
    			set_custom_element_data(player_buttons, "class", "svelte-3escra");
    			add_location(player_buttons, file$$, 48, 1, 1790);
    			set_custom_element_data(song_duration, "class", "song-time svelte-3escra");
    			add_location(song_duration, file$$, 56, 1, 1905);
    			set_custom_element_data(song_time_left, "class", "song-time svelte-3escra");
    			add_location(song_time_left, file$$, 62, 1, 2025);
    			set_custom_element_data(control_bar_svlt, "class", "svelte-3escra");
    			add_location(control_bar_svlt, file$$, 43, 0, 1646);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, control_bar_svlt, anchor);
    			append_dev(control_bar_svlt, album_art);
    			mount_component(albumart, album_art, null);
    			append_dev(control_bar_svlt, t0);
    			append_dev(control_bar_svlt, player_buttons);
    			mount_component(previousbutton, player_buttons, null);
    			append_dev(player_buttons, t1);
    			mount_component(playbutton, player_buttons, null);
    			append_dev(player_buttons, t2);
    			mount_component(nextbutton, player_buttons, null);
    			append_dev(control_bar_svlt, t3);
    			mount_component(playervolumebar, control_bar_svlt, null);
    			append_dev(control_bar_svlt, t4);
    			append_dev(control_bar_svlt, song_duration);
    			append_dev(song_duration, t5);
    			append_dev(song_duration, t6);
    			append_dev(song_duration, t7);
    			append_dev(control_bar_svlt, t8);
    			mount_component(playerprogress, control_bar_svlt, null);
    			append_dev(control_bar_svlt, t9);
    			append_dev(control_bar_svlt, song_time_left);
    			append_dev(song_time_left, t10);
    			append_dev(song_time_left, t11);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const albumart_changes = {};
    			if (dirty & /*$playingSongStore*/ 2) albumart_changes.imageSourceLocation = /*$playingSongStore*/ ctx[1]?.SourceFile;
    			albumart.$set(albumart_changes);
    			if ((!current || dirty & /*songTime*/ 1) && t5_value !== (t5_value = /*songTime*/ ctx[0].currentTime + "")) set_data_dev(t5, t5_value);
    			if ((!current || dirty & /*songTime*/ 1) && t7_value !== (t7_value = /*songTime*/ ctx[0].duration + "")) set_data_dev(t7, t7_value);
    			if ((!current || dirty & /*songTime*/ 1) && t11_value !== (t11_value = /*songTime*/ ctx[0].timeLeft + "")) set_data_dev(t11, t11_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(albumart.$$.fragment, local);
    			transition_in(previousbutton.$$.fragment, local);
    			transition_in(playbutton.$$.fragment, local);
    			transition_in(nextbutton.$$.fragment, local);
    			transition_in(playervolumebar.$$.fragment, local);
    			transition_in(playerprogress.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(albumart.$$.fragment, local);
    			transition_out(previousbutton.$$.fragment, local);
    			transition_out(playbutton.$$.fragment, local);
    			transition_out(nextbutton.$$.fragment, local);
    			transition_out(playervolumebar.$$.fragment, local);
    			transition_out(playerprogress.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(control_bar_svlt);
    			destroy_component(albumart);
    			destroy_component(previousbutton);
    			destroy_component(playbutton);
    			destroy_component(nextbutton);
    			destroy_component(playervolumebar);
    			destroy_component(playerprogress);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$14.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$14($$self, $$props, $$invalidate) {
    	let $playingSongStore;
    	let $currentSongProgressStore;
    	let $currentSongDurationStore;
    	validate_store(playingSongStore, 'playingSongStore');
    	component_subscribe($$self, playingSongStore, $$value => $$invalidate(1, $playingSongStore = $$value));
    	validate_store(currentSongProgressStore, 'currentSongProgressStore');
    	component_subscribe($$self, currentSongProgressStore, $$value => $$invalidate(2, $currentSongProgressStore = $$value));
    	validate_store(currentSongDurationStore, 'currentSongDurationStore');
    	component_subscribe($$self, currentSongDurationStore, $$value => $$invalidate(3, $currentSongDurationStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ControlBar', slots, []);
    	let progress = 0;
    	let artSize = 64;
    	let currentSong = undefined;

    	let songTime = {
    		currentTime: '00:00',
    		duration: '00:00',
    		timeLeft: '00:00'
    	};

    	function updateSongTime(songDuration, songProgress) {
    		$$invalidate(0, songTime = {
    			currentTime: parseDuration(songProgress),
    			duration: parseDuration(songDuration),
    			timeLeft: parseDuration(songDuration - songProgress)
    		});
    	}

    	function durationChanged(currentTime) {
    		let duration = $playingSongStore.Duration;

    		// Rounds to 2 decimals.
    		progress = Math.round((100 / duration * currentTime + Number.EPSILON) * 100) / 100;

    		progress = progress >= 100 ? 100 : progress;
    		cssVariablesService.set('song-time', `${progress}%`);

    		$$invalidate(0, songTime = {
    			currentTime: parseDuration(currentTime),
    			duration: parseDuration(duration),
    			timeLeft: parseDuration(duration - currentTime)
    		});
    	}

    	onMount(() => {
    		
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ControlBar> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		NextButton,
    		PreviousButton,
    		PlayButton,
    		PlayerProgress,
    		PlayerVolumeBar,
    		AlbumArt,
    		playingSongStore,
    		currentSongDurationStore,
    		currentSongProgressStore,
    		parseDuration,
    		cssVariablesService,
    		progress,
    		artSize,
    		currentSong,
    		songTime,
    		updateSongTime,
    		durationChanged,
    		$playingSongStore,
    		$currentSongProgressStore,
    		$currentSongDurationStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('progress' in $$props) progress = $$props.progress;
    		if ('artSize' in $$props) artSize = $$props.artSize;
    		if ('currentSong' in $$props) currentSong = $$props.currentSong;
    		if ('songTime' in $$props) $$invalidate(0, songTime = $$props.songTime);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$currentSongDurationStore, $currentSongProgressStore*/ 12) {
    			{
    				updateSongTime($currentSongDurationStore, $currentSongProgressStore);
    			}
    		}
    	};

    	return [
    		songTime,
    		$playingSongStore,
    		$currentSongProgressStore,
    		$currentSongDurationStore
    	];
    }

    class ControlBar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$14, create_fragment$14, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ControlBar",
    			options,
    			id: create_fragment$14.name
    		});
    	}
    }

    var top = 'top';
    var bottom = 'bottom';
    var right = 'right';
    var left = 'left';
    var auto = 'auto';
    var basePlacements = [top, bottom, right, left];
    var start = 'start';
    var end = 'end';
    var clippingParents = 'clippingParents';
    var viewport = 'viewport';
    var popper = 'popper';
    var reference = 'reference';
    var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
      return acc.concat([placement + "-" + start, placement + "-" + end]);
    }, []);
    var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
      return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
    }, []); // modifiers that need to read the DOM

    var beforeRead = 'beforeRead';
    var read = 'read';
    var afterRead = 'afterRead'; // pure-logic modifiers

    var beforeMain = 'beforeMain';
    var main$1 = 'main';
    var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

    var beforeWrite = 'beforeWrite';
    var write = 'write';
    var afterWrite = 'afterWrite';
    var modifierPhases = [beforeRead, read, afterRead, beforeMain, main$1, afterMain, beforeWrite, write, afterWrite];

    function getNodeName(element) {
      return element ? (element.nodeName || '').toLowerCase() : null;
    }

    function getWindow(node) {
      if (node == null) {
        return window;
      }

      if (node.toString() !== '[object Window]') {
        var ownerDocument = node.ownerDocument;
        return ownerDocument ? ownerDocument.defaultView || window : window;
      }

      return node;
    }

    function isElement$1(node) {
      var OwnElement = getWindow(node).Element;
      return node instanceof OwnElement || node instanceof Element;
    }

    function isHTMLElement(node) {
      var OwnElement = getWindow(node).HTMLElement;
      return node instanceof OwnElement || node instanceof HTMLElement;
    }

    function isShadowRoot(node) {
      // IE 11 has no ShadowRoot
      if (typeof ShadowRoot === 'undefined') {
        return false;
      }

      var OwnElement = getWindow(node).ShadowRoot;
      return node instanceof OwnElement || node instanceof ShadowRoot;
    }

    // and applies them to the HTMLElements such as popper and arrow

    function applyStyles(_ref) {
      var state = _ref.state;
      Object.keys(state.elements).forEach(function (name) {
        var style = state.styles[name] || {};
        var attributes = state.attributes[name] || {};
        var element = state.elements[name]; // arrow is optional + virtual elements

        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        } // Flow doesn't support to extend this property, but it's the most
        // effective way to apply styles to an HTMLElement
        // $FlowFixMe[cannot-write]


        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function (name) {
          var value = attributes[name];

          if (value === false) {
            element.removeAttribute(name);
          } else {
            element.setAttribute(name, value === true ? '' : value);
          }
        });
      });
    }

    function effect$2(_ref2) {
      var state = _ref2.state;
      var initialStyles = {
        popper: {
          position: state.options.strategy,
          left: '0',
          top: '0',
          margin: '0'
        },
        arrow: {
          position: 'absolute'
        },
        reference: {}
      };
      Object.assign(state.elements.popper.style, initialStyles.popper);
      state.styles = initialStyles;

      if (state.elements.arrow) {
        Object.assign(state.elements.arrow.style, initialStyles.arrow);
      }

      return function () {
        Object.keys(state.elements).forEach(function (name) {
          var element = state.elements[name];
          var attributes = state.attributes[name] || {};
          var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

          var style = styleProperties.reduce(function (style, property) {
            style[property] = '';
            return style;
          }, {}); // arrow is optional + virtual elements

          if (!isHTMLElement(element) || !getNodeName(element)) {
            return;
          }

          Object.assign(element.style, style);
          Object.keys(attributes).forEach(function (attribute) {
            element.removeAttribute(attribute);
          });
        });
      };
    } // eslint-disable-next-line import/no-unused-modules


    var applyStyles$1 = {
      name: 'applyStyles',
      enabled: true,
      phase: 'write',
      fn: applyStyles,
      effect: effect$2,
      requires: ['computeStyles']
    };

    function getBasePlacement$1(placement) {
      return placement.split('-')[0];
    }

    var max = Math.max;
    var min = Math.min;
    var round = Math.round;

    function getUAString() {
      var uaData = navigator.userAgentData;

      if (uaData != null && uaData.brands) {
        return uaData.brands.map(function (item) {
          return item.brand + "/" + item.version;
        }).join(' ');
      }

      return navigator.userAgent;
    }

    function isLayoutViewport() {
      return !/^((?!chrome|android).)*safari/i.test(getUAString());
    }

    function getBoundingClientRect(element, includeScale, isFixedStrategy) {
      if (includeScale === void 0) {
        includeScale = false;
      }

      if (isFixedStrategy === void 0) {
        isFixedStrategy = false;
      }

      var clientRect = element.getBoundingClientRect();
      var scaleX = 1;
      var scaleY = 1;

      if (includeScale && isHTMLElement(element)) {
        scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
        scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
      }

      var _ref = isElement$1(element) ? getWindow(element) : window,
          visualViewport = _ref.visualViewport;

      var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
      var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
      var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
      var width = clientRect.width / scaleX;
      var height = clientRect.height / scaleY;
      return {
        width: width,
        height: height,
        top: y,
        right: x + width,
        bottom: y + height,
        left: x,
        x: x,
        y: y
      };
    }

    // means it doesn't take into account transforms.

    function getLayoutRect(element) {
      var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.
      // Fixes https://github.com/popperjs/popper-core/issues/1223

      var width = element.offsetWidth;
      var height = element.offsetHeight;

      if (Math.abs(clientRect.width - width) <= 1) {
        width = clientRect.width;
      }

      if (Math.abs(clientRect.height - height) <= 1) {
        height = clientRect.height;
      }

      return {
        x: element.offsetLeft,
        y: element.offsetTop,
        width: width,
        height: height
      };
    }

    function contains(parent, child) {
      var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

      if (parent.contains(child)) {
        return true;
      } // then fallback to custom implementation with Shadow DOM support
      else if (rootNode && isShadowRoot(rootNode)) {
          var next = child;

          do {
            if (next && parent.isSameNode(next)) {
              return true;
            } // $FlowFixMe[prop-missing]: need a better way to handle this...


            next = next.parentNode || next.host;
          } while (next);
        } // Give up, the result is false


      return false;
    }

    function getComputedStyle$1(element) {
      return getWindow(element).getComputedStyle(element);
    }

    function isTableElement(element) {
      return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
    }

    function getDocumentElement(element) {
      // $FlowFixMe[incompatible-return]: assume body is always available
      return ((isElement$1(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]
      element.document) || window.document).documentElement;
    }

    function getParentNode(element) {
      if (getNodeName(element) === 'html') {
        return element;
      }

      return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
        // $FlowFixMe[incompatible-return]
        // $FlowFixMe[prop-missing]
        element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
        element.parentNode || ( // DOM Element detected
        isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
        // $FlowFixMe[incompatible-call]: HTMLElement is a Node
        getDocumentElement(element) // fallback

      );
    }

    function getTrueOffsetParent(element) {
      if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
      getComputedStyle$1(element).position === 'fixed') {
        return null;
      }

      return element.offsetParent;
    } // `.offsetParent` reports `null` for fixed elements, while absolute elements
    // return the containing block


    function getContainingBlock(element) {
      var isFirefox = /firefox/i.test(getUAString());
      var isIE = /Trident/i.test(getUAString());

      if (isIE && isHTMLElement(element)) {
        // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
        var elementCss = getComputedStyle$1(element);

        if (elementCss.position === 'fixed') {
          return null;
        }
      }

      var currentNode = getParentNode(element);

      if (isShadowRoot(currentNode)) {
        currentNode = currentNode.host;
      }

      while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {
        var css = getComputedStyle$1(currentNode); // This is non-exhaustive but covers the most common CSS properties that
        // create a containing block.
        // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

        if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
          return currentNode;
        } else {
          currentNode = currentNode.parentNode;
        }
      }

      return null;
    } // Gets the closest ancestor positioned element. Handles some edge cases,
    // such as table ancestors and cross browser bugs.


    function getOffsetParent(element) {
      var window = getWindow(element);
      var offsetParent = getTrueOffsetParent(element);

      while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {
        offsetParent = getTrueOffsetParent(offsetParent);
      }

      if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static')) {
        return window;
      }

      return offsetParent || getContainingBlock(element) || window;
    }

    function getMainAxisFromPlacement(placement) {
      return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
    }

    function within(min$1, value, max$1) {
      return max(min$1, min(value, max$1));
    }
    function withinMaxClamp(min, value, max) {
      var v = within(min, value, max);
      return v > max ? max : v;
    }

    function getFreshSideObject() {
      return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };
    }

    function mergePaddingObject(paddingObject) {
      return Object.assign({}, getFreshSideObject(), paddingObject);
    }

    function expandToHashMap(value, keys) {
      return keys.reduce(function (hashMap, key) {
        hashMap[key] = value;
        return hashMap;
      }, {});
    }

    var toPaddingObject = function toPaddingObject(padding, state) {
      padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
        placement: state.placement
      })) : padding;
      return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
    };

    function arrow(_ref) {
      var _state$modifiersData$;

      var state = _ref.state,
          name = _ref.name,
          options = _ref.options;
      var arrowElement = state.elements.arrow;
      var popperOffsets = state.modifiersData.popperOffsets;
      var basePlacement = getBasePlacement$1(state.placement);
      var axis = getMainAxisFromPlacement(basePlacement);
      var isVertical = [left, right].indexOf(basePlacement) >= 0;
      var len = isVertical ? 'height' : 'width';

      if (!arrowElement || !popperOffsets) {
        return;
      }

      var paddingObject = toPaddingObject(options.padding, state);
      var arrowRect = getLayoutRect(arrowElement);
      var minProp = axis === 'y' ? top : left;
      var maxProp = axis === 'y' ? bottom : right;
      var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
      var startDiff = popperOffsets[axis] - state.rects.reference[axis];
      var arrowOffsetParent = getOffsetParent(arrowElement);
      var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
      var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
      // outside of the popper bounds

      var min = paddingObject[minProp];
      var max = clientSize - arrowRect[len] - paddingObject[maxProp];
      var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
      var offset = within(min, center, max); // Prevents breaking syntax highlighting...

      var axisProp = axis;
      state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
    }

    function effect$1(_ref2) {
      var state = _ref2.state,
          options = _ref2.options;
      var _options$element = options.element,
          arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;

      if (arrowElement == null) {
        return;
      } // CSS selector


      if (typeof arrowElement === 'string') {
        arrowElement = state.elements.popper.querySelector(arrowElement);

        if (!arrowElement) {
          return;
        }
      }

      if (!contains(state.elements.popper, arrowElement)) {

        return;
      }

      state.elements.arrow = arrowElement;
    } // eslint-disable-next-line import/no-unused-modules


    var arrow$1 = {
      name: 'arrow',
      enabled: true,
      phase: 'main',
      fn: arrow,
      effect: effect$1,
      requires: ['popperOffsets'],
      requiresIfExists: ['preventOverflow']
    };

    function getVariation(placement) {
      return placement.split('-')[1];
    }

    var unsetSides = {
      top: 'auto',
      right: 'auto',
      bottom: 'auto',
      left: 'auto'
    }; // Round the offsets to the nearest suitable subpixel based on the DPR.
    // Zooming can change the DPR, but it seems to report a value that will
    // cleanly divide the values into the appropriate subpixels.

    function roundOffsetsByDPR(_ref) {
      var x = _ref.x,
          y = _ref.y;
      var win = window;
      var dpr = win.devicePixelRatio || 1;
      return {
        x: round(x * dpr) / dpr || 0,
        y: round(y * dpr) / dpr || 0
      };
    }

    function mapToStyles(_ref2) {
      var _Object$assign2;

      var popper = _ref2.popper,
          popperRect = _ref2.popperRect,
          placement = _ref2.placement,
          variation = _ref2.variation,
          offsets = _ref2.offsets,
          position = _ref2.position,
          gpuAcceleration = _ref2.gpuAcceleration,
          adaptive = _ref2.adaptive,
          roundOffsets = _ref2.roundOffsets,
          isFixed = _ref2.isFixed;
      var _offsets$x = offsets.x,
          x = _offsets$x === void 0 ? 0 : _offsets$x,
          _offsets$y = offsets.y,
          y = _offsets$y === void 0 ? 0 : _offsets$y;

      var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
        x: x,
        y: y
      }) : {
        x: x,
        y: y
      };

      x = _ref3.x;
      y = _ref3.y;
      var hasX = offsets.hasOwnProperty('x');
      var hasY = offsets.hasOwnProperty('y');
      var sideX = left;
      var sideY = top;
      var win = window;

      if (adaptive) {
        var offsetParent = getOffsetParent(popper);
        var heightProp = 'clientHeight';
        var widthProp = 'clientWidth';

        if (offsetParent === getWindow(popper)) {
          offsetParent = getDocumentElement(popper);

          if (getComputedStyle$1(offsetParent).position !== 'static' && position === 'absolute') {
            heightProp = 'scrollHeight';
            widthProp = 'scrollWidth';
          }
        } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it


        offsetParent = offsetParent;

        if (placement === top || (placement === left || placement === right) && variation === end) {
          sideY = bottom;
          var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]
          offsetParent[heightProp];
          y -= offsetY - popperRect.height;
          y *= gpuAcceleration ? 1 : -1;
        }

        if (placement === left || (placement === top || placement === bottom) && variation === end) {
          sideX = right;
          var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]
          offsetParent[widthProp];
          x -= offsetX - popperRect.width;
          x *= gpuAcceleration ? 1 : -1;
        }
      }

      var commonStyles = Object.assign({
        position: position
      }, adaptive && unsetSides);

      var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
        x: x,
        y: y
      }) : {
        x: x,
        y: y
      };

      x = _ref4.x;
      y = _ref4.y;

      if (gpuAcceleration) {
        var _Object$assign;

        return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
      }

      return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
    }

    function computeStyles(_ref5) {
      var state = _ref5.state,
          options = _ref5.options;
      var _options$gpuAccelerat = options.gpuAcceleration,
          gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
          _options$adaptive = options.adaptive,
          adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
          _options$roundOffsets = options.roundOffsets,
          roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;

      var commonStyles = {
        placement: getBasePlacement$1(state.placement),
        variation: getVariation(state.placement),
        popper: state.elements.popper,
        popperRect: state.rects.popper,
        gpuAcceleration: gpuAcceleration,
        isFixed: state.options.strategy === 'fixed'
      };

      if (state.modifiersData.popperOffsets != null) {
        state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state.modifiersData.popperOffsets,
          position: state.options.strategy,
          adaptive: adaptive,
          roundOffsets: roundOffsets
        })));
      }

      if (state.modifiersData.arrow != null) {
        state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state.modifiersData.arrow,
          position: 'absolute',
          adaptive: false,
          roundOffsets: roundOffsets
        })));
      }

      state.attributes.popper = Object.assign({}, state.attributes.popper, {
        'data-popper-placement': state.placement
      });
    } // eslint-disable-next-line import/no-unused-modules


    var computeStyles$1 = {
      name: 'computeStyles',
      enabled: true,
      phase: 'beforeWrite',
      fn: computeStyles,
      data: {}
    };

    var passive = {
      passive: true
    };

    function effect(_ref) {
      var state = _ref.state,
          instance = _ref.instance,
          options = _ref.options;
      var _options$scroll = options.scroll,
          scroll = _options$scroll === void 0 ? true : _options$scroll,
          _options$resize = options.resize,
          resize = _options$resize === void 0 ? true : _options$resize;
      var window = getWindow(state.elements.popper);
      var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

      if (scroll) {
        scrollParents.forEach(function (scrollParent) {
          scrollParent.addEventListener('scroll', instance.update, passive);
        });
      }

      if (resize) {
        window.addEventListener('resize', instance.update, passive);
      }

      return function () {
        if (scroll) {
          scrollParents.forEach(function (scrollParent) {
            scrollParent.removeEventListener('scroll', instance.update, passive);
          });
        }

        if (resize) {
          window.removeEventListener('resize', instance.update, passive);
        }
      };
    } // eslint-disable-next-line import/no-unused-modules


    var eventListeners = {
      name: 'eventListeners',
      enabled: true,
      phase: 'write',
      fn: function fn() {},
      effect: effect,
      data: {}
    };

    var hash$1 = {
      left: 'right',
      right: 'left',
      bottom: 'top',
      top: 'bottom'
    };
    function getOppositePlacement(placement) {
      return placement.replace(/left|right|bottom|top/g, function (matched) {
        return hash$1[matched];
      });
    }

    var hash = {
      start: 'end',
      end: 'start'
    };
    function getOppositeVariationPlacement(placement) {
      return placement.replace(/start|end/g, function (matched) {
        return hash[matched];
      });
    }

    function getWindowScroll(node) {
      var win = getWindow(node);
      var scrollLeft = win.pageXOffset;
      var scrollTop = win.pageYOffset;
      return {
        scrollLeft: scrollLeft,
        scrollTop: scrollTop
      };
    }

    function getWindowScrollBarX(element) {
      // If <html> has a CSS width greater than the viewport, then this will be
      // incorrect for RTL.
      // Popper 1 is broken in this case and never had a bug report so let's assume
      // it's not an issue. I don't think anyone ever specifies width on <html>
      // anyway.
      // Browsers where the left scrollbar doesn't cause an issue report `0` for
      // this (e.g. Edge 2019, IE11, Safari)
      return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
    }

    function getViewportRect(element, strategy) {
      var win = getWindow(element);
      var html = getDocumentElement(element);
      var visualViewport = win.visualViewport;
      var width = html.clientWidth;
      var height = html.clientHeight;
      var x = 0;
      var y = 0;

      if (visualViewport) {
        width = visualViewport.width;
        height = visualViewport.height;
        var layoutViewport = isLayoutViewport();

        if (layoutViewport || !layoutViewport && strategy === 'fixed') {
          x = visualViewport.offsetLeft;
          y = visualViewport.offsetTop;
        }
      }

      return {
        width: width,
        height: height,
        x: x + getWindowScrollBarX(element),
        y: y
      };
    }

    // of the `<html>` and `<body>` rect bounds if horizontally scrollable

    function getDocumentRect(element) {
      var _element$ownerDocumen;

      var html = getDocumentElement(element);
      var winScroll = getWindowScroll(element);
      var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
      var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
      var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
      var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
      var y = -winScroll.scrollTop;

      if (getComputedStyle$1(body || html).direction === 'rtl') {
        x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
      }

      return {
        width: width,
        height: height,
        x: x,
        y: y
      };
    }

    function isScrollParent(element) {
      // Firefox wants us to check `-x` and `-y` variations as well
      var _getComputedStyle = getComputedStyle$1(element),
          overflow = _getComputedStyle.overflow,
          overflowX = _getComputedStyle.overflowX,
          overflowY = _getComputedStyle.overflowY;

      return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
    }

    function getScrollParent(node) {
      if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
        // $FlowFixMe[incompatible-return]: assume body is always available
        return node.ownerDocument.body;
      }

      if (isHTMLElement(node) && isScrollParent(node)) {
        return node;
      }

      return getScrollParent(getParentNode(node));
    }

    /*
    given a DOM element, return the list of all scroll parents, up the list of ancesors
    until we get to the top window object. This list is what we attach scroll listeners
    to, because if any of these parent elements scroll, we'll need to re-calculate the
    reference element's position.
    */

    function listScrollParents(element, list) {
      var _element$ownerDocumen;

      if (list === void 0) {
        list = [];
      }

      var scrollParent = getScrollParent(element);
      var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
      var win = getWindow(scrollParent);
      var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
      var updatedList = list.concat(target);
      return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
      updatedList.concat(listScrollParents(getParentNode(target)));
    }

    function rectToClientRect(rect) {
      return Object.assign({}, rect, {
        left: rect.x,
        top: rect.y,
        right: rect.x + rect.width,
        bottom: rect.y + rect.height
      });
    }

    function getInnerBoundingClientRect(element, strategy) {
      var rect = getBoundingClientRect(element, false, strategy === 'fixed');
      rect.top = rect.top + element.clientTop;
      rect.left = rect.left + element.clientLeft;
      rect.bottom = rect.top + element.clientHeight;
      rect.right = rect.left + element.clientWidth;
      rect.width = element.clientWidth;
      rect.height = element.clientHeight;
      rect.x = rect.left;
      rect.y = rect.top;
      return rect;
    }

    function getClientRectFromMixedType(element, clippingParent, strategy) {
      return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement$1(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
    } // A "clipping parent" is an overflowable container with the characteristic of
    // clipping (or hiding) overflowing elements with a position different from
    // `initial`


    function getClippingParents(element) {
      var clippingParents = listScrollParents(getParentNode(element));
      var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle$1(element).position) >= 0;
      var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;

      if (!isElement$1(clipperElement)) {
        return [];
      } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414


      return clippingParents.filter(function (clippingParent) {
        return isElement$1(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';
      });
    } // Gets the maximum area that the element is visible in due to any number of
    // clipping parents


    function getClippingRect(element, boundary, rootBoundary, strategy) {
      var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
      var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
      var firstClippingParent = clippingParents[0];
      var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
        var rect = getClientRectFromMixedType(element, clippingParent, strategy);
        accRect.top = max(rect.top, accRect.top);
        accRect.right = min(rect.right, accRect.right);
        accRect.bottom = min(rect.bottom, accRect.bottom);
        accRect.left = max(rect.left, accRect.left);
        return accRect;
      }, getClientRectFromMixedType(element, firstClippingParent, strategy));
      clippingRect.width = clippingRect.right - clippingRect.left;
      clippingRect.height = clippingRect.bottom - clippingRect.top;
      clippingRect.x = clippingRect.left;
      clippingRect.y = clippingRect.top;
      return clippingRect;
    }

    function computeOffsets(_ref) {
      var reference = _ref.reference,
          element = _ref.element,
          placement = _ref.placement;
      var basePlacement = placement ? getBasePlacement$1(placement) : null;
      var variation = placement ? getVariation(placement) : null;
      var commonX = reference.x + reference.width / 2 - element.width / 2;
      var commonY = reference.y + reference.height / 2 - element.height / 2;
      var offsets;

      switch (basePlacement) {
        case top:
          offsets = {
            x: commonX,
            y: reference.y - element.height
          };
          break;

        case bottom:
          offsets = {
            x: commonX,
            y: reference.y + reference.height
          };
          break;

        case right:
          offsets = {
            x: reference.x + reference.width,
            y: commonY
          };
          break;

        case left:
          offsets = {
            x: reference.x - element.width,
            y: commonY
          };
          break;

        default:
          offsets = {
            x: reference.x,
            y: reference.y
          };
      }

      var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;

      if (mainAxis != null) {
        var len = mainAxis === 'y' ? 'height' : 'width';

        switch (variation) {
          case start:
            offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
            break;

          case end:
            offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
            break;
        }
      }

      return offsets;
    }

    function detectOverflow(state, options) {
      if (options === void 0) {
        options = {};
      }

      var _options = options,
          _options$placement = _options.placement,
          placement = _options$placement === void 0 ? state.placement : _options$placement,
          _options$strategy = _options.strategy,
          strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,
          _options$boundary = _options.boundary,
          boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
          _options$rootBoundary = _options.rootBoundary,
          rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
          _options$elementConte = _options.elementContext,
          elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
          _options$altBoundary = _options.altBoundary,
          altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
          _options$padding = _options.padding,
          padding = _options$padding === void 0 ? 0 : _options$padding;
      var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
      var altContext = elementContext === popper ? reference : popper;
      var popperRect = state.rects.popper;
      var element = state.elements[altBoundary ? altContext : elementContext];
      var clippingClientRect = getClippingRect(isElement$1(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
      var referenceClientRect = getBoundingClientRect(state.elements.reference);
      var popperOffsets = computeOffsets({
        reference: referenceClientRect,
        element: popperRect,
        strategy: 'absolute',
        placement: placement
      });
      var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
      var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
      // 0 or negative = within the clipping rect

      var overflowOffsets = {
        top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
        bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
        left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
        right: elementClientRect.right - clippingClientRect.right + paddingObject.right
      };
      var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

      if (elementContext === popper && offsetData) {
        var offset = offsetData[placement];
        Object.keys(overflowOffsets).forEach(function (key) {
          var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
          var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
          overflowOffsets[key] += offset[axis] * multiply;
        });
      }

      return overflowOffsets;
    }

    function computeAutoPlacement(state, options) {
      if (options === void 0) {
        options = {};
      }

      var _options = options,
          placement = _options.placement,
          boundary = _options.boundary,
          rootBoundary = _options.rootBoundary,
          padding = _options.padding,
          flipVariations = _options.flipVariations,
          _options$allowedAutoP = _options.allowedAutoPlacements,
          allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
      var variation = getVariation(placement);
      var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
        return getVariation(placement) === variation;
      }) : basePlacements;
      var allowedPlacements = placements$1.filter(function (placement) {
        return allowedAutoPlacements.indexOf(placement) >= 0;
      });

      if (allowedPlacements.length === 0) {
        allowedPlacements = placements$1;
      } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...


      var overflows = allowedPlacements.reduce(function (acc, placement) {
        acc[placement] = detectOverflow(state, {
          placement: placement,
          boundary: boundary,
          rootBoundary: rootBoundary,
          padding: padding
        })[getBasePlacement$1(placement)];
        return acc;
      }, {});
      return Object.keys(overflows).sort(function (a, b) {
        return overflows[a] - overflows[b];
      });
    }

    function getExpandedFallbackPlacements(placement) {
      if (getBasePlacement$1(placement) === auto) {
        return [];
      }

      var oppositePlacement = getOppositePlacement(placement);
      return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
    }

    function flip(_ref) {
      var state = _ref.state,
          options = _ref.options,
          name = _ref.name;

      if (state.modifiersData[name]._skip) {
        return;
      }

      var _options$mainAxis = options.mainAxis,
          checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
          _options$altAxis = options.altAxis,
          checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
          specifiedFallbackPlacements = options.fallbackPlacements,
          padding = options.padding,
          boundary = options.boundary,
          rootBoundary = options.rootBoundary,
          altBoundary = options.altBoundary,
          _options$flipVariatio = options.flipVariations,
          flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
          allowedAutoPlacements = options.allowedAutoPlacements;
      var preferredPlacement = state.options.placement;
      var basePlacement = getBasePlacement$1(preferredPlacement);
      var isBasePlacement = basePlacement === preferredPlacement;
      var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
      var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
        return acc.concat(getBasePlacement$1(placement) === auto ? computeAutoPlacement(state, {
          placement: placement,
          boundary: boundary,
          rootBoundary: rootBoundary,
          padding: padding,
          flipVariations: flipVariations,
          allowedAutoPlacements: allowedAutoPlacements
        }) : placement);
      }, []);
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var checksMap = new Map();
      var makeFallbackChecks = true;
      var firstFittingPlacement = placements[0];

      for (var i = 0; i < placements.length; i++) {
        var placement = placements[i];

        var _basePlacement = getBasePlacement$1(placement);

        var isStartVariation = getVariation(placement) === start;
        var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
        var len = isVertical ? 'width' : 'height';
        var overflow = detectOverflow(state, {
          placement: placement,
          boundary: boundary,
          rootBoundary: rootBoundary,
          altBoundary: altBoundary,
          padding: padding
        });
        var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;

        if (referenceRect[len] > popperRect[len]) {
          mainVariationSide = getOppositePlacement(mainVariationSide);
        }

        var altVariationSide = getOppositePlacement(mainVariationSide);
        var checks = [];

        if (checkMainAxis) {
          checks.push(overflow[_basePlacement] <= 0);
        }

        if (checkAltAxis) {
          checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
        }

        if (checks.every(function (check) {
          return check;
        })) {
          firstFittingPlacement = placement;
          makeFallbackChecks = false;
          break;
        }

        checksMap.set(placement, checks);
      }

      if (makeFallbackChecks) {
        // `2` may be desired in some cases – research later
        var numberOfChecks = flipVariations ? 3 : 1;

        var _loop = function _loop(_i) {
          var fittingPlacement = placements.find(function (placement) {
            var checks = checksMap.get(placement);

            if (checks) {
              return checks.slice(0, _i).every(function (check) {
                return check;
              });
            }
          });

          if (fittingPlacement) {
            firstFittingPlacement = fittingPlacement;
            return "break";
          }
        };

        for (var _i = numberOfChecks; _i > 0; _i--) {
          var _ret = _loop(_i);

          if (_ret === "break") break;
        }
      }

      if (state.placement !== firstFittingPlacement) {
        state.modifiersData[name]._skip = true;
        state.placement = firstFittingPlacement;
        state.reset = true;
      }
    } // eslint-disable-next-line import/no-unused-modules


    var flip$1 = {
      name: 'flip',
      enabled: true,
      phase: 'main',
      fn: flip,
      requiresIfExists: ['offset'],
      data: {
        _skip: false
      }
    };

    function getSideOffsets(overflow, rect, preventedOffsets) {
      if (preventedOffsets === void 0) {
        preventedOffsets = {
          x: 0,
          y: 0
        };
      }

      return {
        top: overflow.top - rect.height - preventedOffsets.y,
        right: overflow.right - rect.width + preventedOffsets.x,
        bottom: overflow.bottom - rect.height + preventedOffsets.y,
        left: overflow.left - rect.width - preventedOffsets.x
      };
    }

    function isAnySideFullyClipped(overflow) {
      return [top, right, bottom, left].some(function (side) {
        return overflow[side] >= 0;
      });
    }

    function hide(_ref) {
      var state = _ref.state,
          name = _ref.name;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var preventedOffsets = state.modifiersData.preventOverflow;
      var referenceOverflow = detectOverflow(state, {
        elementContext: 'reference'
      });
      var popperAltOverflow = detectOverflow(state, {
        altBoundary: true
      });
      var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
      var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
      var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
      var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
      state.modifiersData[name] = {
        referenceClippingOffsets: referenceClippingOffsets,
        popperEscapeOffsets: popperEscapeOffsets,
        isReferenceHidden: isReferenceHidden,
        hasPopperEscaped: hasPopperEscaped
      };
      state.attributes.popper = Object.assign({}, state.attributes.popper, {
        'data-popper-reference-hidden': isReferenceHidden,
        'data-popper-escaped': hasPopperEscaped
      });
    } // eslint-disable-next-line import/no-unused-modules


    var hide$1 = {
      name: 'hide',
      enabled: true,
      phase: 'main',
      requiresIfExists: ['preventOverflow'],
      fn: hide
    };

    function distanceAndSkiddingToXY(placement, rects, offset) {
      var basePlacement = getBasePlacement$1(placement);
      var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;

      var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
        placement: placement
      })) : offset,
          skidding = _ref[0],
          distance = _ref[1];

      skidding = skidding || 0;
      distance = (distance || 0) * invertDistance;
      return [left, right].indexOf(basePlacement) >= 0 ? {
        x: distance,
        y: skidding
      } : {
        x: skidding,
        y: distance
      };
    }

    function offset(_ref2) {
      var state = _ref2.state,
          options = _ref2.options,
          name = _ref2.name;
      var _options$offset = options.offset,
          offset = _options$offset === void 0 ? [0, 0] : _options$offset;
      var data = placements.reduce(function (acc, placement) {
        acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
        return acc;
      }, {});
      var _data$state$placement = data[state.placement],
          x = _data$state$placement.x,
          y = _data$state$placement.y;

      if (state.modifiersData.popperOffsets != null) {
        state.modifiersData.popperOffsets.x += x;
        state.modifiersData.popperOffsets.y += y;
      }

      state.modifiersData[name] = data;
    } // eslint-disable-next-line import/no-unused-modules


    var offset$1 = {
      name: 'offset',
      enabled: true,
      phase: 'main',
      requires: ['popperOffsets'],
      fn: offset
    };

    function popperOffsets(_ref) {
      var state = _ref.state,
          name = _ref.name;
      // Offsets are the actual position the popper needs to have to be
      // properly positioned near its reference element
      // This is the most basic placement, and will be adjusted by
      // the modifiers in the next step
      state.modifiersData[name] = computeOffsets({
        reference: state.rects.reference,
        element: state.rects.popper,
        strategy: 'absolute',
        placement: state.placement
      });
    } // eslint-disable-next-line import/no-unused-modules


    var popperOffsets$1 = {
      name: 'popperOffsets',
      enabled: true,
      phase: 'read',
      fn: popperOffsets,
      data: {}
    };

    function getAltAxis(axis) {
      return axis === 'x' ? 'y' : 'x';
    }

    function preventOverflow(_ref) {
      var state = _ref.state,
          options = _ref.options,
          name = _ref.name;
      var _options$mainAxis = options.mainAxis,
          checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
          _options$altAxis = options.altAxis,
          checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
          boundary = options.boundary,
          rootBoundary = options.rootBoundary,
          altBoundary = options.altBoundary,
          padding = options.padding,
          _options$tether = options.tether,
          tether = _options$tether === void 0 ? true : _options$tether,
          _options$tetherOffset = options.tetherOffset,
          tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
      var overflow = detectOverflow(state, {
        boundary: boundary,
        rootBoundary: rootBoundary,
        padding: padding,
        altBoundary: altBoundary
      });
      var basePlacement = getBasePlacement$1(state.placement);
      var variation = getVariation(state.placement);
      var isBasePlacement = !variation;
      var mainAxis = getMainAxisFromPlacement(basePlacement);
      var altAxis = getAltAxis(mainAxis);
      var popperOffsets = state.modifiersData.popperOffsets;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
        placement: state.placement
      })) : tetherOffset;
      var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
        mainAxis: tetherOffsetValue,
        altAxis: tetherOffsetValue
      } : Object.assign({
        mainAxis: 0,
        altAxis: 0
      }, tetherOffsetValue);
      var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
      var data = {
        x: 0,
        y: 0
      };

      if (!popperOffsets) {
        return;
      }

      if (checkMainAxis) {
        var _offsetModifierState$;

        var mainSide = mainAxis === 'y' ? top : left;
        var altSide = mainAxis === 'y' ? bottom : right;
        var len = mainAxis === 'y' ? 'height' : 'width';
        var offset = popperOffsets[mainAxis];
        var min$1 = offset + overflow[mainSide];
        var max$1 = offset - overflow[altSide];
        var additive = tether ? -popperRect[len] / 2 : 0;
        var minLen = variation === start ? referenceRect[len] : popperRect[len];
        var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
        // outside the reference bounds

        var arrowElement = state.elements.arrow;
        var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
          width: 0,
          height: 0
        };
        var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
        var arrowPaddingMin = arrowPaddingObject[mainSide];
        var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
        // to include its full size in the calculation. If the reference is small
        // and near the edge of a boundary, the popper can overflow even if the
        // reference is not overflowing as well (e.g. virtual elements with no
        // width or height)

        var arrowLen = within(0, referenceRect[len], arrowRect[len]);
        var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
        var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
        var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
        var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
        var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
        var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
        var tetherMax = offset + maxOffset - offsetModifierValue;
        var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);
        popperOffsets[mainAxis] = preventedOffset;
        data[mainAxis] = preventedOffset - offset;
      }

      if (checkAltAxis) {
        var _offsetModifierState$2;

        var _mainSide = mainAxis === 'x' ? top : left;

        var _altSide = mainAxis === 'x' ? bottom : right;

        var _offset = popperOffsets[altAxis];

        var _len = altAxis === 'y' ? 'height' : 'width';

        var _min = _offset + overflow[_mainSide];

        var _max = _offset - overflow[_altSide];

        var isOriginSide = [top, left].indexOf(basePlacement) !== -1;

        var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;

        var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;

        var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;

        var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);

        popperOffsets[altAxis] = _preventedOffset;
        data[altAxis] = _preventedOffset - _offset;
      }

      state.modifiersData[name] = data;
    } // eslint-disable-next-line import/no-unused-modules


    var preventOverflow$1 = {
      name: 'preventOverflow',
      enabled: true,
      phase: 'main',
      fn: preventOverflow,
      requiresIfExists: ['offset']
    };

    function getHTMLElementScroll(element) {
      return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
      };
    }

    function getNodeScroll(node) {
      if (node === getWindow(node) || !isHTMLElement(node)) {
        return getWindowScroll(node);
      } else {
        return getHTMLElementScroll(node);
      }
    }

    function isElementScaled(element) {
      var rect = element.getBoundingClientRect();
      var scaleX = round(rect.width) / element.offsetWidth || 1;
      var scaleY = round(rect.height) / element.offsetHeight || 1;
      return scaleX !== 1 || scaleY !== 1;
    } // Returns the composite rect of an element relative to its offsetParent.
    // Composite means it takes into account transforms as well as layout.


    function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
      if (isFixed === void 0) {
        isFixed = false;
      }

      var isOffsetParentAnElement = isHTMLElement(offsetParent);
      var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
      var documentElement = getDocumentElement(offsetParent);
      var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
      var scroll = {
        scrollLeft: 0,
        scrollTop: 0
      };
      var offsets = {
        x: 0,
        y: 0
      };

      if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
        isScrollParent(documentElement)) {
          scroll = getNodeScroll(offsetParent);
        }

        if (isHTMLElement(offsetParent)) {
          offsets = getBoundingClientRect(offsetParent, true);
          offsets.x += offsetParent.clientLeft;
          offsets.y += offsetParent.clientTop;
        } else if (documentElement) {
          offsets.x = getWindowScrollBarX(documentElement);
        }
      }

      return {
        x: rect.left + scroll.scrollLeft - offsets.x,
        y: rect.top + scroll.scrollTop - offsets.y,
        width: rect.width,
        height: rect.height
      };
    }

    function order(modifiers) {
      var map = new Map();
      var visited = new Set();
      var result = [];
      modifiers.forEach(function (modifier) {
        map.set(modifier.name, modifier);
      }); // On visiting object, check for its dependencies and visit them recursively

      function sort(modifier) {
        visited.add(modifier.name);
        var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
        requires.forEach(function (dep) {
          if (!visited.has(dep)) {
            var depModifier = map.get(dep);

            if (depModifier) {
              sort(depModifier);
            }
          }
        });
        result.push(modifier);
      }

      modifiers.forEach(function (modifier) {
        if (!visited.has(modifier.name)) {
          // check for visited object
          sort(modifier);
        }
      });
      return result;
    }

    function orderModifiers(modifiers) {
      // order based on dependencies
      var orderedModifiers = order(modifiers); // order based on phase

      return modifierPhases.reduce(function (acc, phase) {
        return acc.concat(orderedModifiers.filter(function (modifier) {
          return modifier.phase === phase;
        }));
      }, []);
    }

    function debounce$1(fn) {
      var pending;
      return function () {
        if (!pending) {
          pending = new Promise(function (resolve) {
            Promise.resolve().then(function () {
              pending = undefined;
              resolve(fn());
            });
          });
        }

        return pending;
      };
    }

    function mergeByName(modifiers) {
      var merged = modifiers.reduce(function (merged, current) {
        var existing = merged[current.name];
        merged[current.name] = existing ? Object.assign({}, existing, current, {
          options: Object.assign({}, existing.options, current.options),
          data: Object.assign({}, existing.data, current.data)
        }) : current;
        return merged;
      }, {}); // IE11 does not support Object.values

      return Object.keys(merged).map(function (key) {
        return merged[key];
      });
    }

    var DEFAULT_OPTIONS = {
      placement: 'bottom',
      modifiers: [],
      strategy: 'absolute'
    };

    function areValidElements() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return !args.some(function (element) {
        return !(element && typeof element.getBoundingClientRect === 'function');
      });
    }

    function popperGenerator(generatorOptions) {
      if (generatorOptions === void 0) {
        generatorOptions = {};
      }

      var _generatorOptions = generatorOptions,
          _generatorOptions$def = _generatorOptions.defaultModifiers,
          defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
          _generatorOptions$def2 = _generatorOptions.defaultOptions,
          defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
      return function createPopper(reference, popper, options) {
        if (options === void 0) {
          options = defaultOptions;
        }

        var state = {
          placement: 'bottom',
          orderedModifiers: [],
          options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
          modifiersData: {},
          elements: {
            reference: reference,
            popper: popper
          },
          attributes: {},
          styles: {}
        };
        var effectCleanupFns = [];
        var isDestroyed = false;
        var instance = {
          state: state,
          setOptions: function setOptions(setOptionsAction) {
            var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
            cleanupModifierEffects();
            state.options = Object.assign({}, defaultOptions, state.options, options);
            state.scrollParents = {
              reference: isElement$1(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
              popper: listScrollParents(popper)
            }; // Orders the modifiers based on their dependencies and `phase`
            // properties

            var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

            state.orderedModifiers = orderedModifiers.filter(function (m) {
              return m.enabled;
            }); // Validate the provided modifiers so that the consumer will get warned

            runModifierEffects();
            return instance.update();
          },
          // Sync update – it will always be executed, even if not necessary. This
          // is useful for low frequency updates where sync behavior simplifies the
          // logic.
          // For high frequency updates (e.g. `resize` and `scroll` events), always
          // prefer the async Popper#update method
          forceUpdate: function forceUpdate() {
            if (isDestroyed) {
              return;
            }

            var _state$elements = state.elements,
                reference = _state$elements.reference,
                popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
            // anymore

            if (!areValidElements(reference, popper)) {

              return;
            } // Store the reference and popper rects to be read by modifiers


            state.rects = {
              reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
              popper: getLayoutRect(popper)
            }; // Modifiers have the ability to reset the current update cycle. The
            // most common use case for this is the `flip` modifier changing the
            // placement, which then needs to re-run all the modifiers, because the
            // logic was previously ran for the previous placement and is therefore
            // stale/incorrect

            state.reset = false;
            state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
            // is filled with the initial data specified by the modifier. This means
            // it doesn't persist and is fresh on each update.
            // To ensure persistent data, use `${name}#persistent`

            state.orderedModifiers.forEach(function (modifier) {
              return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
            });

            for (var index = 0; index < state.orderedModifiers.length; index++) {

              if (state.reset === true) {
                state.reset = false;
                index = -1;
                continue;
              }

              var _state$orderedModifie = state.orderedModifiers[index],
                  fn = _state$orderedModifie.fn,
                  _state$orderedModifie2 = _state$orderedModifie.options,
                  _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
                  name = _state$orderedModifie.name;

              if (typeof fn === 'function') {
                state = fn({
                  state: state,
                  options: _options,
                  name: name,
                  instance: instance
                }) || state;
              }
            }
          },
          // Async and optimistically optimized update – it will not be executed if
          // not necessary (debounced to run at most once-per-tick)
          update: debounce$1(function () {
            return new Promise(function (resolve) {
              instance.forceUpdate();
              resolve(state);
            });
          }),
          destroy: function destroy() {
            cleanupModifierEffects();
            isDestroyed = true;
          }
        };

        if (!areValidElements(reference, popper)) {

          return instance;
        }

        instance.setOptions(options).then(function (state) {
          if (!isDestroyed && options.onFirstUpdate) {
            options.onFirstUpdate(state);
          }
        }); // Modifiers have the ability to execute arbitrary code before the first
        // update cycle runs. They will be executed in the same order as the update
        // cycle. This is useful when a modifier adds some persistent data that
        // other modifiers need to use, but the modifier is run after the dependent
        // one.

        function runModifierEffects() {
          state.orderedModifiers.forEach(function (_ref3) {
            var name = _ref3.name,
                _ref3$options = _ref3.options,
                options = _ref3$options === void 0 ? {} : _ref3$options,
                effect = _ref3.effect;

            if (typeof effect === 'function') {
              var cleanupFn = effect({
                state: state,
                name: name,
                instance: instance,
                options: options
              });

              var noopFn = function noopFn() {};

              effectCleanupFns.push(cleanupFn || noopFn);
            }
          });
        }

        function cleanupModifierEffects() {
          effectCleanupFns.forEach(function (fn) {
            return fn();
          });
          effectCleanupFns = [];
        }

        return instance;
      };
    }

    var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
    var createPopper = /*#__PURE__*/popperGenerator({
      defaultModifiers: defaultModifiers
    }); // eslint-disable-next-line import/no-unused-modules

    /**!
    * tippy.js v6.3.7
    * (c) 2017-2021 atomiks
    * MIT License
    */
    var BOX_CLASS = "tippy-box";
    var CONTENT_CLASS = "tippy-content";
    var BACKDROP_CLASS = "tippy-backdrop";
    var ARROW_CLASS = "tippy-arrow";
    var SVG_ARROW_CLASS = "tippy-svg-arrow";
    var TOUCH_OPTIONS = {
      passive: true,
      capture: true
    };
    var TIPPY_DEFAULT_APPEND_TO = function TIPPY_DEFAULT_APPEND_TO() {
      return document.body;
    };
    function getValueAtIndexOrReturn(value, index, defaultValue) {
      if (Array.isArray(value)) {
        var v = value[index];
        return v == null ? Array.isArray(defaultValue) ? defaultValue[index] : defaultValue : v;
      }

      return value;
    }
    function isType(value, type) {
      var str = {}.toString.call(value);
      return str.indexOf('[object') === 0 && str.indexOf(type + "]") > -1;
    }
    function invokeWithArgsOrReturn(value, args) {
      return typeof value === 'function' ? value.apply(void 0, args) : value;
    }
    function debounce(fn, ms) {
      // Avoid wrapping in `setTimeout` if ms is 0 anyway
      if (ms === 0) {
        return fn;
      }

      var timeout;
      return function (arg) {
        clearTimeout(timeout);
        timeout = setTimeout(function () {
          fn(arg);
        }, ms);
      };
    }
    function splitBySpaces(value) {
      return value.split(/\s+/).filter(Boolean);
    }
    function normalizeToArray(value) {
      return [].concat(value);
    }
    function pushIfUnique(arr, value) {
      if (arr.indexOf(value) === -1) {
        arr.push(value);
      }
    }
    function unique(arr) {
      return arr.filter(function (item, index) {
        return arr.indexOf(item) === index;
      });
    }
    function getBasePlacement(placement) {
      return placement.split('-')[0];
    }
    function arrayFrom(value) {
      return [].slice.call(value);
    }
    function removeUndefinedProps(obj) {
      return Object.keys(obj).reduce(function (acc, key) {
        if (obj[key] !== undefined) {
          acc[key] = obj[key];
        }

        return acc;
      }, {});
    }

    function div() {
      return document.createElement('div');
    }
    function isElement(value) {
      return ['Element', 'Fragment'].some(function (type) {
        return isType(value, type);
      });
    }
    function isNodeList(value) {
      return isType(value, 'NodeList');
    }
    function isMouseEvent(value) {
      return isType(value, 'MouseEvent');
    }
    function isReferenceElement(value) {
      return !!(value && value._tippy && value._tippy.reference === value);
    }
    function getArrayOfElements(value) {
      if (isElement(value)) {
        return [value];
      }

      if (isNodeList(value)) {
        return arrayFrom(value);
      }

      if (Array.isArray(value)) {
        return value;
      }

      return arrayFrom(document.querySelectorAll(value));
    }
    function setTransitionDuration(els, value) {
      els.forEach(function (el) {
        if (el) {
          el.style.transitionDuration = value + "ms";
        }
      });
    }
    function setVisibilityState(els, state) {
      els.forEach(function (el) {
        if (el) {
          el.setAttribute('data-state', state);
        }
      });
    }
    function getOwnerDocument(elementOrElements) {
      var _element$ownerDocumen;

      var _normalizeToArray = normalizeToArray(elementOrElements),
          element = _normalizeToArray[0]; // Elements created via a <template> have an ownerDocument with no reference to the body


      return element != null && (_element$ownerDocumen = element.ownerDocument) != null && _element$ownerDocumen.body ? element.ownerDocument : document;
    }
    function isCursorOutsideInteractiveBorder(popperTreeData, event) {
      var clientX = event.clientX,
          clientY = event.clientY;
      return popperTreeData.every(function (_ref) {
        var popperRect = _ref.popperRect,
            popperState = _ref.popperState,
            props = _ref.props;
        var interactiveBorder = props.interactiveBorder;
        var basePlacement = getBasePlacement(popperState.placement);
        var offsetData = popperState.modifiersData.offset;

        if (!offsetData) {
          return true;
        }

        var topDistance = basePlacement === 'bottom' ? offsetData.top.y : 0;
        var bottomDistance = basePlacement === 'top' ? offsetData.bottom.y : 0;
        var leftDistance = basePlacement === 'right' ? offsetData.left.x : 0;
        var rightDistance = basePlacement === 'left' ? offsetData.right.x : 0;
        var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
        var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
        var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
        var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
        return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
      });
    }
    function updateTransitionEndListener(box, action, listener) {
      var method = action + "EventListener"; // some browsers apparently support `transition` (unprefixed) but only fire
      // `webkitTransitionEnd`...

      ['transitionend', 'webkitTransitionEnd'].forEach(function (event) {
        box[method](event, listener);
      });
    }
    /**
     * Compared to xxx.contains, this function works for dom structures with shadow
     * dom
     */

    function actualContains(parent, child) {
      var target = child;

      while (target) {
        var _target$getRootNode;

        if (parent.contains(target)) {
          return true;
        }

        target = target.getRootNode == null ? void 0 : (_target$getRootNode = target.getRootNode()) == null ? void 0 : _target$getRootNode.host;
      }

      return false;
    }

    var currentInput = {
      isTouch: false
    };
    var lastMouseMoveTime = 0;
    /**
     * When a `touchstart` event is fired, it's assumed the user is using touch
     * input. We'll bind a `mousemove` event listener to listen for mouse input in
     * the future. This way, the `isTouch` property is fully dynamic and will handle
     * hybrid devices that use a mix of touch + mouse input.
     */

    function onDocumentTouchStart() {
      if (currentInput.isTouch) {
        return;
      }

      currentInput.isTouch = true;

      if (window.performance) {
        document.addEventListener('mousemove', onDocumentMouseMove);
      }
    }
    /**
     * When two `mousemove` event are fired consecutively within 20ms, it's assumed
     * the user is using mouse input again. `mousemove` can fire on touch devices as
     * well, but very rarely that quickly.
     */

    function onDocumentMouseMove() {
      var now = performance.now();

      if (now - lastMouseMoveTime < 20) {
        currentInput.isTouch = false;
        document.removeEventListener('mousemove', onDocumentMouseMove);
      }

      lastMouseMoveTime = now;
    }
    /**
     * When an element is in focus and has a tippy, leaving the tab/window and
     * returning causes it to show again. For mouse users this is unexpected, but
     * for keyboard use it makes sense.
     * TODO: find a better technique to solve this problem
     */

    function onWindowBlur() {
      var activeElement = document.activeElement;

      if (isReferenceElement(activeElement)) {
        var instance = activeElement._tippy;

        if (activeElement.blur && !instance.state.isVisible) {
          activeElement.blur();
        }
      }
    }
    function bindGlobalEventListeners() {
      document.addEventListener('touchstart', onDocumentTouchStart, TOUCH_OPTIONS);
      window.addEventListener('blur', onWindowBlur);
    }

    var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';
    var isIE11 = isBrowser ? // @ts-ignore
    !!window.msCrypto : false;

    var pluginProps = {
      animateFill: false,
      followCursor: false,
      inlinePositioning: false,
      sticky: false
    };
    var renderProps = {
      allowHTML: false,
      animation: 'fade',
      arrow: true,
      content: '',
      inertia: false,
      maxWidth: 350,
      role: 'tooltip',
      theme: '',
      zIndex: 9999
    };
    var defaultProps = Object.assign({
      appendTo: TIPPY_DEFAULT_APPEND_TO,
      aria: {
        content: 'auto',
        expanded: 'auto'
      },
      delay: 0,
      duration: [300, 250],
      getReferenceClientRect: null,
      hideOnClick: true,
      ignoreAttributes: false,
      interactive: false,
      interactiveBorder: 2,
      interactiveDebounce: 0,
      moveTransition: '',
      offset: [0, 10],
      onAfterUpdate: function onAfterUpdate() {},
      onBeforeUpdate: function onBeforeUpdate() {},
      onCreate: function onCreate() {},
      onDestroy: function onDestroy() {},
      onHidden: function onHidden() {},
      onHide: function onHide() {},
      onMount: function onMount() {},
      onShow: function onShow() {},
      onShown: function onShown() {},
      onTrigger: function onTrigger() {},
      onUntrigger: function onUntrigger() {},
      onClickOutside: function onClickOutside() {},
      placement: 'top',
      plugins: [],
      popperOptions: {},
      render: null,
      showOnCreate: false,
      touch: true,
      trigger: 'mouseenter focus',
      triggerTarget: null
    }, pluginProps, renderProps);
    var defaultKeys = Object.keys(defaultProps);
    var setDefaultProps = function setDefaultProps(partialProps) {

      var keys = Object.keys(partialProps);
      keys.forEach(function (key) {
        defaultProps[key] = partialProps[key];
      });
    };
    function getExtendedPassedProps(passedProps) {
      var plugins = passedProps.plugins || [];
      var pluginProps = plugins.reduce(function (acc, plugin) {
        var name = plugin.name,
            defaultValue = plugin.defaultValue;

        if (name) {
          var _name;

          acc[name] = passedProps[name] !== undefined ? passedProps[name] : (_name = defaultProps[name]) != null ? _name : defaultValue;
        }

        return acc;
      }, {});
      return Object.assign({}, passedProps, pluginProps);
    }
    function getDataAttributeProps(reference, plugins) {
      var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
        plugins: plugins
      }))) : defaultKeys;
      var props = propKeys.reduce(function (acc, key) {
        var valueAsString = (reference.getAttribute("data-tippy-" + key) || '').trim();

        if (!valueAsString) {
          return acc;
        }

        if (key === 'content') {
          acc[key] = valueAsString;
        } else {
          try {
            acc[key] = JSON.parse(valueAsString);
          } catch (e) {
            acc[key] = valueAsString;
          }
        }

        return acc;
      }, {});
      return props;
    }
    function evaluateProps(reference, props) {
      var out = Object.assign({}, props, {
        content: invokeWithArgsOrReturn(props.content, [reference])
      }, props.ignoreAttributes ? {} : getDataAttributeProps(reference, props.plugins));
      out.aria = Object.assign({}, defaultProps.aria, out.aria);
      out.aria = {
        expanded: out.aria.expanded === 'auto' ? props.interactive : out.aria.expanded,
        content: out.aria.content === 'auto' ? props.interactive ? null : 'describedby' : out.aria.content
      };
      return out;
    }

    var innerHTML = function innerHTML() {
      return 'innerHTML';
    };

    function dangerouslySetInnerHTML(element, html) {
      element[innerHTML()] = html;
    }

    function createArrowElement(value) {
      var arrow = div();

      if (value === true) {
        arrow.className = ARROW_CLASS;
      } else {
        arrow.className = SVG_ARROW_CLASS;

        if (isElement(value)) {
          arrow.appendChild(value);
        } else {
          dangerouslySetInnerHTML(arrow, value);
        }
      }

      return arrow;
    }

    function setContent(content, props) {
      if (isElement(props.content)) {
        dangerouslySetInnerHTML(content, '');
        content.appendChild(props.content);
      } else if (typeof props.content !== 'function') {
        if (props.allowHTML) {
          dangerouslySetInnerHTML(content, props.content);
        } else {
          content.textContent = props.content;
        }
      }
    }
    function getChildren(popper) {
      var box = popper.firstElementChild;
      var boxChildren = arrayFrom(box.children);
      return {
        box: box,
        content: boxChildren.find(function (node) {
          return node.classList.contains(CONTENT_CLASS);
        }),
        arrow: boxChildren.find(function (node) {
          return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);
        }),
        backdrop: boxChildren.find(function (node) {
          return node.classList.contains(BACKDROP_CLASS);
        })
      };
    }
    function render(instance) {
      var popper = div();
      var box = div();
      box.className = BOX_CLASS;
      box.setAttribute('data-state', 'hidden');
      box.setAttribute('tabindex', '-1');
      var content = div();
      content.className = CONTENT_CLASS;
      content.setAttribute('data-state', 'hidden');
      setContent(content, instance.props);
      popper.appendChild(box);
      box.appendChild(content);
      onUpdate(instance.props, instance.props);

      function onUpdate(prevProps, nextProps) {
        var _getChildren = getChildren(popper),
            box = _getChildren.box,
            content = _getChildren.content,
            arrow = _getChildren.arrow;

        if (nextProps.theme) {
          box.setAttribute('data-theme', nextProps.theme);
        } else {
          box.removeAttribute('data-theme');
        }

        if (typeof nextProps.animation === 'string') {
          box.setAttribute('data-animation', nextProps.animation);
        } else {
          box.removeAttribute('data-animation');
        }

        if (nextProps.inertia) {
          box.setAttribute('data-inertia', '');
        } else {
          box.removeAttribute('data-inertia');
        }

        box.style.maxWidth = typeof nextProps.maxWidth === 'number' ? nextProps.maxWidth + "px" : nextProps.maxWidth;

        if (nextProps.role) {
          box.setAttribute('role', nextProps.role);
        } else {
          box.removeAttribute('role');
        }

        if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {
          setContent(content, instance.props);
        }

        if (nextProps.arrow) {
          if (!arrow) {
            box.appendChild(createArrowElement(nextProps.arrow));
          } else if (prevProps.arrow !== nextProps.arrow) {
            box.removeChild(arrow);
            box.appendChild(createArrowElement(nextProps.arrow));
          }
        } else if (arrow) {
          box.removeChild(arrow);
        }
      }

      return {
        popper: popper,
        onUpdate: onUpdate
      };
    } // Runtime check to identify if the render function is the default one; this
    // way we can apply default CSS transitions logic and it can be tree-shaken away

    render.$$tippy = true;

    var idCounter = 1;
    var mouseMoveListeners = []; // Used by `hideAll()`

    var mountedInstances = [];
    function createTippy(reference, passedProps) {
      var props = evaluateProps(reference, Object.assign({}, defaultProps, getExtendedPassedProps(removeUndefinedProps(passedProps)))); // ===========================================================================
      // 🔒 Private members
      // ===========================================================================

      var showTimeout;
      var hideTimeout;
      var scheduleHideAnimationFrame;
      var isVisibleFromClick = false;
      var didHideDueToDocumentMouseDown = false;
      var didTouchMove = false;
      var ignoreOnFirstUpdate = false;
      var lastTriggerEvent;
      var currentTransitionEndListener;
      var onFirstUpdate;
      var listeners = [];
      var debouncedOnMouseMove = debounce(onMouseMove, props.interactiveDebounce);
      var currentTarget; // ===========================================================================
      // 🔑 Public members
      // ===========================================================================

      var id = idCounter++;
      var popperInstance = null;
      var plugins = unique(props.plugins);
      var state = {
        // Is the instance currently enabled?
        isEnabled: true,
        // Is the tippy currently showing and not transitioning out?
        isVisible: false,
        // Has the instance been destroyed?
        isDestroyed: false,
        // Is the tippy currently mounted to the DOM?
        isMounted: false,
        // Has the tippy finished transitioning in?
        isShown: false
      };
      var instance = {
        // properties
        id: id,
        reference: reference,
        popper: div(),
        popperInstance: popperInstance,
        props: props,
        state: state,
        plugins: plugins,
        // methods
        clearDelayTimeouts: clearDelayTimeouts,
        setProps: setProps,
        setContent: setContent,
        show: show,
        hide: hide,
        hideWithInteractivity: hideWithInteractivity,
        enable: enable,
        disable: disable,
        unmount: unmount,
        destroy: destroy
      }; // TODO: Investigate why this early return causes a TDZ error in the tests —
      // it doesn't seem to happen in the browser

      /* istanbul ignore if */

      if (!props.render) {

        return instance;
      } // ===========================================================================
      // Initial mutations
      // ===========================================================================


      var _props$render = props.render(instance),
          popper = _props$render.popper,
          onUpdate = _props$render.onUpdate;

      popper.setAttribute('data-tippy-root', '');
      popper.id = "tippy-" + instance.id;
      instance.popper = popper;
      reference._tippy = instance;
      popper._tippy = instance;
      var pluginsHooks = plugins.map(function (plugin) {
        return plugin.fn(instance);
      });
      var hasAriaExpanded = reference.hasAttribute('aria-expanded');
      addListeners();
      handleAriaExpandedAttribute();
      handleStyles();
      invokeHook('onCreate', [instance]);

      if (props.showOnCreate) {
        scheduleShow();
      } // Prevent a tippy with a delay from hiding if the cursor left then returned
      // before it started hiding


      popper.addEventListener('mouseenter', function () {
        if (instance.props.interactive && instance.state.isVisible) {
          instance.clearDelayTimeouts();
        }
      });
      popper.addEventListener('mouseleave', function () {
        if (instance.props.interactive && instance.props.trigger.indexOf('mouseenter') >= 0) {
          getDocument().addEventListener('mousemove', debouncedOnMouseMove);
        }
      });
      return instance; // ===========================================================================
      // 🔒 Private methods
      // ===========================================================================

      function getNormalizedTouchSettings() {
        var touch = instance.props.touch;
        return Array.isArray(touch) ? touch : [touch, 0];
      }

      function getIsCustomTouchBehavior() {
        return getNormalizedTouchSettings()[0] === 'hold';
      }

      function getIsDefaultRenderFn() {
        var _instance$props$rende;

        // @ts-ignore
        return !!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy);
      }

      function getCurrentTarget() {
        return currentTarget || reference;
      }

      function getDocument() {
        var parent = getCurrentTarget().parentNode;
        return parent ? getOwnerDocument(parent) : document;
      }

      function getDefaultTemplateChildren() {
        return getChildren(popper);
      }

      function getDelay(isShow) {
        // For touch or keyboard input, force `0` delay for UX reasons
        // Also if the instance is mounted but not visible (transitioning out),
        // ignore delay
        if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === 'focus') {
          return 0;
        }

        return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);
      }

      function handleStyles(fromHide) {
        if (fromHide === void 0) {
          fromHide = false;
        }

        popper.style.pointerEvents = instance.props.interactive && !fromHide ? '' : 'none';
        popper.style.zIndex = "" + instance.props.zIndex;
      }

      function invokeHook(hook, args, shouldInvokePropsHook) {
        if (shouldInvokePropsHook === void 0) {
          shouldInvokePropsHook = true;
        }

        pluginsHooks.forEach(function (pluginHooks) {
          if (pluginHooks[hook]) {
            pluginHooks[hook].apply(pluginHooks, args);
          }
        });

        if (shouldInvokePropsHook) {
          var _instance$props;

          (_instance$props = instance.props)[hook].apply(_instance$props, args);
        }
      }

      function handleAriaContentAttribute() {
        var aria = instance.props.aria;

        if (!aria.content) {
          return;
        }

        var attr = "aria-" + aria.content;
        var id = popper.id;
        var nodes = normalizeToArray(instance.props.triggerTarget || reference);
        nodes.forEach(function (node) {
          var currentValue = node.getAttribute(attr);

          if (instance.state.isVisible) {
            node.setAttribute(attr, currentValue ? currentValue + " " + id : id);
          } else {
            var nextValue = currentValue && currentValue.replace(id, '').trim();

            if (nextValue) {
              node.setAttribute(attr, nextValue);
            } else {
              node.removeAttribute(attr);
            }
          }
        });
      }

      function handleAriaExpandedAttribute() {
        if (hasAriaExpanded || !instance.props.aria.expanded) {
          return;
        }

        var nodes = normalizeToArray(instance.props.triggerTarget || reference);
        nodes.forEach(function (node) {
          if (instance.props.interactive) {
            node.setAttribute('aria-expanded', instance.state.isVisible && node === getCurrentTarget() ? 'true' : 'false');
          } else {
            node.removeAttribute('aria-expanded');
          }
        });
      }

      function cleanupInteractiveMouseListeners() {
        getDocument().removeEventListener('mousemove', debouncedOnMouseMove);
        mouseMoveListeners = mouseMoveListeners.filter(function (listener) {
          return listener !== debouncedOnMouseMove;
        });
      }

      function onDocumentPress(event) {
        // Moved finger to scroll instead of an intentional tap outside
        if (currentInput.isTouch) {
          if (didTouchMove || event.type === 'mousedown') {
            return;
          }
        }

        var actualTarget = event.composedPath && event.composedPath()[0] || event.target; // Clicked on interactive popper

        if (instance.props.interactive && actualContains(popper, actualTarget)) {
          return;
        } // Clicked on the event listeners target


        if (normalizeToArray(instance.props.triggerTarget || reference).some(function (el) {
          return actualContains(el, actualTarget);
        })) {
          if (currentInput.isTouch) {
            return;
          }

          if (instance.state.isVisible && instance.props.trigger.indexOf('click') >= 0) {
            return;
          }
        } else {
          invokeHook('onClickOutside', [instance, event]);
        }

        if (instance.props.hideOnClick === true) {
          instance.clearDelayTimeouts();
          instance.hide(); // `mousedown` event is fired right before `focus` if pressing the
          // currentTarget. This lets a tippy with `focus` trigger know that it
          // should not show

          didHideDueToDocumentMouseDown = true;
          setTimeout(function () {
            didHideDueToDocumentMouseDown = false;
          }); // The listener gets added in `scheduleShow()`, but this may be hiding it
          // before it shows, and hide()'s early bail-out behavior can prevent it
          // from being cleaned up

          if (!instance.state.isMounted) {
            removeDocumentPress();
          }
        }
      }

      function onTouchMove() {
        didTouchMove = true;
      }

      function onTouchStart() {
        didTouchMove = false;
      }

      function addDocumentPress() {
        var doc = getDocument();
        doc.addEventListener('mousedown', onDocumentPress, true);
        doc.addEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);
        doc.addEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);
        doc.addEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);
      }

      function removeDocumentPress() {
        var doc = getDocument();
        doc.removeEventListener('mousedown', onDocumentPress, true);
        doc.removeEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);
        doc.removeEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);
        doc.removeEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);
      }

      function onTransitionedOut(duration, callback) {
        onTransitionEnd(duration, function () {
          if (!instance.state.isVisible && popper.parentNode && popper.parentNode.contains(popper)) {
            callback();
          }
        });
      }

      function onTransitionedIn(duration, callback) {
        onTransitionEnd(duration, callback);
      }

      function onTransitionEnd(duration, callback) {
        var box = getDefaultTemplateChildren().box;

        function listener(event) {
          if (event.target === box) {
            updateTransitionEndListener(box, 'remove', listener);
            callback();
          }
        } // Make callback synchronous if duration is 0
        // `transitionend` won't fire otherwise


        if (duration === 0) {
          return callback();
        }

        updateTransitionEndListener(box, 'remove', currentTransitionEndListener);
        updateTransitionEndListener(box, 'add', listener);
        currentTransitionEndListener = listener;
      }

      function on(eventType, handler, options) {
        if (options === void 0) {
          options = false;
        }

        var nodes = normalizeToArray(instance.props.triggerTarget || reference);
        nodes.forEach(function (node) {
          node.addEventListener(eventType, handler, options);
          listeners.push({
            node: node,
            eventType: eventType,
            handler: handler,
            options: options
          });
        });
      }

      function addListeners() {
        if (getIsCustomTouchBehavior()) {
          on('touchstart', onTrigger, {
            passive: true
          });
          on('touchend', onMouseLeave, {
            passive: true
          });
        }

        splitBySpaces(instance.props.trigger).forEach(function (eventType) {
          if (eventType === 'manual') {
            return;
          }

          on(eventType, onTrigger);

          switch (eventType) {
            case 'mouseenter':
              on('mouseleave', onMouseLeave);
              break;

            case 'focus':
              on(isIE11 ? 'focusout' : 'blur', onBlurOrFocusOut);
              break;

            case 'focusin':
              on('focusout', onBlurOrFocusOut);
              break;
          }
        });
      }

      function removeListeners() {
        listeners.forEach(function (_ref) {
          var node = _ref.node,
              eventType = _ref.eventType,
              handler = _ref.handler,
              options = _ref.options;
          node.removeEventListener(eventType, handler, options);
        });
        listeners = [];
      }

      function onTrigger(event) {
        var _lastTriggerEvent;

        var shouldScheduleClickHide = false;

        if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
          return;
        }

        var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === 'focus';
        lastTriggerEvent = event;
        currentTarget = event.currentTarget;
        handleAriaExpandedAttribute();

        if (!instance.state.isVisible && isMouseEvent(event)) {
          // If scrolling, `mouseenter` events can be fired if the cursor lands
          // over a new target, but `mousemove` events don't get fired. This
          // causes interactive tooltips to get stuck open until the cursor is
          // moved
          mouseMoveListeners.forEach(function (listener) {
            return listener(event);
          });
        } // Toggle show/hide when clicking click-triggered tooltips


        if (event.type === 'click' && (instance.props.trigger.indexOf('mouseenter') < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {
          shouldScheduleClickHide = true;
        } else {
          scheduleShow(event);
        }

        if (event.type === 'click') {
          isVisibleFromClick = !shouldScheduleClickHide;
        }

        if (shouldScheduleClickHide && !wasFocused) {
          scheduleHide(event);
        }
      }

      function onMouseMove(event) {
        var target = event.target;
        var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper.contains(target);

        if (event.type === 'mousemove' && isCursorOverReferenceOrPopper) {
          return;
        }

        var popperTreeData = getNestedPopperTree().concat(popper).map(function (popper) {
          var _instance$popperInsta;

          var instance = popper._tippy;
          var state = (_instance$popperInsta = instance.popperInstance) == null ? void 0 : _instance$popperInsta.state;

          if (state) {
            return {
              popperRect: popper.getBoundingClientRect(),
              popperState: state,
              props: props
            };
          }

          return null;
        }).filter(Boolean);

        if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
          cleanupInteractiveMouseListeners();
          scheduleHide(event);
        }
      }

      function onMouseLeave(event) {
        var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf('click') >= 0 && isVisibleFromClick;

        if (shouldBail) {
          return;
        }

        if (instance.props.interactive) {
          instance.hideWithInteractivity(event);
          return;
        }

        scheduleHide(event);
      }

      function onBlurOrFocusOut(event) {
        if (instance.props.trigger.indexOf('focusin') < 0 && event.target !== getCurrentTarget()) {
          return;
        } // If focus was moved to within the popper


        if (instance.props.interactive && event.relatedTarget && popper.contains(event.relatedTarget)) {
          return;
        }

        scheduleHide(event);
      }

      function isEventListenerStopped(event) {
        return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf('touch') >= 0 : false;
      }

      function createPopperInstance() {
        destroyPopperInstance();
        var _instance$props2 = instance.props,
            popperOptions = _instance$props2.popperOptions,
            placement = _instance$props2.placement,
            offset = _instance$props2.offset,
            getReferenceClientRect = _instance$props2.getReferenceClientRect,
            moveTransition = _instance$props2.moveTransition;
        var arrow = getIsDefaultRenderFn() ? getChildren(popper).arrow : null;
        var computedReference = getReferenceClientRect ? {
          getBoundingClientRect: getReferenceClientRect,
          contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
        } : reference;
        var tippyModifier = {
          name: '$$tippy',
          enabled: true,
          phase: 'beforeWrite',
          requires: ['computeStyles'],
          fn: function fn(_ref2) {
            var state = _ref2.state;

            if (getIsDefaultRenderFn()) {
              var _getDefaultTemplateCh = getDefaultTemplateChildren(),
                  box = _getDefaultTemplateCh.box;

              ['placement', 'reference-hidden', 'escaped'].forEach(function (attr) {
                if (attr === 'placement') {
                  box.setAttribute('data-placement', state.placement);
                } else {
                  if (state.attributes.popper["data-popper-" + attr]) {
                    box.setAttribute("data-" + attr, '');
                  } else {
                    box.removeAttribute("data-" + attr);
                  }
                }
              });
              state.attributes.popper = {};
            }
          }
        };
        var modifiers = [{
          name: 'offset',
          options: {
            offset: offset
          }
        }, {
          name: 'preventOverflow',
          options: {
            padding: {
              top: 2,
              bottom: 2,
              left: 5,
              right: 5
            }
          }
        }, {
          name: 'flip',
          options: {
            padding: 5
          }
        }, {
          name: 'computeStyles',
          options: {
            adaptive: !moveTransition
          }
        }, tippyModifier];

        if (getIsDefaultRenderFn() && arrow) {
          modifiers.push({
            name: 'arrow',
            options: {
              element: arrow,
              padding: 3
            }
          });
        }

        modifiers.push.apply(modifiers, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
        instance.popperInstance = createPopper(computedReference, popper, Object.assign({}, popperOptions, {
          placement: placement,
          onFirstUpdate: onFirstUpdate,
          modifiers: modifiers
        }));
      }

      function destroyPopperInstance() {
        if (instance.popperInstance) {
          instance.popperInstance.destroy();
          instance.popperInstance = null;
        }
      }

      function mount() {
        var appendTo = instance.props.appendTo;
        var parentNode; // By default, we'll append the popper to the triggerTargets's parentNode so
        // it's directly after the reference element so the elements inside the
        // tippy can be tabbed to
        // If there are clipping issues, the user can specify a different appendTo
        // and ensure focus management is handled correctly manually

        var node = getCurrentTarget();

        if (instance.props.interactive && appendTo === TIPPY_DEFAULT_APPEND_TO || appendTo === 'parent') {
          parentNode = node.parentNode;
        } else {
          parentNode = invokeWithArgsOrReturn(appendTo, [node]);
        } // The popper element needs to exist on the DOM before its position can be
        // updated as Popper needs to read its dimensions


        if (!parentNode.contains(popper)) {
          parentNode.appendChild(popper);
        }

        instance.state.isMounted = true;
        createPopperInstance();
      }

      function getNestedPopperTree() {
        return arrayFrom(popper.querySelectorAll('[data-tippy-root]'));
      }

      function scheduleShow(event) {
        instance.clearDelayTimeouts();

        if (event) {
          invokeHook('onTrigger', [instance, event]);
        }

        addDocumentPress();
        var delay = getDelay(true);

        var _getNormalizedTouchSe = getNormalizedTouchSettings(),
            touchValue = _getNormalizedTouchSe[0],
            touchDelay = _getNormalizedTouchSe[1];

        if (currentInput.isTouch && touchValue === 'hold' && touchDelay) {
          delay = touchDelay;
        }

        if (delay) {
          showTimeout = setTimeout(function () {
            instance.show();
          }, delay);
        } else {
          instance.show();
        }
      }

      function scheduleHide(event) {
        instance.clearDelayTimeouts();
        invokeHook('onUntrigger', [instance, event]);

        if (!instance.state.isVisible) {
          removeDocumentPress();
          return;
        } // For interactive tippies, scheduleHide is added to a document.body handler
        // from onMouseLeave so must intercept scheduled hides from mousemove/leave
        // events when trigger contains mouseenter and click, and the tip is
        // currently shown as a result of a click.


        if (instance.props.trigger.indexOf('mouseenter') >= 0 && instance.props.trigger.indexOf('click') >= 0 && ['mouseleave', 'mousemove'].indexOf(event.type) >= 0 && isVisibleFromClick) {
          return;
        }

        var delay = getDelay(false);

        if (delay) {
          hideTimeout = setTimeout(function () {
            if (instance.state.isVisible) {
              instance.hide();
            }
          }, delay);
        } else {
          // Fixes a `transitionend` problem when it fires 1 frame too
          // late sometimes, we don't want hide() to be called.
          scheduleHideAnimationFrame = requestAnimationFrame(function () {
            instance.hide();
          });
        }
      } // ===========================================================================
      // 🔑 Public methods
      // ===========================================================================


      function enable() {
        instance.state.isEnabled = true;
      }

      function disable() {
        // Disabling the instance should also hide it
        // https://github.com/atomiks/tippy.js-react/issues/106
        instance.hide();
        instance.state.isEnabled = false;
      }

      function clearDelayTimeouts() {
        clearTimeout(showTimeout);
        clearTimeout(hideTimeout);
        cancelAnimationFrame(scheduleHideAnimationFrame);
      }

      function setProps(partialProps) {

        if (instance.state.isDestroyed) {
          return;
        }

        invokeHook('onBeforeUpdate', [instance, partialProps]);
        removeListeners();
        var prevProps = instance.props;
        var nextProps = evaluateProps(reference, Object.assign({}, prevProps, removeUndefinedProps(partialProps), {
          ignoreAttributes: true
        }));
        instance.props = nextProps;
        addListeners();

        if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
          cleanupInteractiveMouseListeners();
          debouncedOnMouseMove = debounce(onMouseMove, nextProps.interactiveDebounce);
        } // Ensure stale aria-expanded attributes are removed


        if (prevProps.triggerTarget && !nextProps.triggerTarget) {
          normalizeToArray(prevProps.triggerTarget).forEach(function (node) {
            node.removeAttribute('aria-expanded');
          });
        } else if (nextProps.triggerTarget) {
          reference.removeAttribute('aria-expanded');
        }

        handleAriaExpandedAttribute();
        handleStyles();

        if (onUpdate) {
          onUpdate(prevProps, nextProps);
        }

        if (instance.popperInstance) {
          createPopperInstance(); // Fixes an issue with nested tippies if they are all getting re-rendered,
          // and the nested ones get re-rendered first.
          // https://github.com/atomiks/tippyjs-react/issues/177
          // TODO: find a cleaner / more efficient solution(!)

          getNestedPopperTree().forEach(function (nestedPopper) {
            // React (and other UI libs likely) requires a rAF wrapper as it flushes
            // its work in one
            requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
          });
        }

        invokeHook('onAfterUpdate', [instance, partialProps]);
      }

      function setContent(content) {
        instance.setProps({
          content: content
        });
      }

      function show() {


        var isAlreadyVisible = instance.state.isVisible;
        var isDestroyed = instance.state.isDestroyed;
        var isDisabled = !instance.state.isEnabled;
        var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;
        var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);

        if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
          return;
        } // Normalize `disabled` behavior across browsers.
        // Firefox allows events on disabled elements, but Chrome doesn't.
        // Using a wrapper element (i.e. <span>) is recommended.


        if (getCurrentTarget().hasAttribute('disabled')) {
          return;
        }

        invokeHook('onShow', [instance], false);

        if (instance.props.onShow(instance) === false) {
          return;
        }

        instance.state.isVisible = true;

        if (getIsDefaultRenderFn()) {
          popper.style.visibility = 'visible';
        }

        handleStyles();
        addDocumentPress();

        if (!instance.state.isMounted) {
          popper.style.transition = 'none';
        } // If flipping to the opposite side after hiding at least once, the
        // animation will use the wrong placement without resetting the duration


        if (getIsDefaultRenderFn()) {
          var _getDefaultTemplateCh2 = getDefaultTemplateChildren(),
              box = _getDefaultTemplateCh2.box,
              content = _getDefaultTemplateCh2.content;

          setTransitionDuration([box, content], 0);
        }

        onFirstUpdate = function onFirstUpdate() {
          var _instance$popperInsta2;

          if (!instance.state.isVisible || ignoreOnFirstUpdate) {
            return;
          }

          ignoreOnFirstUpdate = true; // reflow

          void popper.offsetHeight;
          popper.style.transition = instance.props.moveTransition;

          if (getIsDefaultRenderFn() && instance.props.animation) {
            var _getDefaultTemplateCh3 = getDefaultTemplateChildren(),
                _box = _getDefaultTemplateCh3.box,
                _content = _getDefaultTemplateCh3.content;

            setTransitionDuration([_box, _content], duration);
            setVisibilityState([_box, _content], 'visible');
          }

          handleAriaContentAttribute();
          handleAriaExpandedAttribute();
          pushIfUnique(mountedInstances, instance); // certain modifiers (e.g. `maxSize`) require a second update after the
          // popper has been positioned for the first time

          (_instance$popperInsta2 = instance.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();
          invokeHook('onMount', [instance]);

          if (instance.props.animation && getIsDefaultRenderFn()) {
            onTransitionedIn(duration, function () {
              instance.state.isShown = true;
              invokeHook('onShown', [instance]);
            });
          }
        };

        mount();
      }

      function hide() {


        var isAlreadyHidden = !instance.state.isVisible;
        var isDestroyed = instance.state.isDestroyed;
        var isDisabled = !instance.state.isEnabled;
        var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);

        if (isAlreadyHidden || isDestroyed || isDisabled) {
          return;
        }

        invokeHook('onHide', [instance], false);

        if (instance.props.onHide(instance) === false) {
          return;
        }

        instance.state.isVisible = false;
        instance.state.isShown = false;
        ignoreOnFirstUpdate = false;
        isVisibleFromClick = false;

        if (getIsDefaultRenderFn()) {
          popper.style.visibility = 'hidden';
        }

        cleanupInteractiveMouseListeners();
        removeDocumentPress();
        handleStyles(true);

        if (getIsDefaultRenderFn()) {
          var _getDefaultTemplateCh4 = getDefaultTemplateChildren(),
              box = _getDefaultTemplateCh4.box,
              content = _getDefaultTemplateCh4.content;

          if (instance.props.animation) {
            setTransitionDuration([box, content], duration);
            setVisibilityState([box, content], 'hidden');
          }
        }

        handleAriaContentAttribute();
        handleAriaExpandedAttribute();

        if (instance.props.animation) {
          if (getIsDefaultRenderFn()) {
            onTransitionedOut(duration, instance.unmount);
          }
        } else {
          instance.unmount();
        }
      }

      function hideWithInteractivity(event) {

        getDocument().addEventListener('mousemove', debouncedOnMouseMove);
        pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
        debouncedOnMouseMove(event);
      }

      function unmount() {

        if (instance.state.isVisible) {
          instance.hide();
        }

        if (!instance.state.isMounted) {
          return;
        }

        destroyPopperInstance(); // If a popper is not interactive, it will be appended outside the popper
        // tree by default. This seems mainly for interactive tippies, but we should
        // find a workaround if possible

        getNestedPopperTree().forEach(function (nestedPopper) {
          nestedPopper._tippy.unmount();
        });

        if (popper.parentNode) {
          popper.parentNode.removeChild(popper);
        }

        mountedInstances = mountedInstances.filter(function (i) {
          return i !== instance;
        });
        instance.state.isMounted = false;
        invokeHook('onHidden', [instance]);
      }

      function destroy() {

        if (instance.state.isDestroyed) {
          return;
        }

        instance.clearDelayTimeouts();
        instance.unmount();
        removeListeners();
        delete reference._tippy;
        instance.state.isDestroyed = true;
        invokeHook('onDestroy', [instance]);
      }
    }

    function tippy(targets, optionalProps) {
      if (optionalProps === void 0) {
        optionalProps = {};
      }

      var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);

      bindGlobalEventListeners();
      var passedProps = Object.assign({}, optionalProps, {
        plugins: plugins
      });
      var elements = getArrayOfElements(targets);

      var instances = elements.reduce(function (acc, reference) {
        var instance = reference && createTippy(reference, passedProps);

        if (instance) {
          acc.push(instance);
        }

        return acc;
      }, []);
      return isElement(targets) ? instances[0] : instances;
    }

    tippy.defaultProps = defaultProps;
    tippy.setDefaultProps = setDefaultProps;
    tippy.currentInput = currentInput;

    // every time the popper is destroyed (i.e. a new target), removing the styles
    // and causing transitions to break for singletons when the console is open, but
    // most notably for non-transform styles being used, `gpuAcceleration: false`.

    Object.assign({}, applyStyles$1, {
      effect: function effect(_ref) {
        var state = _ref.state;
        var initialStyles = {
          popper: {
            position: state.options.strategy,
            left: '0',
            top: '0',
            margin: '0'
          },
          arrow: {
            position: 'absolute'
          },
          reference: {}
        };
        Object.assign(state.elements.popper.style, initialStyles.popper);
        state.styles = initialStyles;

        if (state.elements.arrow) {
          Object.assign(state.elements.arrow.style, initialStyles.arrow);
        } // intentionally return no cleanup function
        // return () => { ... }

      }
    });

    tippy.setDefaultProps({
      render: render
    });

    /*! @license DOMPurify 2.3.12 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.12/LICENSE */

    var purify = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
      module.exports = factory() ;
    })(commonjsGlobal, (function () {
      function _typeof(obj) {
        "@babel/helpers - typeof";

        return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
          return typeof obj;
        } : function (obj) {
          return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        }, _typeof(obj);
      }

      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };

        return _setPrototypeOf(o, p);
      }

      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === "function") return true;

        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
          return true;
        } catch (e) {
          return false;
        }
      }

      function _construct(Parent, args, Class) {
        if (_isNativeReflectConstruct()) {
          _construct = Reflect.construct;
        } else {
          _construct = function _construct(Parent, args, Class) {
            var a = [null];
            a.push.apply(a, args);
            var Constructor = Function.bind.apply(Parent, a);
            var instance = new Constructor();
            if (Class) _setPrototypeOf(instance, Class.prototype);
            return instance;
          };
        }

        return _construct.apply(null, arguments);
      }

      function _toConsumableArray(arr) {
        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
      }

      function _arrayWithoutHoles(arr) {
        if (Array.isArray(arr)) return _arrayLikeToArray(arr);
      }

      function _iterableToArray(iter) {
        if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
      }

      function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
      }

      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;

        for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

        return arr2;
      }

      function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }

      var hasOwnProperty = Object.hasOwnProperty,
          setPrototypeOf = Object.setPrototypeOf,
          isFrozen = Object.isFrozen,
          getPrototypeOf = Object.getPrototypeOf,
          getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      var freeze = Object.freeze,
          seal = Object.seal,
          create = Object.create; // eslint-disable-line import/no-mutable-exports

      var _ref = typeof Reflect !== 'undefined' && Reflect,
          apply = _ref.apply,
          construct = _ref.construct;

      if (!apply) {
        apply = function apply(fun, thisValue, args) {
          return fun.apply(thisValue, args);
        };
      }

      if (!freeze) {
        freeze = function freeze(x) {
          return x;
        };
      }

      if (!seal) {
        seal = function seal(x) {
          return x;
        };
      }

      if (!construct) {
        construct = function construct(Func, args) {
          return _construct(Func, _toConsumableArray(args));
        };
      }

      var arrayForEach = unapply(Array.prototype.forEach);
      var arrayPop = unapply(Array.prototype.pop);
      var arrayPush = unapply(Array.prototype.push);
      var stringToLowerCase = unapply(String.prototype.toLowerCase);
      var stringMatch = unapply(String.prototype.match);
      var stringReplace = unapply(String.prototype.replace);
      var stringIndexOf = unapply(String.prototype.indexOf);
      var stringTrim = unapply(String.prototype.trim);
      var regExpTest = unapply(RegExp.prototype.test);
      var typeErrorCreate = unconstruct(TypeError);
      function unapply(func) {
        return function (thisArg) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          return apply(func, thisArg, args);
        };
      }
      function unconstruct(func) {
        return function () {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          return construct(func, args);
        };
      }
      /* Add properties to a lookup table */

      function addToSet(set, array, transformCaseFunc) {
        transformCaseFunc = transformCaseFunc ? transformCaseFunc : stringToLowerCase;

        if (setPrototypeOf) {
          // Make 'in' and truthy checks like Boolean(set.constructor)
          // independent of any properties defined on Object.prototype.
          // Prevent prototype setters from intercepting set as a this value.
          setPrototypeOf(set, null);
        }

        var l = array.length;

        while (l--) {
          var element = array[l];

          if (typeof element === 'string') {
            var lcElement = transformCaseFunc(element);

            if (lcElement !== element) {
              // Config presets (e.g. tags.js, attrs.js) are immutable.
              if (!isFrozen(array)) {
                array[l] = lcElement;
              }

              element = lcElement;
            }
          }

          set[element] = true;
        }

        return set;
      }
      /* Shallow clone an object */

      function clone(object) {
        var newObject = create(null);
        var property;

        for (property in object) {
          if (apply(hasOwnProperty, object, [property])) {
            newObject[property] = object[property];
          }
        }

        return newObject;
      }
      /* IE10 doesn't support __lookupGetter__ so lets'
       * simulate it. It also automatically checks
       * if the prop is function or getter and behaves
       * accordingly. */

      function lookupGetter(object, prop) {
        while (object !== null) {
          var desc = getOwnPropertyDescriptor(object, prop);

          if (desc) {
            if (desc.get) {
              return unapply(desc.get);
            }

            if (typeof desc.value === 'function') {
              return unapply(desc.value);
            }
          }

          object = getPrototypeOf(object);
        }

        function fallbackValue(element) {
          console.warn('fallback value for', element);
          return null;
        }

        return fallbackValue;
      }

      var html$1 = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']); // SVG

      var svg$1 = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);
      var svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']); // List of SVG elements that are disallowed by default.
      // We still need to know them so that we can do namespace
      // checks properly in case one wants to add them to
      // allow-list.

      var svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'fedropshadow', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);
      var mathMl$1 = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover']); // Similarly to SVG, we want to know all MathML elements,
      // even those that we disallow by default.

      var mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);
      var text = freeze(['#text']);

      var html = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'nonce', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', 'slot']);
      var svg = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'transform-origin', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);
      var mathMl = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);
      var xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);

      var MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode

      var ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
      var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/); // eslint-disable-line no-useless-escape

      var ARIA_ATTR = seal(/^aria-[\-\w]+$/); // eslint-disable-line no-useless-escape

      var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i // eslint-disable-line no-useless-escape
      );
      var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
      var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g // eslint-disable-line no-control-regex
      );
      var DOCTYPE_NAME = seal(/^html$/i);

      var getGlobal = function getGlobal() {
        return typeof window === 'undefined' ? null : window;
      };
      /**
       * Creates a no-op policy for internal use only.
       * Don't export this function outside this module!
       * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.
       * @param {Document} document The document object (to determine policy name suffix)
       * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types
       * are not supported).
       */


      var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {
        if (_typeof(trustedTypes) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {
          return null;
        } // Allow the callers to control the unique policy name
        // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
        // Policy creation with duplicate names throws in Trusted Types.


        var suffix = null;
        var ATTR_NAME = 'data-tt-policy-suffix';

        if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {
          suffix = document.currentScript.getAttribute(ATTR_NAME);
        }

        var policyName = 'dompurify' + (suffix ? '#' + suffix : '');

        try {
          return trustedTypes.createPolicy(policyName, {
            createHTML: function createHTML(html) {
              return html;
            },
            createScriptURL: function createScriptURL(scriptUrl) {
              return scriptUrl;
            }
          });
        } catch (_) {
          // Policy creation failed (most likely another DOMPurify script has
          // already run). Skip creating the policy, as this will only cause errors
          // if TT are enforced.
          console.warn('TrustedTypes policy ' + policyName + ' could not be created.');
          return null;
        }
      };

      function createDOMPurify() {
        var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();

        var DOMPurify = function DOMPurify(root) {
          return createDOMPurify(root);
        };
        /**
         * Version label, exposed for easier checks
         * if DOMPurify is up to date or not
         */


        DOMPurify.version = '2.3.12';
        /**
         * Array of elements that DOMPurify removed during sanitation.
         * Empty if nothing was removed.
         */

        DOMPurify.removed = [];

        if (!window || !window.document || window.document.nodeType !== 9) {
          // Not running in a browser, provide a factory function
          // so that you can pass your own Window
          DOMPurify.isSupported = false;
          return DOMPurify;
        }

        var originalDocument = window.document;
        var document = window.document;
        var DocumentFragment = window.DocumentFragment,
            HTMLTemplateElement = window.HTMLTemplateElement,
            Node = window.Node,
            Element = window.Element,
            NodeFilter = window.NodeFilter,
            _window$NamedNodeMap = window.NamedNodeMap,
            NamedNodeMap = _window$NamedNodeMap === void 0 ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,
            HTMLFormElement = window.HTMLFormElement,
            DOMParser = window.DOMParser,
            trustedTypes = window.trustedTypes;
        var ElementPrototype = Element.prototype;
        var cloneNode = lookupGetter(ElementPrototype, 'cloneNode');
        var getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');
        var getChildNodes = lookupGetter(ElementPrototype, 'childNodes');
        var getParentNode = lookupGetter(ElementPrototype, 'parentNode'); // As per issue #47, the web-components registry is inherited by a
        // new document created via createHTMLDocument. As per the spec
        // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
        // a new empty registry is used when creating a template contents owner
        // document, so we use that as our parent document to ensure nothing
        // is inherited.

        if (typeof HTMLTemplateElement === 'function') {
          var template = document.createElement('template');

          if (template.content && template.content.ownerDocument) {
            document = template.content.ownerDocument;
          }
        }

        var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);

        var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML('') : '';
        var _document = document,
            implementation = _document.implementation,
            createNodeIterator = _document.createNodeIterator,
            createDocumentFragment = _document.createDocumentFragment,
            getElementsByTagName = _document.getElementsByTagName;
        var importNode = originalDocument.importNode;
        var documentMode = {};

        try {
          documentMode = clone(document).documentMode ? document.documentMode : {};
        } catch (_) {}

        var hooks = {};
        /**
         * Expose whether this browser supports running the full DOMPurify.
         */

        DOMPurify.isSupported = typeof getParentNode === 'function' && implementation && typeof implementation.createHTMLDocument !== 'undefined' && documentMode !== 9;
        var MUSTACHE_EXPR$1 = MUSTACHE_EXPR,
            ERB_EXPR$1 = ERB_EXPR,
            DATA_ATTR$1 = DATA_ATTR,
            ARIA_ATTR$1 = ARIA_ATTR,
            IS_SCRIPT_OR_DATA$1 = IS_SCRIPT_OR_DATA,
            ATTR_WHITESPACE$1 = ATTR_WHITESPACE;
        var IS_ALLOWED_URI$1 = IS_ALLOWED_URI;
        /**
         * We consider the elements and attributes below to be safe. Ideally
         * don't add any new ones but feel free to remove unwanted ones.
         */

        /* allowed element names */

        var ALLOWED_TAGS = null;
        var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(html$1), _toConsumableArray(svg$1), _toConsumableArray(svgFilters), _toConsumableArray(mathMl$1), _toConsumableArray(text)));
        /* Allowed attribute names */

        var ALLOWED_ATTR = null;
        var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray(html), _toConsumableArray(svg), _toConsumableArray(mathMl), _toConsumableArray(xml)));
        /*
         * Configure how DOMPUrify should handle custom elements and their attributes as well as customized built-in elements.
         * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)
         * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)
         * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.
         */

        var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
          tagNameCheck: {
            writable: true,
            configurable: false,
            enumerable: true,
            value: null
          },
          attributeNameCheck: {
            writable: true,
            configurable: false,
            enumerable: true,
            value: null
          },
          allowCustomizedBuiltInElements: {
            writable: true,
            configurable: false,
            enumerable: true,
            value: false
          }
        }));
        /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */

        var FORBID_TAGS = null;
        /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */

        var FORBID_ATTR = null;
        /* Decide if ARIA attributes are okay */

        var ALLOW_ARIA_ATTR = true;
        /* Decide if custom data attributes are okay */

        var ALLOW_DATA_ATTR = true;
        /* Decide if unknown protocols are okay */

        var ALLOW_UNKNOWN_PROTOCOLS = false;
        /* Output should be safe for common template engines.
         * This means, DOMPurify removes data attributes, mustaches and ERB
         */

        var SAFE_FOR_TEMPLATES = false;
        /* Decide if document with <html>... should be returned */

        var WHOLE_DOCUMENT = false;
        /* Track whether config is already set on this instance of DOMPurify. */

        var SET_CONFIG = false;
        /* Decide if all elements (e.g. style, script) must be children of
         * document.body. By default, browsers might move them to document.head */

        var FORCE_BODY = false;
        /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html
         * string (or a TrustedHTML object if Trusted Types are supported).
         * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
         */

        var RETURN_DOM = false;
        /* Decide if a DOM `DocumentFragment` should be returned, instead of a html
         * string  (or a TrustedHTML object if Trusted Types are supported) */

        var RETURN_DOM_FRAGMENT = false;
        /* Try to return a Trusted Type object instead of a string, return a string in
         * case Trusted Types are not supported  */

        var RETURN_TRUSTED_TYPE = false;
        /* Output should be free from DOM clobbering attacks?
         * This sanitizes markups named with colliding, clobberable built-in DOM APIs.
         */

        var SANITIZE_DOM = true;
        /* Achieve full DOM Clobbering protection by isolating the namespace of named
         * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.
         *
         * HTML/DOM spec rules that enable DOM Clobbering:
         *   - Named Access on Window (§7.3.3)
         *   - DOM Tree Accessors (§3.1.5)
         *   - Form Element Parent-Child Relations (§4.10.3)
         *   - Iframe srcdoc / Nested WindowProxies (§4.8.5)
         *   - HTMLCollection (§4.2.10.2)
         *
         * Namespace isolation is implemented by prefixing `id` and `name` attributes
         * with a constant string, i.e., `user-content-`
         */

        var SANITIZE_NAMED_PROPS = false;
        var SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';
        /* Keep element content when removing element? */

        var KEEP_CONTENT = true;
        /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead
         * of importing it into a new Document and returning a sanitized copy */

        var IN_PLACE = false;
        /* Allow usage of profiles like html, svg and mathMl */

        var USE_PROFILES = {};
        /* Tags to ignore content of when KEEP_CONTENT is true */

        var FORBID_CONTENTS = null;
        var DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);
        /* Tags that are safe for data: URIs */

        var DATA_URI_TAGS = null;
        var DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);
        /* Attributes safe for values like "javascript:" */

        var URI_SAFE_ATTRIBUTES = null;
        var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);
        var MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
        var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
        var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
        /* Document namespace */

        var NAMESPACE = HTML_NAMESPACE;
        var IS_EMPTY_INPUT = false;
        /* Parsing of strict XHTML documents */

        var PARSER_MEDIA_TYPE;
        var SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];
        var DEFAULT_PARSER_MEDIA_TYPE = 'text/html';
        var transformCaseFunc;
        /* Keep a reference to config to pass to hooks */

        var CONFIG = null;
        /* Ideally, do not touch anything below this line */

        /* ______________________________________________ */

        var formElement = document.createElement('form');

        var isRegexOrFunction = function isRegexOrFunction(testValue) {
          return testValue instanceof RegExp || testValue instanceof Function;
        };
        /**
         * _parseConfig
         *
         * @param  {Object} cfg optional config literal
         */
        // eslint-disable-next-line complexity


        var _parseConfig = function _parseConfig(cfg) {
          if (CONFIG && CONFIG === cfg) {
            return;
          }
          /* Shield configuration object from tampering */


          if (!cfg || _typeof(cfg) !== 'object') {
            cfg = {};
          }
          /* Shield configuration object from prototype pollution */


          cfg = clone(cfg);
          PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
          SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE; // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.

          transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? function (x) {
            return x;
          } : stringToLowerCase;
          /* Set configuration parameters */

          ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
          ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
          URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), // eslint-disable-line indent
          cfg.ADD_URI_SAFE_ATTR, // eslint-disable-line indent
          transformCaseFunc // eslint-disable-line indent
          ) // eslint-disable-line indent
          : DEFAULT_URI_SAFE_ATTRIBUTES;
          DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), // eslint-disable-line indent
          cfg.ADD_DATA_URI_TAGS, // eslint-disable-line indent
          transformCaseFunc // eslint-disable-line indent
          ) // eslint-disable-line indent
          : DEFAULT_DATA_URI_TAGS;
          FORBID_CONTENTS = 'FORBID_CONTENTS' in cfg ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
          FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
          FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
          USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;
          ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true

          ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true

          ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false

          SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false

          WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false

          RETURN_DOM = cfg.RETURN_DOM || false; // Default false

          RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false

          RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false

          FORCE_BODY = cfg.FORCE_BODY || false; // Default false

          SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true

          SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false

          KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true

          IN_PLACE = cfg.IN_PLACE || false; // Default false

          IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$1;
          NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;

          if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
            CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
          }

          if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
            CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
          }

          if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {
            CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
          }

          if (SAFE_FOR_TEMPLATES) {
            ALLOW_DATA_ATTR = false;
          }

          if (RETURN_DOM_FRAGMENT) {
            RETURN_DOM = true;
          }
          /* Parse profile info */


          if (USE_PROFILES) {
            ALLOWED_TAGS = addToSet({}, _toConsumableArray(text));
            ALLOWED_ATTR = [];

            if (USE_PROFILES.html === true) {
              addToSet(ALLOWED_TAGS, html$1);
              addToSet(ALLOWED_ATTR, html);
            }

            if (USE_PROFILES.svg === true) {
              addToSet(ALLOWED_TAGS, svg$1);
              addToSet(ALLOWED_ATTR, svg);
              addToSet(ALLOWED_ATTR, xml);
            }

            if (USE_PROFILES.svgFilters === true) {
              addToSet(ALLOWED_TAGS, svgFilters);
              addToSet(ALLOWED_ATTR, svg);
              addToSet(ALLOWED_ATTR, xml);
            }

            if (USE_PROFILES.mathMl === true) {
              addToSet(ALLOWED_TAGS, mathMl$1);
              addToSet(ALLOWED_ATTR, mathMl);
              addToSet(ALLOWED_ATTR, xml);
            }
          }
          /* Merge configuration parameters */


          if (cfg.ADD_TAGS) {
            if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
              ALLOWED_TAGS = clone(ALLOWED_TAGS);
            }

            addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
          }

          if (cfg.ADD_ATTR) {
            if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
              ALLOWED_ATTR = clone(ALLOWED_ATTR);
            }

            addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
          }

          if (cfg.ADD_URI_SAFE_ATTR) {
            addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
          }

          if (cfg.FORBID_CONTENTS) {
            if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
              FORBID_CONTENTS = clone(FORBID_CONTENTS);
            }

            addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
          }
          /* Add #text in case KEEP_CONTENT is set to true */


          if (KEEP_CONTENT) {
            ALLOWED_TAGS['#text'] = true;
          }
          /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */


          if (WHOLE_DOCUMENT) {
            addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);
          }
          /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */


          if (ALLOWED_TAGS.table) {
            addToSet(ALLOWED_TAGS, ['tbody']);
            delete FORBID_TAGS.tbody;
          } // Prevent further manipulation of configuration.
          // Not available in IE8, Safari 5, etc.


          if (freeze) {
            freeze(cfg);
          }

          CONFIG = cfg;
        };

        var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);
        var HTML_INTEGRATION_POINTS = addToSet({}, ['foreignobject', 'desc', 'title', 'annotation-xml']); // Certain elements are allowed in both SVG and HTML
        // namespace. We need to specify them explicitly
        // so that they don't get erroneously deleted from
        // HTML namespace.

        var COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ['title', 'style', 'font', 'a', 'script']);
        /* Keep track of all possible SVG and MathML tags
         * so that we can perform the namespace checks
         * correctly. */

        var ALL_SVG_TAGS = addToSet({}, svg$1);
        addToSet(ALL_SVG_TAGS, svgFilters);
        addToSet(ALL_SVG_TAGS, svgDisallowed);
        var ALL_MATHML_TAGS = addToSet({}, mathMl$1);
        addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
        /**
         *
         *
         * @param  {Element} element a DOM element whose namespace is being checked
         * @returns {boolean} Return false if the element has a
         *  namespace that a spec-compliant parser would never
         *  return. Return true otherwise.
         */

        var _checkValidNamespace = function _checkValidNamespace(element) {
          var parent = getParentNode(element); // In JSDOM, if we're inside shadow DOM, then parentNode
          // can be null. We just simulate parent in this case.

          if (!parent || !parent.tagName) {
            parent = {
              namespaceURI: HTML_NAMESPACE,
              tagName: 'template'
            };
          }

          var tagName = stringToLowerCase(element.tagName);
          var parentTagName = stringToLowerCase(parent.tagName);

          if (element.namespaceURI === SVG_NAMESPACE) {
            // The only way to switch from HTML namespace to SVG
            // is via <svg>. If it happens via any other tag, then
            // it should be killed.
            if (parent.namespaceURI === HTML_NAMESPACE) {
              return tagName === 'svg';
            } // The only way to switch from MathML to SVG is via
            // svg if parent is either <annotation-xml> or MathML
            // text integration points.


            if (parent.namespaceURI === MATHML_NAMESPACE) {
              return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
            } // We only allow elements that are defined in SVG
            // spec. All others are disallowed in SVG namespace.


            return Boolean(ALL_SVG_TAGS[tagName]);
          }

          if (element.namespaceURI === MATHML_NAMESPACE) {
            // The only way to switch from HTML namespace to MathML
            // is via <math>. If it happens via any other tag, then
            // it should be killed.
            if (parent.namespaceURI === HTML_NAMESPACE) {
              return tagName === 'math';
            } // The only way to switch from SVG to MathML is via
            // <math> and HTML integration points


            if (parent.namespaceURI === SVG_NAMESPACE) {
              return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];
            } // We only allow elements that are defined in MathML
            // spec. All others are disallowed in MathML namespace.


            return Boolean(ALL_MATHML_TAGS[tagName]);
          }

          if (element.namespaceURI === HTML_NAMESPACE) {
            // The only way to switch from SVG to HTML is via
            // HTML integration points, and from MathML to HTML
            // is via MathML text integration points
            if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
              return false;
            }

            if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
              return false;
            } // We disallow tags that are specific for MathML
            // or SVG and should never appear in HTML namespace


            return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
          } // The code should never reach this place (this means
          // that the element somehow got namespace that is not
          // HTML, SVG or MathML). Return false just in case.


          return false;
        };
        /**
         * _forceRemove
         *
         * @param  {Node} node a DOM node
         */


        var _forceRemove = function _forceRemove(node) {
          arrayPush(DOMPurify.removed, {
            element: node
          });

          try {
            // eslint-disable-next-line unicorn/prefer-dom-node-remove
            node.parentNode.removeChild(node);
          } catch (_) {
            try {
              node.outerHTML = emptyHTML;
            } catch (_) {
              node.remove();
            }
          }
        };
        /**
         * _removeAttribute
         *
         * @param  {String} name an Attribute name
         * @param  {Node} node a DOM node
         */


        var _removeAttribute = function _removeAttribute(name, node) {
          try {
            arrayPush(DOMPurify.removed, {
              attribute: node.getAttributeNode(name),
              from: node
            });
          } catch (_) {
            arrayPush(DOMPurify.removed, {
              attribute: null,
              from: node
            });
          }

          node.removeAttribute(name); // We void attribute values for unremovable "is"" attributes

          if (name === 'is' && !ALLOWED_ATTR[name]) {
            if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
              try {
                _forceRemove(node);
              } catch (_) {}
            } else {
              try {
                node.setAttribute(name, '');
              } catch (_) {}
            }
          }
        };
        /**
         * _initDocument
         *
         * @param  {String} dirty a string of dirty markup
         * @return {Document} a DOM, filled with the dirty markup
         */


        var _initDocument = function _initDocument(dirty) {
          /* Create a HTML document */
          var doc;
          var leadingWhitespace;

          if (FORCE_BODY) {
            dirty = '<remove></remove>' + dirty;
          } else {
            /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
            var matches = stringMatch(dirty, /^[\r\n\t ]+/);
            leadingWhitespace = matches && matches[0];
          }

          if (PARSER_MEDIA_TYPE === 'application/xhtml+xml') {
            // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)
            dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + '</body></html>';
          }

          var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
          /*
           * Use the DOMParser API by default, fallback later if needs be
           * DOMParser not work for svg when has multiple root element.
           */

          if (NAMESPACE === HTML_NAMESPACE) {
            try {
              doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
            } catch (_) {}
          }
          /* Use createHTMLDocument in case DOMParser is not available */


          if (!doc || !doc.documentElement) {
            doc = implementation.createDocument(NAMESPACE, 'template', null);

            try {
              doc.documentElement.innerHTML = IS_EMPTY_INPUT ? '' : dirtyPayload;
            } catch (_) {// Syntax error if dirtyPayload is invalid xml
            }
          }

          var body = doc.body || doc.documentElement;

          if (dirty && leadingWhitespace) {
            body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);
          }
          /* Work on whole document or just its body */


          if (NAMESPACE === HTML_NAMESPACE) {
            return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
          }

          return WHOLE_DOCUMENT ? doc.documentElement : body;
        };
        /**
         * _createIterator
         *
         * @param  {Document} root document/fragment to create iterator for
         * @return {Iterator} iterator instance
         */


        var _createIterator = function _createIterator(root) {
          return createNodeIterator.call(root.ownerDocument || root, root, // eslint-disable-next-line no-bitwise
          NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);
        };
        /**
         * _isClobbered
         *
         * @param  {Node} elm element to check for clobbering attacks
         * @return {Boolean} true if clobbered, false if safe
         */


        var _isClobbered = function _isClobbered(elm) {
          return elm instanceof HTMLFormElement && (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function');
        };
        /**
         * _isNode
         *
         * @param  {Node} obj object to check whether it's a DOM node
         * @return {Boolean} true is object is a DOM node
         */


        var _isNode = function _isNode(object) {
          return _typeof(Node) === 'object' ? object instanceof Node : object && _typeof(object) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';
        };
        /**
         * _executeHook
         * Execute user configurable hooks
         *
         * @param  {String} entryPoint  Name of the hook's entry point
         * @param  {Node} currentNode node to work on with the hook
         * @param  {Object} data additional hook parameters
         */


        var _executeHook = function _executeHook(entryPoint, currentNode, data) {
          if (!hooks[entryPoint]) {
            return;
          }

          arrayForEach(hooks[entryPoint], function (hook) {
            hook.call(DOMPurify, currentNode, data, CONFIG);
          });
        };
        /**
         * _sanitizeElements
         *
         * @protect nodeName
         * @protect textContent
         * @protect removeChild
         *
         * @param   {Node} currentNode to check for permission to exist
         * @return  {Boolean} true if node was killed, false if left alive
         */


        var _sanitizeElements = function _sanitizeElements(currentNode) {
          var content;
          /* Execute a hook if present */

          _executeHook('beforeSanitizeElements', currentNode, null);
          /* Check if element is clobbered or can clobber */


          if (_isClobbered(currentNode)) {
            _forceRemove(currentNode);

            return true;
          }
          /* Check if tagname contains Unicode */


          if (regExpTest(/[\u0080-\uFFFF]/, currentNode.nodeName)) {
            _forceRemove(currentNode);

            return true;
          }
          /* Now let's check the element's type and name */


          var tagName = transformCaseFunc(currentNode.nodeName);
          /* Execute a hook if present */

          _executeHook('uponSanitizeElement', currentNode, {
            tagName: tagName,
            allowedTags: ALLOWED_TAGS
          });
          /* Detect mXSS attempts abusing namespace confusion */


          if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
            _forceRemove(currentNode);

            return true;
          }
          /* Mitigate a problem with templates inside select */


          if (tagName === 'select' && regExpTest(/<template/i, currentNode.innerHTML)) {
            _forceRemove(currentNode);

            return true;
          }
          /* Remove element if anything forbids its presence */


          if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
            /* Check if we have a custom element to handle */
            if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
              if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) return false;
              if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) return false;
            }
            /* Keep content except for bad-listed elements */


            if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
              var parentNode = getParentNode(currentNode) || currentNode.parentNode;
              var childNodes = getChildNodes(currentNode) || currentNode.childNodes;

              if (childNodes && parentNode) {
                var childCount = childNodes.length;

                for (var i = childCount - 1; i >= 0; --i) {
                  parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
                }
              }
            }

            _forceRemove(currentNode);

            return true;
          }
          /* Check whether element has a valid namespace */


          if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
            _forceRemove(currentNode);

            return true;
          }

          if ((tagName === 'noscript' || tagName === 'noembed') && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
            _forceRemove(currentNode);

            return true;
          }
          /* Sanitize element content to be template-safe */


          if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
            /* Get the element's text content */
            content = currentNode.textContent;
            content = stringReplace(content, MUSTACHE_EXPR$1, ' ');
            content = stringReplace(content, ERB_EXPR$1, ' ');

            if (currentNode.textContent !== content) {
              arrayPush(DOMPurify.removed, {
                element: currentNode.cloneNode()
              });
              currentNode.textContent = content;
            }
          }
          /* Execute a hook if present */


          _executeHook('afterSanitizeElements', currentNode, null);

          return false;
        };
        /**
         * _isValidAttribute
         *
         * @param  {string} lcTag Lowercase tag name of containing element.
         * @param  {string} lcName Lowercase attribute name.
         * @param  {string} value Attribute value.
         * @return {Boolean} Returns true if `value` is valid, otherwise false.
         */
        // eslint-disable-next-line complexity


        var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
          /* Make sure attribute cannot clobber */
          if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
            return false;
          }
          /* Allow valid data-* attributes: At least one character after "-"
              (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
              XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
              We don't need to check the value; it's always URI safe. */


          if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$1, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$1, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
            if ( // First condition does a very basic check if a) it's basically a valid custom element tagname AND
            // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
            _basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || // Alternative, second condition checks if it's an `is`-attribute, AND
            // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ; else {
              return false;
            }
            /* Check value is safe. First, is attr inert? If so, is safe */

          } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE$1, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$1, stringReplace(value, ATTR_WHITESPACE$1, ''))) ; else if (!value) ; else {
            return false;
          }

          return true;
        };
        /**
         * _basicCustomElementCheck
         * checks if at least one dash is included in tagName, and it's not the first char
         * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name
         * @param {string} tagName name of the tag of the node to sanitize
         */


        var _basicCustomElementTest = function _basicCustomElementTest(tagName) {
          return tagName.indexOf('-') > 0;
        };
        /**
         * _sanitizeAttributes
         *
         * @protect attributes
         * @protect nodeName
         * @protect removeAttribute
         * @protect setAttribute
         *
         * @param  {Node} currentNode to sanitize
         */


        var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
          var attr;
          var value;
          var lcName;
          var l;
          /* Execute a hook if present */

          _executeHook('beforeSanitizeAttributes', currentNode, null);

          var attributes = currentNode.attributes;
          /* Check if we have attributes; if not we might have a text node */

          if (!attributes) {
            return;
          }

          var hookEvent = {
            attrName: '',
            attrValue: '',
            keepAttr: true,
            allowedAttributes: ALLOWED_ATTR
          };
          l = attributes.length;
          /* Go backwards over all attributes; safely remove bad ones */

          while (l--) {
            attr = attributes[l];
            var _attr = attr,
                name = _attr.name,
                namespaceURI = _attr.namespaceURI;
            value = name === 'value' ? attr.value : stringTrim(attr.value);
            lcName = transformCaseFunc(name);
            /* Execute a hook if present */

            hookEvent.attrName = lcName;
            hookEvent.attrValue = value;
            hookEvent.keepAttr = true;
            hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set

            _executeHook('uponSanitizeAttribute', currentNode, hookEvent);

            value = hookEvent.attrValue;
            /* Did the hooks approve of the attribute? */

            if (hookEvent.forceKeepAttr) {
              continue;
            }
            /* Remove attribute */


            _removeAttribute(name, currentNode);
            /* Did the hooks approve of the attribute? */


            if (!hookEvent.keepAttr) {
              continue;
            }
            /* Work around a security issue in jQuery 3.0 */


            if (regExpTest(/\/>/i, value)) {
              _removeAttribute(name, currentNode);

              continue;
            }
            /* Sanitize attribute content to be template-safe */


            if (SAFE_FOR_TEMPLATES) {
              value = stringReplace(value, MUSTACHE_EXPR$1, ' ');
              value = stringReplace(value, ERB_EXPR$1, ' ');
            }
            /* Is `value` valid for this attribute? */


            var lcTag = transformCaseFunc(currentNode.nodeName);

            if (!_isValidAttribute(lcTag, lcName, value)) {
              continue;
            }
            /* Full DOM Clobbering protection via namespace isolation,
             * Prefix id and name attributes with `user-content-`
             */


            if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {
              // Remove the attribute with this value
              _removeAttribute(name, currentNode); // Prefix the value and later re-create the attribute with the sanitized value


              value = SANITIZE_NAMED_PROPS_PREFIX + value;
            }
            /* Handle attributes that require Trusted Types */


            if (trustedTypesPolicy && _typeof(trustedTypes) === 'object' && typeof trustedTypes.getAttributeType === 'function') {
              if (namespaceURI) ; else {
                switch (trustedTypes.getAttributeType(lcTag, lcName)) {
                  case 'TrustedHTML':
                    value = trustedTypesPolicy.createHTML(value);
                    break;

                  case 'TrustedScriptURL':
                    value = trustedTypesPolicy.createScriptURL(value);
                    break;
                }
              }
            }
            /* Handle invalid data-* attribute set by try-catching it */


            try {
              if (namespaceURI) {
                currentNode.setAttributeNS(namespaceURI, name, value);
              } else {
                /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
                currentNode.setAttribute(name, value);
              }

              arrayPop(DOMPurify.removed);
            } catch (_) {}
          }
          /* Execute a hook if present */


          _executeHook('afterSanitizeAttributes', currentNode, null);
        };
        /**
         * _sanitizeShadowDOM
         *
         * @param  {DocumentFragment} fragment to iterate over recursively
         */


        var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
          var shadowNode;

          var shadowIterator = _createIterator(fragment);
          /* Execute a hook if present */


          _executeHook('beforeSanitizeShadowDOM', fragment, null);

          while (shadowNode = shadowIterator.nextNode()) {
            /* Execute a hook if present */
            _executeHook('uponSanitizeShadowNode', shadowNode, null);
            /* Sanitize tags and elements */


            if (_sanitizeElements(shadowNode)) {
              continue;
            }
            /* Deep shadow DOM detected */


            if (shadowNode.content instanceof DocumentFragment) {
              _sanitizeShadowDOM(shadowNode.content);
            }
            /* Check attributes, sanitize if necessary */


            _sanitizeAttributes(shadowNode);
          }
          /* Execute a hook if present */


          _executeHook('afterSanitizeShadowDOM', fragment, null);
        };
        /**
         * Sanitize
         * Public method providing core sanitation functionality
         *
         * @param {String|Node} dirty string or DOM node
         * @param {Object} configuration object
         */
        // eslint-disable-next-line complexity


        DOMPurify.sanitize = function (dirty) {
          var cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          var body;
          var importedNode;
          var currentNode;
          var oldNode;
          var returnNode;
          /* Make sure we have a string to sanitize.
            DO NOT return early, as this will return the wrong type if
            the user has requested a DOM object rather than a string */

          IS_EMPTY_INPUT = !dirty;

          if (IS_EMPTY_INPUT) {
            dirty = '<!-->';
          }
          /* Stringify, in case dirty is an object */


          if (typeof dirty !== 'string' && !_isNode(dirty)) {
            // eslint-disable-next-line no-negated-condition
            if (typeof dirty.toString !== 'function') {
              throw typeErrorCreate('toString is not a function');
            } else {
              dirty = dirty.toString();

              if (typeof dirty !== 'string') {
                throw typeErrorCreate('dirty is not a string, aborting');
              }
            }
          }
          /* Check we can run. Otherwise fall back or ignore */


          if (!DOMPurify.isSupported) {
            if (_typeof(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {
              if (typeof dirty === 'string') {
                return window.toStaticHTML(dirty);
              }

              if (_isNode(dirty)) {
                return window.toStaticHTML(dirty.outerHTML);
              }
            }

            return dirty;
          }
          /* Assign config vars */


          if (!SET_CONFIG) {
            _parseConfig(cfg);
          }
          /* Clean up removed elements */


          DOMPurify.removed = [];
          /* Check if dirty is correctly typed for IN_PLACE */

          if (typeof dirty === 'string') {
            IN_PLACE = false;
          }

          if (IN_PLACE) {
            /* Do some early pre-sanitization to avoid unsafe root nodes */
            if (dirty.nodeName) {
              var tagName = transformCaseFunc(dirty.nodeName);

              if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
                throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');
              }
            }
          } else if (dirty instanceof Node) {
            /* If dirty is a DOM element, append to an empty document to avoid
               elements being stripped by the parser */
            body = _initDocument('<!---->');
            importedNode = body.ownerDocument.importNode(dirty, true);

            if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {
              /* Node is already a body, use as is */
              body = importedNode;
            } else if (importedNode.nodeName === 'HTML') {
              body = importedNode;
            } else {
              // eslint-disable-next-line unicorn/prefer-dom-node-append
              body.appendChild(importedNode);
            }
          } else {
            /* Exit directly if we have nothing to do */
            if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
            dirty.indexOf('<') === -1) {
              return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
            }
            /* Initialize the document to work on */


            body = _initDocument(dirty);
            /* Check we have a DOM node from the data */

            if (!body) {
              return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';
            }
          }
          /* Remove first element node (ours) if FORCE_BODY is set */


          if (body && FORCE_BODY) {
            _forceRemove(body.firstChild);
          }
          /* Get node iterator */


          var nodeIterator = _createIterator(IN_PLACE ? dirty : body);
          /* Now start iterating over the created document */


          while (currentNode = nodeIterator.nextNode()) {
            /* Fix IE's strange behavior with manipulated textNodes #89 */
            if (currentNode.nodeType === 3 && currentNode === oldNode) {
              continue;
            }
            /* Sanitize tags and elements */


            if (_sanitizeElements(currentNode)) {
              continue;
            }
            /* Shadow DOM detected, sanitize it */


            if (currentNode.content instanceof DocumentFragment) {
              _sanitizeShadowDOM(currentNode.content);
            }
            /* Check attributes, sanitize if necessary */


            _sanitizeAttributes(currentNode);

            oldNode = currentNode;
          }

          oldNode = null;
          /* If we sanitized `dirty` in-place, return it. */

          if (IN_PLACE) {
            return dirty;
          }
          /* Return sanitized string or DOM */


          if (RETURN_DOM) {
            if (RETURN_DOM_FRAGMENT) {
              returnNode = createDocumentFragment.call(body.ownerDocument);

              while (body.firstChild) {
                // eslint-disable-next-line unicorn/prefer-dom-node-append
                returnNode.appendChild(body.firstChild);
              }
            } else {
              returnNode = body;
            }

            if (ALLOWED_ATTR.shadowroot) {
              /*
                AdoptNode() is not used because internal state is not reset
                (e.g. the past names map of a HTMLFormElement), this is safe
                in theory but we would rather not risk another attack vector.
                The state that is cloned by importNode() is explicitly defined
                by the specs.
              */
              returnNode = importNode.call(originalDocument, returnNode, true);
            }

            return returnNode;
          }

          var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
          /* Serialize doctype if allowed */

          if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
            serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\n' + serializedHTML;
          }
          /* Sanitize final string template-safe */


          if (SAFE_FOR_TEMPLATES) {
            serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$1, ' ');
            serializedHTML = stringReplace(serializedHTML, ERB_EXPR$1, ' ');
          }

          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
        };
        /**
         * Public method to set the configuration once
         * setConfig
         *
         * @param {Object} cfg configuration object
         */


        DOMPurify.setConfig = function (cfg) {
          _parseConfig(cfg);

          SET_CONFIG = true;
        };
        /**
         * Public method to remove the configuration
         * clearConfig
         *
         */


        DOMPurify.clearConfig = function () {
          CONFIG = null;
          SET_CONFIG = false;
        };
        /**
         * Public method to check if an attribute value is valid.
         * Uses last set config, if any. Otherwise, uses config defaults.
         * isValidAttribute
         *
         * @param  {string} tag Tag name of containing element.
         * @param  {string} attr Attribute name.
         * @param  {string} value Attribute value.
         * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.
         */


        DOMPurify.isValidAttribute = function (tag, attr, value) {
          /* Initialize shared config vars if necessary. */
          if (!CONFIG) {
            _parseConfig({});
          }

          var lcTag = transformCaseFunc(tag);
          var lcName = transformCaseFunc(attr);
          return _isValidAttribute(lcTag, lcName, value);
        };
        /**
         * AddHook
         * Public method to add DOMPurify hooks
         *
         * @param {String} entryPoint entry point for the hook to add
         * @param {Function} hookFunction function to execute
         */


        DOMPurify.addHook = function (entryPoint, hookFunction) {
          if (typeof hookFunction !== 'function') {
            return;
          }

          hooks[entryPoint] = hooks[entryPoint] || [];
          arrayPush(hooks[entryPoint], hookFunction);
        };
        /**
         * RemoveHook
         * Public method to remove a DOMPurify hook at a given entryPoint
         * (pops it from the stack of hooks if more are present)
         *
         * @param {String} entryPoint entry point for the hook to remove
         * @return {Function} removed(popped) hook
         */


        DOMPurify.removeHook = function (entryPoint) {
          if (hooks[entryPoint]) {
            return arrayPop(hooks[entryPoint]);
          }
        };
        /**
         * RemoveHooks
         * Public method to remove all DOMPurify hooks at a given entryPoint
         *
         * @param  {String} entryPoint entry point for the hooks to remove
         */


        DOMPurify.removeHooks = function (entryPoint) {
          if (hooks[entryPoint]) {
            hooks[entryPoint] = [];
          }
        };
        /**
         * RemoveAllHooks
         * Public method to remove all DOMPurify hooks
         *
         */


        DOMPurify.removeAllHooks = function () {
          hooks = {};
        };

        return DOMPurify;
      }

      var purify = createDOMPurify();

      return purify;

    }));

    });

    let tippyInstances = new Map();
    const defaultTippyOptions = {
        theme: 'dynamic',
        animation: 'scale-subtle',
        inertia: true,
        allowHTML: true
    };
    function tippyService (id, query, options) {
        let tippyInstance = tippyInstances.get(id);
        if (options === null || options === void 0 ? void 0 : options.content) {
            options.content = purify.sanitize(options.content, { ALLOWED_TAGS: ['bold'] });
        }
        // If exists, update content.
        if (tippyInstance) {
            tippyInstance.forEach(instance => {
                instance.setContent(options.content);
            });
            // Otherwise, create new instance.
        }
        else {
            //@ts-ignore
            tippyInstances.set(id, tippy(query, Object.assign(defaultTippyOptions, options)));
        }
    }

    function numberZeroPad (num) {
        return num < 10 ? '0' + num : num;
    }

    /* src/layouts/library/AlbumInfo.svelte generated by Svelte v3.49.0 */
    const file$_ = "src/layouts/library/AlbumInfo.svelte";

    function create_fragment$13(ctx) {
    	let album_info_svlt;
    	let p;
    	let t0;
    	let t1;
    	let t2;
    	let t3;

    	const block = {
    		c: function create() {
    			album_info_svlt = element("album-info-svlt");
    			p = element("p");
    			t0 = text(/*totalDuration*/ ctx[0]);
    			t1 = text(" (-");
    			t2 = text(/*totalDurationLeft*/ ctx[1]);
    			t3 = text(")");
    			attr_dev(p, "class", "svelte-tk3zmd");
    			add_location(p, file$_, 30, 1, 865);
    			set_custom_element_data(album_info_svlt, "class", "svelte-tk3zmd");
    			add_location(album_info_svlt, file$_, 29, 0, 846);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, album_info_svlt, anchor);
    			append_dev(album_info_svlt, p);
    			append_dev(p, t0);
    			append_dev(p, t1);
    			append_dev(p, t2);
    			append_dev(p, t3);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*totalDuration*/ 1) set_data_dev(t0, /*totalDuration*/ ctx[0]);
    			if (dirty & /*totalDurationLeft*/ 2) set_data_dev(t2, /*totalDurationLeft*/ ctx[1]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(album_info_svlt);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$13.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$13($$self, $$props, $$invalidate) {
    	let $playbackStore;
    	let $playbackCursor;
    	validate_store(playbackStore, 'playbackStore');
    	component_subscribe($$self, playbackStore, $$value => $$invalidate(2, $playbackStore = $$value));
    	validate_store(playbackCursor, 'playbackCursor');
    	component_subscribe($$self, playbackCursor, $$value => $$invalidate(3, $playbackCursor = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('AlbumInfo', slots, []);
    	let totalDuration = '';
    	let totalDurationLeft = '';

    	function sumDuration() {
    		let tempDurationSum = 0;
    		$playbackStore.forEach(song => tempDurationSum += song.Duration);
    		$$invalidate(0, totalDuration = parseDuration(tempDurationSum));
    	}

    	function sumLeftDuration() {
    		let playingSongIndex = $playbackCursor[0];
    		let tempLeftDurationSum = 0;

    		for (let i = playingSongIndex; i <= $playbackStore.length; i++) {
    			if ($playbackStore[i]) {
    				tempLeftDurationSum += $playbackStore[i].Duration;
    			}
    		}

    		$$invalidate(1, totalDurationLeft = parseDuration(tempLeftDurationSum));
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AlbumInfo> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		parseDuration,
    		playbackCursor,
    		playbackStore,
    		totalDuration,
    		totalDurationLeft,
    		sumDuration,
    		sumLeftDuration,
    		$playbackStore,
    		$playbackCursor
    	});

    	$$self.$inject_state = $$props => {
    		if ('totalDuration' in $$props) $$invalidate(0, totalDuration = $$props.totalDuration);
    		if ('totalDurationLeft' in $$props) $$invalidate(1, totalDurationLeft = $$props.totalDurationLeft);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$playbackStore*/ 4) {
    			{
    				sumDuration();
    			}
    		}

    		if ($$self.$$.dirty & /*$playbackCursor*/ 8) {
    			{
    				sumLeftDuration();
    			}
    		}
    	};

    	return [totalDuration, totalDurationLeft, $playbackStore, $playbackCursor];
    }

    class AlbumInfo extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$13, create_fragment$13, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AlbumInfo",
    			options,
    			id: create_fragment$13.name
    		});
    	}
    }

    /* src/icons/ImageIcon.svelte generated by Svelte v3.49.0 */

    const file$Z = "src/icons/ImageIcon.svelte";

    function create_fragment$12(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$Z, 6, 2, 159);
    			attr_dev(path1, "d", "M21 15v3h3v2h-3v3h-2v-3h-3v-2h3v-3h2zm.008-12c.548 0 .992.445.992.993v9.349A5.99 5.99 0 0 0 20 13V5H4l.001 14 9.292-9.293a.999.999 0 0 1 1.32-.084l.093.085 3.546 3.55a6.003 6.003 0 0 0-3.91 7.743L2.992 21A.993.993 0 0 1 2 20.007V3.993A1 1 0 0 1 2.992 3h18.016zM8 7a2 2 0 1 1 0 4 2 2 0 0 1 0-4z");
    			add_location(path1, file$Z, 6, 40, 197);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "style", /*style*/ ctx[0]);
    			attr_dev(svg, "class", "svelte-12x8euw");
    			add_location(svg, file$Z, 5, 0, 89);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*style*/ 1) {
    				attr_dev(svg, "style", /*style*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$12.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$12($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ImageIcon', slots, []);
    	let { style = '' } = $$props;
    	const writable_props = ['style'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ImageIcon> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	$$self.$capture_state = () => ({ style });

    	$$self.$inject_state = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [style];
    }

    class ImageIcon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$12, create_fragment$12, safe_not_equal, { style: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ImageIcon",
    			options,
    			id: create_fragment$12.name
    		});
    	}

    	get style() {
    		throw new Error("<ImageIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<ImageIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/icons/MusicNoteIcon.svelte generated by Svelte v3.49.0 */

    const file$Y = "src/icons/MusicNoteIcon.svelte";

    function create_fragment$11(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$Y, 6, 2, 159);
    			attr_dev(path1, "d", "M12 13.535V3h8v2h-6v12a4 4 0 1 1-2-3.465zM10 19a2 2 0 1 0 0-4 2 2 0 0 0 0 4z");
    			add_location(path1, file$Y, 6, 40, 197);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "style", /*style*/ ctx[0]);
    			attr_dev(svg, "class", "svelte-12x8euw");
    			add_location(svg, file$Y, 5, 0, 89);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*style*/ 1) {
    				attr_dev(svg, "style", /*style*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$11.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$11($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MusicNoteIcon', slots, []);
    	let { style = '' } = $$props;
    	const writable_props = ['style'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MusicNoteIcon> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	$$self.$capture_state = () => ({ style });

    	$$self.$inject_state = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [style];
    }

    class MusicNoteIcon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$11, create_fragment$11, safe_not_equal, { style: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MusicNoteIcon",
    			options,
    			id: create_fragment$11.name
    		});
    	}

    	get style() {
    		throw new Error("<MusicNoteIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<MusicNoteIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/icons/RefreshIcon.svelte generated by Svelte v3.49.0 */

    const file$X = "src/icons/RefreshIcon.svelte";

    function create_fragment$10(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$X, 6, 2, 159);
    			attr_dev(path1, "d", "M5.463 4.433A9.961 9.961 0 0 1 12 2c5.523 0 10 4.477 10 10 0 2.136-.67 4.116-1.81 5.74L17 12h3A8 8 0 0 0 6.46 6.228l-.997-1.795zm13.074 15.134A9.961 9.961 0 0 1 12 22C6.477 22 2 17.523 2 12c0-2.136.67-4.116 1.81-5.74L7 12H4a8 8 0 0 0 13.54 5.772l.997 1.795z");
    			add_location(path1, file$X, 6, 40, 197);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "style", /*style*/ ctx[0]);
    			add_location(svg, file$X, 5, 0, 89);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*style*/ 1) {
    				attr_dev(svg, "style", /*style*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$10.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$10($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('RefreshIcon', slots, []);
    	let { style = '' } = $$props;
    	const writable_props = ['style'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<RefreshIcon> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	$$self.$capture_state = () => ({ style });

    	$$self.$inject_state = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [style];
    }

    class RefreshIcon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$10, create_fragment$10, safe_not_equal, { style: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "RefreshIcon",
    			options,
    			id: create_fragment$10.name
    		});
    	}

    	get style() {
    		throw new Error("<RefreshIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<RefreshIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/layouts/status_bar/Queues.svelte generated by Svelte v3.49.0 */
    const file$W = "src/layouts/status_bar/Queues.svelte";

    function create_fragment$$(ctx) {
    	let queue_processes;
    	let art_compress_queue;
    	let imageicon;
    	let t0;
    	let span0;
    	let t1;
    	let t2;
    	let song_sync_queue;
    	let musicnoteicon;
    	let t3;
    	let span1;
    	let t4;
    	let t5;
    	let t6;
    	let song_sync_queue_progress;
    	let t7;
    	let song_update;
    	let song_update_icon;
    	let refreshicon;
    	let song_update_icon_data_is_song_updating_value;
    	let current;
    	let mounted;
    	let dispose;

    	imageicon = new ImageIcon({
    			props: {
    				style: "fill:var(--art-color-dark);height: 20px;width: 20px;margin-right: .5rem;"
    			},
    			$$inline: true
    		});

    	musicnoteicon = new MusicNoteIcon({
    			props: {
    				style: "fill:var(--art-color-dark);height: 20px;width: 20px;margin-right: .5rem;"
    			},
    			$$inline: true
    		});

    	refreshicon = new RefreshIcon({
    			props: {
    				style: "fill:var(--art-color-dark);height: 20px;width: 20px;"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			queue_processes = element("queue-processes");
    			art_compress_queue = element("art-compress-queue");
    			create_component(imageicon.$$.fragment);
    			t0 = space();
    			span0 = element("span");
    			t1 = text(/*$artCompressQueueLength*/ ctx[2]);
    			t2 = space();
    			song_sync_queue = element("song-sync-queue");
    			create_component(musicnoteicon.$$.fragment);
    			t3 = space();
    			span1 = element("span");
    			t4 = text(/*currentSongSyncProgress*/ ctx[1]);
    			t5 = text("%");
    			t6 = space();
    			song_sync_queue_progress = element("song-sync-queue-progress");
    			t7 = space();
    			song_update = element("song-update");
    			song_update_icon = element("song-update-icon");
    			create_component(refreshicon.$$.fragment);
    			add_location(span0, file$W, 49, 2, 1909);
    			set_custom_element_data(art_compress_queue, "class", "svelte-53qjea");
    			add_location(art_compress_queue, file$W, 47, 1, 1789);
    			attr_dev(span1, "class", "svelte-53qjea");
    			add_location(span1, file$W, 53, 2, 2093);
    			set_custom_element_data(song_sync_queue_progress, "data-progress", /*currentSongSyncProgress*/ ctx[1]);
    			set_custom_element_data(song_sync_queue_progress, "class", "svelte-53qjea");
    			add_location(song_sync_queue_progress, file$W, 56, 2, 2142);
    			set_custom_element_data(song_sync_queue, "class", "svelte-53qjea");
    			add_location(song_sync_queue, file$W, 51, 1, 1972);
    			set_custom_element_data(song_update_icon, "data-is-song-updating", song_update_icon_data_is_song_updating_value = /*$songSyncQueueProgress*/ ctx[0].isSongUpdating);
    			set_custom_element_data(song_update_icon, "class", "svelte-53qjea");
    			add_location(song_update_icon, file$W, 59, 2, 2282);
    			set_custom_element_data(song_update, "class", "svelte-53qjea");
    			add_location(song_update, file$W, 58, 1, 2232);
    			set_custom_element_data(queue_processes, "class", "svelte-53qjea");
    			add_location(queue_processes, file$W, 46, 0, 1770);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, queue_processes, anchor);
    			append_dev(queue_processes, art_compress_queue);
    			mount_component(imageicon, art_compress_queue, null);
    			append_dev(art_compress_queue, t0);
    			append_dev(art_compress_queue, span0);
    			append_dev(span0, t1);
    			append_dev(queue_processes, t2);
    			append_dev(queue_processes, song_sync_queue);
    			mount_component(musicnoteicon, song_sync_queue, null);
    			append_dev(song_sync_queue, t3);
    			append_dev(song_sync_queue, span1);
    			append_dev(span1, t4);
    			append_dev(span1, t5);
    			append_dev(song_sync_queue, t6);
    			append_dev(song_sync_queue, song_sync_queue_progress);
    			append_dev(queue_processes, t7);
    			append_dev(queue_processes, song_update);
    			append_dev(song_update, song_update_icon);
    			mount_component(refreshicon, song_update_icon, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(song_update, "click", /*click_handler*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*$artCompressQueueLength*/ 4) set_data_dev(t1, /*$artCompressQueueLength*/ ctx[2]);
    			if (!current || dirty & /*currentSongSyncProgress*/ 2) set_data_dev(t4, /*currentSongSyncProgress*/ ctx[1]);

    			if (!current || dirty & /*currentSongSyncProgress*/ 2) {
    				set_custom_element_data(song_sync_queue_progress, "data-progress", /*currentSongSyncProgress*/ ctx[1]);
    			}

    			if (!current || dirty & /*$songSyncQueueProgress*/ 1 && song_update_icon_data_is_song_updating_value !== (song_update_icon_data_is_song_updating_value = /*$songSyncQueueProgress*/ ctx[0].isSongUpdating)) {
    				set_custom_element_data(song_update_icon, "data-is-song-updating", song_update_icon_data_is_song_updating_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(imageicon.$$.fragment, local);
    			transition_in(musicnoteicon.$$.fragment, local);
    			transition_in(refreshicon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(imageicon.$$.fragment, local);
    			transition_out(musicnoteicon.$$.fragment, local);
    			transition_out(refreshicon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(queue_processes);
    			destroy_component(imageicon);
    			destroy_component(musicnoteicon);
    			destroy_component(refreshicon);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$$.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$$($$self, $$props, $$invalidate) {
    	let $songSyncQueueProgress;
    	let $artCompressQueueLength;
    	validate_store(songSyncQueueProgress, 'songSyncQueueProgress');
    	component_subscribe($$self, songSyncQueueProgress, $$value => $$invalidate(0, $songSyncQueueProgress = $$value));
    	validate_store(artCompressQueueLength, 'artCompressQueueLength');
    	component_subscribe($$self, artCompressQueueLength, $$value => $$invalidate(2, $artCompressQueueLength = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Queues', slots, []);
    	let isMounted = false;
    	let currentSongSyncProgress = 0;
    	let tippySongUpdateId = generateId();

    	function calculateProgress(songSyncQueueProgress) {
    		$$invalidate(1, currentSongSyncProgress = 100 - Math.ceil(100 / songSyncQueueProgress.maxLength * songSyncQueueProgress.currentLength));

    		if (Math.abs(currentSongSyncProgress) === Infinity || isNaN(currentSongSyncProgress)) {
    			$$invalidate(1, currentSongSyncProgress = 100);
    		}

    		cssVariablesService.set('song-sync-queue-progress', currentSongSyncProgress + 'px');
    	}

    	function stopSongUpdate() {
    		if ($songSyncQueueProgress.isSongUpdating === true) {
    			window.ipc.stopSongUpdate().then(() => {
    				notifyService.success('Song update stopped');
    			});
    		}
    	}

    	function loadSongUpdateTippy(isSongUpdating) {
    		if (isSongUpdating) {
    			tippyService(tippySongUpdateId, 'song-update', { content: 'Stop songs update' });
    		} else {
    			tippyService(tippySongUpdateId, 'song-update', { content: 'No songs updating' });
    		}
    	}

    	onMount(() => {
    		$$invalidate(4, isMounted = true);
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Queues> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => stopSongUpdate();

    	$$self.$capture_state = () => ({
    		onMount,
    		generateId,
    		tippyService,
    		artCompressQueueLength,
    		songSyncQueueProgress,
    		ImageIcon,
    		MusicNoteIcon,
    		RefreshIcon,
    		notifyService,
    		cssVariablesService,
    		isMounted,
    		currentSongSyncProgress,
    		tippySongUpdateId,
    		calculateProgress,
    		stopSongUpdate,
    		loadSongUpdateTippy,
    		$songSyncQueueProgress,
    		$artCompressQueueLength
    	});

    	$$self.$inject_state = $$props => {
    		if ('isMounted' in $$props) $$invalidate(4, isMounted = $$props.isMounted);
    		if ('currentSongSyncProgress' in $$props) $$invalidate(1, currentSongSyncProgress = $$props.currentSongSyncProgress);
    		if ('tippySongUpdateId' in $$props) tippySongUpdateId = $$props.tippySongUpdateId;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$songSyncQueueProgress*/ 1) {
    			calculateProgress($songSyncQueueProgress);
    		}

    		if ($$self.$$.dirty & /*isMounted, $songSyncQueueProgress*/ 17) {
    			if (isMounted) loadSongUpdateTippy($songSyncQueueProgress.isSongUpdating);
    		}
    	};

    	return [
    		$songSyncQueueProgress,
    		currentSongSyncProgress,
    		$artCompressQueueLength,
    		stopSongUpdate,
    		isMounted,
    		click_handler
    	];
    }

    class Queues extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$$, create_fragment$$, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Queues",
    			options,
    			id: create_fragment$$.name
    		});
    	}
    }

    /* src/icons/RepeatIcon.svelte generated by Svelte v3.49.0 */

    const file$V = "src/icons/RepeatIcon.svelte";

    function create_fragment$_(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$V, 6, 2, 159);
    			attr_dev(path1, "d", "M8 20v1.932a.5.5 0 0 1-.82.385l-4.12-3.433A.5.5 0 0 1 3.382 18H18a2 2 0 0 0 2-2V8h2v8a4 4 0 0 1-4 4H8zm8-16V2.068a.5.5 0 0 1 .82-.385l4.12 3.433a.5.5 0 0 1-.321.884H6a2 2 0 0 0-2 2v8H2V8a4 4 0 0 1 4-4h10z");
    			add_location(path1, file$V, 6, 40, 197);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "style", /*style*/ ctx[0]);
    			attr_dev(svg, "class", "svelte-1yxkwx0");
    			add_location(svg, file$V, 5, 0, 89);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*style*/ 1) {
    				attr_dev(svg, "style", /*style*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$_.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$_($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('RepeatIcon', slots, []);
    	let { style = '' } = $$props;
    	const writable_props = ['style'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<RepeatIcon> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	$$self.$capture_state = () => ({ style });

    	$$self.$inject_state = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [style];
    }

    class RepeatIcon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$_, create_fragment$_, safe_not_equal, { style: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "RepeatIcon",
    			options,
    			id: create_fragment$_.name
    		});
    	}

    	get style() {
    		throw new Error("<RepeatIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<RepeatIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/icons/RepeatOneIcon.svelte generated by Svelte v3.49.0 */

    const file$U = "src/icons/RepeatOneIcon.svelte";

    function create_fragment$Z(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$U, 6, 2, 159);
    			attr_dev(path1, "d", "M8 20v1.932a.5.5 0 0 1-.82.385l-4.12-3.433A.5.5 0 0 1 3.382 18H18a2 2 0 0 0 2-2V8h2v8a4 4 0 0 1-4 4H8zm8-17.932a.5.5 0 0 1 .82-.385l4.12 3.433a.5.5 0 0 1-.321.884H6a2 2 0 0 0-2 2v8H2V8a4 4 0 0 1 4-4h10V2.068zM11 8h2v8h-2v-6H9V9l2-1z");
    			add_location(path1, file$U, 6, 40, 197);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "style", /*style*/ ctx[0]);
    			attr_dev(svg, "class", "svelte-1yxkwx0");
    			add_location(svg, file$U, 5, 0, 89);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*style*/ 1) {
    				attr_dev(svg, "style", /*style*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Z($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('RepeatOneIcon', slots, []);
    	let { style = '' } = $$props;
    	const writable_props = ['style'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<RepeatOneIcon> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	$$self.$capture_state = () => ({ style });

    	$$self.$inject_state = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [style];
    }

    class RepeatOneIcon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Z, create_fragment$Z, safe_not_equal, { style: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "RepeatOneIcon",
    			options,
    			id: create_fragment$Z.name
    		});
    	}

    	get style() {
    		throw new Error("<RepeatOneIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<RepeatOneIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/icons/ShuffleIcon.svelte generated by Svelte v3.49.0 */

    const file$T = "src/icons/ShuffleIcon.svelte";

    function create_fragment$Y(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$T, 6, 2, 159);
    			attr_dev(path1, "d", "M18 17.883V16l5 3-5 3v-2.09a9 9 0 0 1-6.997-5.365L11 14.54l-.003.006A9 9 0 0 1 2.725 20H2v-2h.725a7 7 0 0 0 6.434-4.243L9.912 12l-.753-1.757A7 7 0 0 0 2.725 6H2V4h.725a9 9 0 0 1 8.272 5.455L11 9.46l.003-.006A9 9 0 0 1 18 4.09V2l5 3-5 3V6.117a7 7 0 0 0-5.159 4.126L12.088 12l.753 1.757A7 7 0 0 0 18 17.883z");
    			add_location(path1, file$T, 6, 40, 197);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "style", /*style*/ ctx[0]);
    			attr_dev(svg, "class", "svelte-1yxkwx0");
    			add_location(svg, file$T, 5, 0, 89);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*style*/ 1) {
    				attr_dev(svg, "style", /*style*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Y($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ShuffleIcon', slots, []);
    	let { style = '' } = $$props;
    	const writable_props = ['style'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ShuffleIcon> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	$$self.$capture_state = () => ({ style });

    	$$self.$inject_state = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [style];
    }

    class ShuffleIcon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Y, create_fragment$Y, safe_not_equal, { style: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ShuffleIcon",
    			options,
    			id: create_fragment$Y.name
    		});
    	}

    	get style() {
    		throw new Error("<ShuffleIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<ShuffleIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/layouts/status_bar/PlaybackOptions.svelte generated by Svelte v3.49.0 */

    const file$S = "src/layouts/status_bar/PlaybackOptions.svelte";

    function create_fragment$X(ctx) {
    	let playback_options;
    	let option_icon0;
    	let shuffleicon;
    	let t0;
    	let option_icon1;
    	let repeaticon;
    	let t1;
    	let option_icon2;
    	let repeatoneicon;
    	let current;
    	let mounted;
    	let dispose;

    	shuffleicon = new ShuffleIcon({
    			props: {
    				style: "height: 1.25rem;fill:var(--art-color-" + (/*$isSongShuffleEnabledStore*/ ctx[0] === true
    				? 'light'
    				: 'dark') + ")"
    			},
    			$$inline: true
    		});

    	repeaticon = new RepeatIcon({
    			props: {
    				style: "height: 1.25rem;fill:var(--art-color-" + (/*$isPlaybackRepeatEnabledStore*/ ctx[1] === true
    				? 'light'
    				: 'dark') + ")"
    			},
    			$$inline: true
    		});

    	repeatoneicon = new RepeatOneIcon({
    			props: {
    				style: "height: 1.25rem;fill:var(--art-color-" + (/*$isSongRepeatEnabledStore*/ ctx[2] === true
    				? 'light'
    				: 'dark') + ")"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			playback_options = element("playback-options");
    			option_icon0 = element("option-icon");
    			create_component(shuffleicon.$$.fragment);
    			t0 = space();
    			option_icon1 = element("option-icon");
    			create_component(repeaticon.$$.fragment);
    			t1 = space();
    			option_icon2 = element("option-icon");
    			create_component(repeatoneicon.$$.fragment);
    			set_custom_element_data(option_icon0, "class", "shuffle svelte-o32u4f");
    			set_custom_element_data(option_icon0, "data-is-active", /*$isSongShuffleEnabledStore*/ ctx[0]);
    			add_location(option_icon0, file$S, 31, 1, 1484);
    			set_custom_element_data(option_icon1, "data-is-active", /*$isPlaybackRepeatEnabledStore*/ ctx[1]);
    			set_custom_element_data(option_icon1, "class", "svelte-o32u4f");
    			add_location(option_icon1, file$S, 35, 1, 1697);
    			set_custom_element_data(option_icon2, "data-is-active", /*$isSongRepeatEnabledStore*/ ctx[2]);
    			set_custom_element_data(option_icon2, "class", "svelte-o32u4f");
    			add_location(option_icon2, file$S, 42, 1, 1987);
    			set_custom_element_data(playback_options, "class", "svelte-o32u4f");
    			add_location(playback_options, file$S, 30, 0, 1464);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, playback_options, anchor);
    			append_dev(playback_options, option_icon0);
    			mount_component(shuffleicon, option_icon0, null);
    			append_dev(playback_options, t0);
    			append_dev(playback_options, option_icon1);
    			mount_component(repeaticon, option_icon1, null);
    			append_dev(playback_options, t1);
    			append_dev(playback_options, option_icon2);
    			mount_component(repeatoneicon, option_icon2, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(option_icon1, "click", /*click_handler*/ ctx[3], false, false, false),
    					listen_dev(option_icon2, "click", /*click_handler_1*/ ctx[4], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const shuffleicon_changes = {};

    			if (dirty & /*$isSongShuffleEnabledStore*/ 1) shuffleicon_changes.style = "height: 1.25rem;fill:var(--art-color-" + (/*$isSongShuffleEnabledStore*/ ctx[0] === true
    			? 'light'
    			: 'dark') + ")";

    			shuffleicon.$set(shuffleicon_changes);

    			if (!current || dirty & /*$isSongShuffleEnabledStore*/ 1) {
    				set_custom_element_data(option_icon0, "data-is-active", /*$isSongShuffleEnabledStore*/ ctx[0]);
    			}

    			const repeaticon_changes = {};

    			if (dirty & /*$isPlaybackRepeatEnabledStore*/ 2) repeaticon_changes.style = "height: 1.25rem;fill:var(--art-color-" + (/*$isPlaybackRepeatEnabledStore*/ ctx[1] === true
    			? 'light'
    			: 'dark') + ")";

    			repeaticon.$set(repeaticon_changes);

    			if (!current || dirty & /*$isPlaybackRepeatEnabledStore*/ 2) {
    				set_custom_element_data(option_icon1, "data-is-active", /*$isPlaybackRepeatEnabledStore*/ ctx[1]);
    			}

    			const repeatoneicon_changes = {};

    			if (dirty & /*$isSongRepeatEnabledStore*/ 4) repeatoneicon_changes.style = "height: 1.25rem;fill:var(--art-color-" + (/*$isSongRepeatEnabledStore*/ ctx[2] === true
    			? 'light'
    			: 'dark') + ")";

    			repeatoneicon.$set(repeatoneicon_changes);

    			if (!current || dirty & /*$isSongRepeatEnabledStore*/ 4) {
    				set_custom_element_data(option_icon2, "data-is-active", /*$isSongRepeatEnabledStore*/ ctx[2]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(shuffleicon.$$.fragment, local);
    			transition_in(repeaticon.$$.fragment, local);
    			transition_in(repeatoneicon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(shuffleicon.$$.fragment, local);
    			transition_out(repeaticon.$$.fragment, local);
    			transition_out(repeatoneicon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(playback_options);
    			destroy_component(shuffleicon);
    			destroy_component(repeaticon);
    			destroy_component(repeatoneicon);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$X.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$X($$self, $$props, $$invalidate) {
    	let $isSongShuffleEnabledStore;
    	let $config;
    	let $playbackStore;
    	let $playingSongStore;
    	let $songListStore;
    	let $isPlaybackRepeatEnabledStore;
    	let $isSongRepeatEnabledStore;
    	validate_store(isSongShuffleEnabledStore, 'isSongShuffleEnabledStore');
    	component_subscribe($$self, isSongShuffleEnabledStore, $$value => $$invalidate(0, $isSongShuffleEnabledStore = $$value));
    	validate_store(config, 'config');
    	component_subscribe($$self, config, $$value => $$invalidate(5, $config = $$value));
    	validate_store(playbackStore, 'playbackStore');
    	component_subscribe($$self, playbackStore, $$value => $$invalidate(6, $playbackStore = $$value));
    	validate_store(playingSongStore, 'playingSongStore');
    	component_subscribe($$self, playingSongStore, $$value => $$invalidate(7, $playingSongStore = $$value));
    	validate_store(songListStore, 'songListStore');
    	component_subscribe($$self, songListStore, $$value => $$invalidate(8, $songListStore = $$value));
    	validate_store(isPlaybackRepeatEnabledStore, 'isPlaybackRepeatEnabledStore');
    	component_subscribe($$self, isPlaybackRepeatEnabledStore, $$value => $$invalidate(1, $isPlaybackRepeatEnabledStore = $$value));
    	validate_store(isSongRepeatEnabledStore, 'isSongRepeatEnabledStore');
    	component_subscribe($$self, isSongRepeatEnabledStore, $$value => $$invalidate(2, $isSongRepeatEnabledStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PlaybackOptions', slots, []);

    	function shuffleSongs(evt) {
    		if (evt.type === 'click') {
    			let shuffledArray = shuffleArrayFn($songListStore);
    			let removedSong = shuffledArray.splice(shuffledArray.findIndex(song => song.ID === $playingSongStore.ID), 1);
    			shuffledArray.unshift(removedSong[0]);
    			set_store_value(playbackStore, $playbackStore = shuffledArray, $playbackStore);

    			// Sets value to false first to trigger an update.
    			set_store_value(isSongShuffleEnabledStore, $isSongShuffleEnabledStore = false, $isSongShuffleEnabledStore);

    			set_store_value(isSongShuffleEnabledStore, $isSongShuffleEnabledStore = true, $isSongShuffleEnabledStore);
    		} else if (evt.type === 'contextmenu') {
    			set_store_value(playbackStore, $playbackStore = sortSongsArrayFn($playbackStore, $config.userOptions.sortBy, $config.userOptions.sortOrder), $playbackStore);
    			set_store_value(isSongShuffleEnabledStore, $isSongShuffleEnabledStore = false, $isSongShuffleEnabledStore);
    		}
    	}

    	onMount(() => {
    		let shuffleSongsElement = document.querySelector('.shuffle');

    		['click', 'contextmenu'].forEach(evtType => {
    			shuffleSongsElement.addEventListener(evtType, evt => shuffleSongs(evt));
    		});
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PlaybackOptions> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => set_store_value(isPlaybackRepeatEnabledStore, $isPlaybackRepeatEnabledStore = !$isPlaybackRepeatEnabledStore, $isPlaybackRepeatEnabledStore);
    	const click_handler_1 = () => set_store_value(isSongRepeatEnabledStore, $isSongRepeatEnabledStore = !$isSongRepeatEnabledStore, $isSongRepeatEnabledStore);

    	$$self.$capture_state = () => ({
    		onMount,
    		shuffleArrayFn,
    		sortSongsArrayFn,
    		RepeatIcon,
    		RepeatOneIcon,
    		ShuffleIcon,
    		config,
    		isPlaybackRepeatEnabledStore,
    		isSongRepeatEnabledStore,
    		isSongShuffleEnabledStore,
    		playbackStore,
    		playingSongStore,
    		songListStore,
    		shuffleSongs,
    		$isSongShuffleEnabledStore,
    		$config,
    		$playbackStore,
    		$playingSongStore,
    		$songListStore,
    		$isPlaybackRepeatEnabledStore,
    		$isSongRepeatEnabledStore
    	});

    	return [
    		$isSongShuffleEnabledStore,
    		$isPlaybackRepeatEnabledStore,
    		$isSongRepeatEnabledStore,
    		click_handler,
    		click_handler_1
    	];
    }

    class PlaybackOptions extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$X, create_fragment$X, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PlaybackOptions",
    			options,
    			id: create_fragment$X.name
    		});
    	}
    }

    /* src/layouts/status_bar/!StatusBar.svelte generated by Svelte v3.49.0 */
    const file$R = "src/layouts/status_bar/!StatusBar.svelte";

    // (32:2) {#if currentSong?.Title !== ''}
    function create_if_block$c(ctx) {
    	let bold0;
    	let t0_value = numberZeroPad(/*currentSong*/ ctx[0].Track) + "";
    	let t0;
    	let t1;
    	let bold1;
    	let t2_value = (/*currentSong*/ ctx[0].Title || '') + "";
    	let t2;
    	let t3;
    	let bold2;
    	let t4_value = (/*currentSong*/ ctx[0].Artist || '') + "";
    	let t4;

    	const block = {
    		c: function create() {
    			bold0 = element("bold");
    			t0 = text(t0_value);
    			t1 = space();
    			bold1 = element("bold");
    			t2 = text(t2_value);
    			t3 = text(" by\n\t\t\t");
    			bold2 = element("bold");
    			t4 = text(t4_value);
    			add_location(bold0, file$R, 32, 3, 995);
    			add_location(bold1, file$R, 32, 51, 1043);
    			add_location(bold2, file$R, 33, 3, 1088);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, bold0, anchor);
    			append_dev(bold0, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, bold1, anchor);
    			append_dev(bold1, t2);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, bold2, anchor);
    			append_dev(bold2, t4);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*currentSong*/ 1 && t0_value !== (t0_value = numberZeroPad(/*currentSong*/ ctx[0].Track) + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*currentSong*/ 1 && t2_value !== (t2_value = (/*currentSong*/ ctx[0].Title || '') + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*currentSong*/ 1 && t4_value !== (t4_value = (/*currentSong*/ ctx[0].Artist || '') + "")) set_data_dev(t4, t4_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(bold0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(bold1);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(bold2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$c.name,
    		type: "if",
    		source: "(32:2) {#if currentSong?.Title !== ''}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$W(ctx) {
    	let statusbar_svlt;
    	let queues;
    	let t0;
    	let song_info;
    	let t1;
    	let albuminfo;
    	let t2;
    	let playbackoptions;
    	let current;
    	queues = new Queues({ $$inline: true });
    	let if_block = /*currentSong*/ ctx[0]?.Title !== '' && create_if_block$c(ctx);
    	albuminfo = new AlbumInfo({ $$inline: true });
    	playbackoptions = new PlaybackOptions({ $$inline: true });

    	const block = {
    		c: function create() {
    			statusbar_svlt = element("statusbar-svlt");
    			create_component(queues.$$.fragment);
    			t0 = space();
    			song_info = element("song-info");
    			if (if_block) if_block.c();
    			t1 = space();
    			create_component(albuminfo.$$.fragment);
    			t2 = space();
    			create_component(playbackoptions.$$.fragment);
    			set_custom_element_data(song_info, "class", "svelte-1o7y175");
    			add_location(song_info, file$R, 30, 1, 946);
    			set_custom_element_data(statusbar_svlt, "class", "svelte-1o7y175");
    			add_location(statusbar_svlt, file$R, 28, 0, 916);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, statusbar_svlt, anchor);
    			mount_component(queues, statusbar_svlt, null);
    			append_dev(statusbar_svlt, t0);
    			append_dev(statusbar_svlt, song_info);
    			if (if_block) if_block.m(song_info, null);
    			append_dev(statusbar_svlt, t1);
    			mount_component(albuminfo, statusbar_svlt, null);
    			append_dev(statusbar_svlt, t2);
    			mount_component(playbackoptions, statusbar_svlt, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*currentSong*/ ctx[0]?.Title !== '') {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$c(ctx);
    					if_block.c();
    					if_block.m(song_info, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(queues.$$.fragment, local);
    			transition_in(albuminfo.$$.fragment, local);
    			transition_in(playbackoptions.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(queues.$$.fragment, local);
    			transition_out(albuminfo.$$.fragment, local);
    			transition_out(playbackoptions.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(statusbar_svlt);
    			destroy_component(queues);
    			if (if_block) if_block.d();
    			destroy_component(albuminfo);
    			destroy_component(playbackoptions);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$W.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$W($$self, $$props, $$invalidate) {
    	let $playingSongStore;
    	validate_store(playingSongStore, 'playingSongStore');
    	component_subscribe($$self, playingSongStore, $$value => $$invalidate(1, $playingSongStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('StatusBar', slots, []);
    	let currentSong = { Track: 0, Title: '', Artist: '' };
    	let tippySongInfoId = generateId();

    	onMount(() => {
    		tippyService(tippySongInfoId, 'song-info', '');
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<StatusBar> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		tippyService,
    		playingSongStore,
    		generateId,
    		numberZeroPad,
    		AlbumInfo,
    		Queues,
    		PlaybackOptions,
    		currentSong,
    		tippySongInfoId,
    		$playingSongStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('currentSong' in $$props) $$invalidate(0, currentSong = $$props.currentSong);
    		if ('tippySongInfoId' in $$props) $$invalidate(2, tippySongInfoId = $$props.tippySongInfoId);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$playingSongStore, currentSong*/ 3) {
    			{
    				if ($playingSongStore) {
    					$$invalidate(0, currentSong = $playingSongStore);

    					tippyService(tippySongInfoId, null, {
    						content: `<bold>${numberZeroPad(currentSong.Track)}</bold> <bold>${currentSong.Title || ''}</bold> by
		<bold>${currentSong.Artist || ''}</bold>`
    					});
    				}
    			}
    		}
    	};

    	return [currentSong, $playingSongStore];
    }

    class StatusBar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$W, create_fragment$W, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "StatusBar",
    			options,
    			id: create_fragment$W.name
    		});
    	}
    }

    async function groupSongs(groups, groupValues) {
        let songs = await getAllSongsFn();
        groups = normalizeGroupNames(groups);
        groups.forEach((group, index) => {
            runGroupSongs(songs, groups, groupValues, index);
        });
    }
    function runGroupSongs(songs, groups, groupValues, index) {
        let filteredSongs = [];
        let groupedValues = [];
        /********************** First Index **********************/
        // For the first index there is no need to filter the songs.
        if (index === 0) {
            // Group songs by value.
            let firstIndexGroupedSongs = Array.from(new Set(songs.map(song => song[groups[index]])));
            // If too many values, slice the array to prevent performance issues.
            if (firstIndexGroupedSongs.length > 500) {
                firstIndexGroupedSongs = firstIndexGroupedSongs.slice(0, 500);
                // sendWebContents('notify', { type: 'error', message: `Only the first 500 ${groups[index]} will be shown.` })
            }
            // Sort array.
            firstIndexGroupedSongs = firstIndexGroupedSongs.sort((a, b) => {
                return String(a).localeCompare(String(b), undefined, { numeric: true });
            });
            let selectedGroupsLocal;
            selectedGroups.subscribe(value => {
                selectedGroupsLocal = value;
            })();
            selectedGroupsLocal[index] = firstIndexGroupedSongs;
            selectedGroups.set(selectedGroupsLocal);
            return;
        }
        /********************** Song Filtering **********************/
        // Filter out all songs by value.
        filteredSongs = filterSongsByValue(songs, groups, groupValues, index);
        // Group unique values.
        filteredSongs.forEach(song => {
            let value = song[groups[index]];
            if (!groupedValues.includes(value)) {
                groupedValues.push(value);
            }
        });
        // If too many values, slice the array to prevent performance issues.
        if (groupedValues.length > 500) {
            groupedValues = groupedValues.slice(0, 500);
            // sendWebContents('notify', { type: 'error', message: `Only the first 500 ${groups[index]} will be shown.` })
        }
        let selectedGroupsLocal;
        selectedGroups.subscribe(value => {
            selectedGroupsLocal = value;
        })();
        selectedGroupsLocal[index] = groupedValues.sort((a, b) => {
            if (a && b) {
                a = String(a).toLowerCase();
                b = String(b).toLowerCase();
                return a.localeCompare(b, undefined, { numeric: true });
            }
            else {
                return false;
            }
        });
        selectedGroups.set(selectedGroupsLocal);
        /********************** Album Grouping **********************/
        // If last index, group unique albums.
        if (index === groups.length - 1) ;
    }
    function filterSongsByValue(songs, groups, groupValues, index) {
        let filteredSongs = songs;
        groups.forEach((group, groupIndex) => {
            if (groupIndex >= index) {
                return;
            }
            filteredSongs = filteredSongs.filter(song => {
                if (groupValues[groupIndex] === undefined || groupValues[groupIndex] === 'undefined') {
                    return true;
                }
                if (song[group] === groupValues[groupIndex]) {
                    return true;
                }
                else {
                    return false;
                }
            });
        });
        return filteredSongs;
    }
    function normalizeGroupNames(groups) {
        if (!groups) {
            return groups;
        }
        groups = groups.map(group => {
            switch (group) {
                case 'Album Artist':
                    return 'AlbumArtist';
                case 'Disc #':
                    return 'DiscNumber';
                case 'Year':
                    return 'Date_Year';
                default:
                    return group;
            }
        });
        return groups;
    }

    /* src/components/Album.svelte generated by Svelte v3.49.0 */
    const file$Q = "src/components/Album.svelte";

    // (29:2) {:else}
    function create_else_block$7(ctx) {
    	let album_artist;

    	const block = {
    		c: function create() {
    			album_artist = element("album-artist");
    			set_custom_element_data(album_artist, "class", "svelte-1so5fyd");
    			add_location(album_artist, file$Q, 29, 3, 945);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, album_artist, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(album_artist);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$7.name,
    		type: "else",
    		source: "(29:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (27:54) 
    function create_if_block_1$5(ctx) {
    	let album_artist;
    	let t_value = (/*album*/ ctx[0]['DynamicAlbumArtist'] || '') + "";
    	let t;

    	const block = {
    		c: function create() {
    			album_artist = element("album-artist");
    			t = text(t_value);
    			set_custom_element_data(album_artist, "class", "svelte-1so5fyd");
    			add_location(album_artist, file$Q, 27, 3, 867);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, album_artist, anchor);
    			append_dev(album_artist, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*album*/ 1 && t_value !== (t_value = (/*album*/ ctx[0]['DynamicAlbumArtist'] || '') + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(album_artist);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$5.name,
    		type: "if",
    		source: "(27:54) ",
    		ctx
    	});

    	return block;
    }

    // (25:2) {#if album['AlbumArtist'] !== undefined}
    function create_if_block$b(ctx) {
    	let album_artist;
    	let t_value = (/*album*/ ctx[0]['AlbumArtist'] || '') + "";
    	let t;

    	const block = {
    		c: function create() {
    			album_artist = element("album-artist");
    			t = text(t_value);
    			set_custom_element_data(album_artist, "class", "svelte-1so5fyd");
    			add_location(album_artist, file$Q, 25, 3, 751);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, album_artist, anchor);
    			append_dev(album_artist, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*album*/ 1 && t_value !== (t_value = (/*album*/ ctx[0]['AlbumArtist'] || '') + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(album_artist);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$b.name,
    		type: "if",
    		source: "(25:2) {#if album['AlbumArtist'] !== undefined}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$V(ctx) {
    	let album_1;
    	let albumart;
    	let t0;
    	let overlay_gradient;
    	let t1;
    	let album_details;
    	let album_name;
    	let t2_value = (/*album*/ ctx[0]['Name'] || '') + "";
    	let t2;
    	let t3;
    	let album_1_rootdir_value;
    	let album_1_class_value;
    	let current;

    	albumart = new AlbumArt({
    			props: {
    				imageSourceLocation: /*album*/ ctx[0].RootDir,
    				intersectionRoot: "art-grid-svlt"
    			},
    			$$inline: true
    		});

    	function select_block_type(ctx, dirty) {
    		if (/*album*/ ctx[0]['AlbumArtist'] !== undefined) return create_if_block$b;
    		if (/*album*/ ctx[0]['DynamicAlbumArtist'] !== undefined) return create_if_block_1$5;
    		return create_else_block$7;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			album_1 = element("album");
    			create_component(albumart.$$.fragment);
    			t0 = space();
    			overlay_gradient = element("overlay-gradient");
    			t1 = space();
    			album_details = element("album-details");
    			album_name = element("album-name");
    			t2 = text(t2_value);
    			t3 = space();
    			if_block.c();
    			set_custom_element_data(overlay_gradient, "class", "svelte-1so5fyd");
    			add_location(overlay_gradient, file$Q, 19, 1, 616);
    			set_custom_element_data(album_name, "class", "svelte-1so5fyd");
    			add_location(album_name, file$Q, 22, 2, 657);
    			set_custom_element_data(album_details, "class", "svelte-1so5fyd");
    			add_location(album_details, file$Q, 21, 1, 639);
    			attr_dev(album_1, "rootdir", album_1_rootdir_value = /*album*/ ctx[0].RootDir);

    			attr_dev(album_1, "class", album_1_class_value = "" + (null_to_empty(/*$selectedAlbumDir*/ ctx[1] === /*album*/ ctx[0]?.RootDir
    			? 'selected'
    			: '') + " svelte-1so5fyd"));

    			add_location(album_1, file$Q, 16, 0, 435);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, album_1, anchor);
    			mount_component(albumart, album_1, null);
    			append_dev(album_1, t0);
    			append_dev(album_1, overlay_gradient);
    			append_dev(album_1, t1);
    			append_dev(album_1, album_details);
    			append_dev(album_details, album_name);
    			append_dev(album_name, t2);
    			append_dev(album_details, t3);
    			if_block.m(album_details, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const albumart_changes = {};
    			if (dirty & /*album*/ 1) albumart_changes.imageSourceLocation = /*album*/ ctx[0].RootDir;
    			albumart.$set(albumart_changes);
    			if ((!current || dirty & /*album*/ 1) && t2_value !== (t2_value = (/*album*/ ctx[0]['Name'] || '') + "")) set_data_dev(t2, t2_value);

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(album_details, null);
    				}
    			}

    			if (!current || dirty & /*album*/ 1 && album_1_rootdir_value !== (album_1_rootdir_value = /*album*/ ctx[0].RootDir)) {
    				attr_dev(album_1, "rootdir", album_1_rootdir_value);
    			}

    			if (!current || dirty & /*$selectedAlbumDir, album*/ 3 && album_1_class_value !== (album_1_class_value = "" + (null_to_empty(/*$selectedAlbumDir*/ ctx[1] === /*album*/ ctx[0]?.RootDir
    			? 'selected'
    			: '') + " svelte-1so5fyd"))) {
    				attr_dev(album_1, "class", album_1_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(albumart.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(albumart.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(album_1);
    			destroy_component(albumart);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$V.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$V($$self, $$props, $$invalidate) {
    	let $selectedAlbumDir;
    	validate_store(selectedAlbumDir, 'selectedAlbumDir');
    	component_subscribe($$self, selectedAlbumDir, $$value => $$invalidate(1, $selectedAlbumDir = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Album', slots, []);
    	let { album } = $$props;
    	let artSize = 0;
    	let element;

    	onMount(() => {
    		
    	}); // let lastPlayedAlbumId = localStorage.getItem('LastPlayedAlbumId')
    	// if (album.ID === lastPlayedAlbumId) {
    	// 	setTimeout(() => {
    	// 		scrollToAlbumFn(album.ID)

    	const writable_props = ['album'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Album> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('album' in $$props) $$invalidate(0, album = $$props.album);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		selectedAlbumDir,
    		AlbumArt,
    		album,
    		artSize,
    		element,
    		$selectedAlbumDir
    	});

    	$$self.$inject_state = $$props => {
    		if ('album' in $$props) $$invalidate(0, album = $$props.album);
    		if ('artSize' in $$props) artSize = $$props.artSize;
    		if ('element' in $$props) element = $$props.element;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [album, $selectedAlbumDir];
    }

    class Album extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$V, create_fragment$V, safe_not_equal, { album: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Album",
    			options,
    			id: create_fragment$V.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*album*/ ctx[0] === undefined && !('album' in props)) {
    			console.warn("<Album> was created without expected prop 'album'");
    		}
    	}

    	get album() {
    		throw new Error("<Album>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set album(value) {
    		throw new Error("<Album>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function groupSongsByAlbumFn (songs) {
        return new Promise((resolve, reject) => {
            let albums = [];
            songs.forEach(song => {
                const rootDir = song.SourceFile.split('/').slice(0, -1).join('/');
                const albumId = hash$2(rootDir);
                let album = albums.find(album => album.ID === albumId);
                if (album === undefined) {
                    album = {
                        ID: albumId,
                        RootDir: rootDir,
                        Name: song.Album || '',
                        AlbumArtist: song.AlbumArtist,
                        DynamicAlbumArtist: getAllAlbumArtists(songs, song.Album),
                        Songs: []
                    };
                    albums.push(album);
                }
                album.Songs.push(song);
                albums[albums.indexOf(album)] = album;
            });
            resolve(albums);
        });
    }
    function getAllAlbumArtists(songArray, album) {
        let artistsCount = [];
        let artistsConcat = [];
        let artistsSorted = '';
        songArray.forEach(song => {
            if (song['Album'] === album) {
                let artists = splitArtists(song['Artist']);
                if (artists.length > 0) {
                    artistsConcat.push(...artists);
                }
                else {
                    artistsConcat = artists;
                }
            }
        });
        artistsConcat.forEach(artist => {
            let foundArtist = artistsCount.find(i => i['Artist'] === artist);
            if (foundArtist) {
                foundArtist['Count']++;
            }
            else {
                artistsCount.push({
                    Artist: artist,
                    Count: 0
                });
            }
        });
        artistsCount = artistsCount.sort((a, b) => b['Count'] - a['Count']);
        artistsSorted = artistsCount.map(a => a['Artist']).join(', ');
        return artistsSorted;
    }
    function splitArtists(artists) {
        if (artists) {
            let artistSplit = [];
            if (typeof artists === 'string') {
                artistSplit = artists.split(', ');
                artistSplit = artists.split(',');
            }
            return artistSplit;
        }
        return [];
    }

    /* src/layouts/library/ArtGrid.svelte generated by Svelte v3.49.0 */
    const file$P = "src/layouts/library/ArtGrid.svelte";

    function get_each_context$c(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[5] = list[i];
    	return child_ctx;
    }

    // (45:1) {#each albums || [] as album (album.ID)}
    function create_each_block$c(key_1, ctx) {
    	let first;
    	let album;
    	let current;

    	album = new Album({
    			props: { album: /*album*/ ctx[5] },
    			$$inline: true
    		});

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(album.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(album, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const album_changes = {};
    			if (dirty & /*albums*/ 1) album_changes.album = /*album*/ ctx[5];
    			album.$set(album_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(album.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(album.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(album, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$c.name,
    		type: "each",
    		source: "(45:1) {#each albums || [] as album (album.ID)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$U(ctx) {
    	let art_grid_svlt;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let current;
    	let each_value = /*albums*/ ctx[0] || [];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*album*/ ctx[5].ID;
    	validate_each_keys(ctx, each_value, get_each_context$c, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$c(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$c(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			art_grid_svlt = element("art-grid-svlt");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			set_custom_element_data(art_grid_svlt, "class", "svelte-n3jpin");
    			add_location(art_grid_svlt, file$P, 43, 0, 1729);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, art_grid_svlt, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(art_grid_svlt, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*albums*/ 1) {
    				each_value = /*albums*/ ctx[0] || [];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$c, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, art_grid_svlt, outro_and_destroy_block, create_each_block$c, null, get_each_context$c);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(art_grid_svlt);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$U.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$U($$self, $$props, $$invalidate) {
    	let $config;
    	let $dbSongsStore;
    	validate_store(config, 'config');
    	component_subscribe($$self, config, $$value => $$invalidate(1, $config = $$value));
    	validate_store(dbSongsStore, 'dbSongsStore');
    	component_subscribe($$self, dbSongsStore, $$value => $$invalidate(2, $dbSongsStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ArtGrid', slots, []);
    	let albums;
    	let groupByValuesConfigObserver;

    	function updateArtGridAlbums() {
    		let songsFiltered = [];

    		$config.group.groupBy.forEach((group, index) => {
    			songsFiltered = $dbSongsStore.filter(song => {
    				return song[$config.group.groupBy[index]] === $config.group.groupByValues[index];
    			});
    		});

    		groupSongsByAlbumFn(songsFiltered).then(groupedAlbums => {
    			// TODO add user controlled album sorting.
    			$$invalidate(0, albums = groupedAlbums.sort((a, b) => {
    				return a.RootDir.localeCompare(b.RootDir);
    			}));
    		});
    	}

    	onMount(() => {
    		
    	}); // Whenever a filter is selected resets the scroll to top. Can't do it in reactive statement because querySelector gives undefined.
    	//TODO Improve this part.
    	/* 	groupByValuesConfigObserver = groupByValuesConfig.subscribe(() => {
        document.querySelector('art-grid-svlt').scrollTop = 0
    }) */

    	onDestroy(() => {
    		
    	}); // groupByValuesConfigObserver()

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ArtGrid> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onDestroy,
    		onMount,
    		Album,
    		config,
    		dbSongsStore,
    		groupSongsByAlbumFn,
    		cssVariablesService,
    		albums,
    		groupByValuesConfigObserver,
    		updateArtGridAlbums,
    		$config,
    		$dbSongsStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('albums' in $$props) $$invalidate(0, albums = $$props.albums);
    		if ('groupByValuesConfigObserver' in $$props) groupByValuesConfigObserver = $$props.groupByValuesConfigObserver;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$config*/ 2) {
    			// If the album art size has been set in the store.
    			if ($config.userOptions.artSize !== undefined) cssVariablesService.set('art-dimension', `${$config.userOptions.artSize}px`);
    		}

    		if ($$self.$$.dirty & /*$config*/ 2) {
    			if ($config.userOptions.gridGap !== undefined) cssVariablesService.set('grid-gap', `${$config.userOptions.gridGap}px`);
    		}

    		if ($$self.$$.dirty & /*$dbSongsStore, $config*/ 6) {
    			{
    				if ($dbSongsStore && $config.group.groupByValues && $config.group.groupBy) {
    					updateArtGridAlbums();
    				}
    			}
    		}
    	};

    	return [albums, $config, $dbSongsStore];
    }

    class ArtGrid extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$U, create_fragment$U, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ArtGrid",
    			options,
    			id: create_fragment$U.name
    		});
    	}
    }

    let selectedConfigOptionName = writable('Appearance');

    /* src/layouts/library/NoSong.svelte generated by Svelte v3.49.0 */
    const file$O = "src/layouts/library/NoSong.svelte";

    function create_fragment$T(ctx) {
    	let no_song_svlt;
    	let p;
    	let t1;
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			no_song_svlt = element("no-song-svlt");
    			p = element("p");
    			p.textContent = "No songs found!";
    			t1 = space();
    			button = element("button");
    			button.textContent = "Click here to add songs";
    			attr_dev(p, "class", "svelte-ybhhgv");
    			add_location(p, file$O, 9, 1, 276);
    			attr_dev(button, "class", "svelte-ybhhgv");
    			add_location(button, file$O, 10, 1, 300);
    			set_custom_element_data(no_song_svlt, "class", "svelte-ybhhgv");
    			add_location(no_song_svlt, file$O, 8, 0, 260);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, no_song_svlt, anchor);
    			append_dev(no_song_svlt, p);
    			append_dev(no_song_svlt, t1);
    			append_dev(no_song_svlt, button);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[1], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(no_song_svlt);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$T.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$T($$self, $$props, $$invalidate) {
    	let $layoutToShow;
    	let $selectedConfigOptionName;
    	validate_store(layoutToShow, 'layoutToShow');
    	component_subscribe($$self, layoutToShow, $$value => $$invalidate(2, $layoutToShow = $$value));
    	validate_store(selectedConfigOptionName, 'selectedConfigOptionName');
    	component_subscribe($$self, selectedConfigOptionName, $$value => $$invalidate(3, $selectedConfigOptionName = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('NoSong', slots, []);

    	function handleAddFolder() {
    		set_store_value(selectedConfigOptionName, $selectedConfigOptionName = 'Library', $selectedConfigOptionName);
    		set_store_value(layoutToShow, $layoutToShow = 'Config', $layoutToShow);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<NoSong> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => handleAddFolder();

    	$$self.$capture_state = () => ({
    		layoutToShow,
    		selectedConfigOptionName,
    		handleAddFolder,
    		$layoutToShow,
    		$selectedConfigOptionName
    	});

    	return [handleAddFolder, click_handler];
    }

    class NoSong extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$T, create_fragment$T, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NoSong",
    			options,
    			id: create_fragment$T.name
    		});
    	}
    }

    /* src/components/Star.svelte generated by Svelte v3.49.0 */
    const file$N = "src/components/Star.svelte";

    function create_fragment$S(ctx) {
    	let stars;
    	let img0;
    	let img0_class_value;
    	let img0_src_value;
    	let t;
    	let img1;
    	let img1_class_value;
    	let img1_src_value;
    	let stars_class_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			stars = element("stars");
    			img0 = element("img");
    			t = space();
    			img1 = element("img");
    			attr_dev(img0, "class", img0_class_value = "delete-star " + /*klass*/ ctx[0] + " starFilter" + " svelte-1k3f6xu");
    			if (!src_url_equal(img0.src, img0_src_value = `assets/img/star/star-delete.svg`)) attr_dev(img0, "src", img0_src_value);
    			attr_dev(img0, "alt", "");
    			add_location(img0, file$N, 42, 1, 1272);
    			attr_dev(img1, "class", img1_class_value = "star starFilter " + /*klass*/ ctx[0] + " svelte-1k3f6xu");
    			if (!src_url_equal(img1.src, img1_src_value = `assets/img/star/star-${/*starRating*/ ctx[1]}.svg`)) attr_dev(img1, "src", img1_src_value);
    			attr_dev(img1, "alt", "");
    			add_location(img1, file$N, 57, 1, 1779);
    			attr_dev(stars, "class", stars_class_value = "" + (null_to_empty(/*klass*/ ctx[0]) + " svelte-1k3f6xu"));
    			add_location(stars, file$N, 41, 0, 1186);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, stars, anchor);
    			append_dev(stars, img0);
    			append_dev(stars, t);
    			append_dev(stars, img1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(img0, "click", /*click_handler*/ ctx[7], false, false, false),
    					listen_dev(img1, "mouseleave", /*mouseleave_handler*/ ctx[8], false, false, false),
    					listen_dev(img1, "click", /*click_handler_1*/ ctx[9], false, false, false),
    					listen_dev(img1, "mousemove", /*mousemove_handler*/ ctx[10], false, false, false),
    					listen_dev(
    						stars,
    						"click",
    						function () {
    							if (is_function(/*dispatch*/ ctx[3]('starChange', { rating: /*starRating*/ ctx[1] * 10 }))) /*dispatch*/ ctx[3]('starChange', { rating: /*starRating*/ ctx[1] * 10 }).apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;

    			if (dirty & /*klass*/ 1 && img0_class_value !== (img0_class_value = "delete-star " + /*klass*/ ctx[0] + " starFilter" + " svelte-1k3f6xu")) {
    				attr_dev(img0, "class", img0_class_value);
    			}

    			if (dirty & /*klass*/ 1 && img1_class_value !== (img1_class_value = "star starFilter " + /*klass*/ ctx[0] + " svelte-1k3f6xu")) {
    				attr_dev(img1, "class", img1_class_value);
    			}

    			if (dirty & /*starRating*/ 2 && !src_url_equal(img1.src, img1_src_value = `assets/img/star/star-${/*starRating*/ ctx[1]}.svg`)) {
    				attr_dev(img1, "src", img1_src_value);
    			}

    			if (dirty & /*klass*/ 1 && stars_class_value !== (stars_class_value = "" + (null_to_empty(/*klass*/ ctx[0]) + " svelte-1k3f6xu"))) {
    				attr_dev(stars, "class", stars_class_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(stars);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$S.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$S($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Star', slots, []);
    	const dispatch = createEventDispatcher();
    	let { songRating = 0 } = $$props;
    	let { hook } = $$props;
    	let { klass = '' } = $$props;
    	let starRating = 0;
    	let starRatingTemp = 0; // Keeps track of the user selected rating.
    	let starElementWidth = undefined;

    	function convertRating(fnSongRating) {
    		// Converts 0-100 Rating to 0-10
    		if (fnSongRating && fnSongRating !== 0) {
    			$$invalidate(1, starRating = fnSongRating / 10);
    		} else {
    			$$invalidate(1, starRating = 0);
    		}

    		$$invalidate(2, starRatingTemp = starRating);
    	}

    	function setStarRating(e) {
    		if (!starElementWidth) {
    			let starElement = document.querySelector(`${hook} img.star`);

    			if (starElement) {
    				starElementWidth = starElement.scrollWidth;
    			} else {
    				return;
    			}
    		}

    		// Gets a value from 0 to 10 based on the percentage of the cursor position on star element.
    		let starValue = Math.trunc(100 / starElementWidth * e.offsetX / (100 / 10)) + 1;

    		if (starValue <= 1) {
    			starValue = 1;
    		} else if (starValue >= 10) {
    			starValue = 10;
    		}

    		$$invalidate(1, starRating = starValue);
    	}

    	const writable_props = ['songRating', 'hook', 'klass'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Star> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		$$invalidate(1, starRating = 0);
    		$$invalidate(2, starRatingTemp = 0);
    	};

    	const mouseleave_handler = () => $$invalidate(1, starRating = starRatingTemp);
    	const click_handler_1 = () => $$invalidate(2, starRatingTemp = starRating);
    	const mousemove_handler = e => setStarRating(e);

    	$$self.$$set = $$props => {
    		if ('songRating' in $$props) $$invalidate(5, songRating = $$props.songRating);
    		if ('hook' in $$props) $$invalidate(6, hook = $$props.hook);
    		if ('klass' in $$props) $$invalidate(0, klass = $$props.klass);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		dispatch,
    		songRating,
    		hook,
    		klass,
    		starRating,
    		starRatingTemp,
    		starElementWidth,
    		convertRating,
    		setStarRating
    	});

    	$$self.$inject_state = $$props => {
    		if ('songRating' in $$props) $$invalidate(5, songRating = $$props.songRating);
    		if ('hook' in $$props) $$invalidate(6, hook = $$props.hook);
    		if ('klass' in $$props) $$invalidate(0, klass = $$props.klass);
    		if ('starRating' in $$props) $$invalidate(1, starRating = $$props.starRating);
    		if ('starRatingTemp' in $$props) $$invalidate(2, starRatingTemp = $$props.starRatingTemp);
    		if ('starElementWidth' in $$props) starElementWidth = $$props.starElementWidth;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*songRating*/ 32) {
    			convertRating(songRating);
    		}
    	};

    	return [
    		klass,
    		starRating,
    		starRatingTemp,
    		dispatch,
    		setStarRating,
    		songRating,
    		hook,
    		click_handler,
    		mouseleave_handler,
    		click_handler_1,
    		mousemove_handler
    	];
    }

    class Star extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$S, create_fragment$S, safe_not_equal, { songRating: 5, hook: 6, klass: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Star",
    			options,
    			id: create_fragment$S.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*hook*/ ctx[6] === undefined && !('hook' in props)) {
    			console.warn("<Star> was created without expected prop 'hook'");
    		}
    	}

    	get songRating() {
    		throw new Error("<Star>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set songRating(value) {
    		throw new Error("<Star>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hook() {
    		throw new Error("<Star>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hook(value) {
    		throw new Error("<Star>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get klass() {
    		throw new Error("<Star>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set klass(value) {
    		throw new Error("<Star>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/SongTag.svelte generated by Svelte v3.49.0 */
    const file$M = "src/components/SongTag.svelte";

    // (62:0) {:else}
    function create_else_block$6(ctx) {
    	let star;
    	let current;

    	star = new Star({
    			props: {
    				songRating: /*tagValue*/ ctx[2],
    				hook: "song-list-item"
    			},
    			$$inline: true
    		});

    	star.$on("starChange", /*starChange_handler*/ ctx[6]);

    	const block = {
    		c: function create() {
    			create_component(star.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(star, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const star_changes = {};
    			if (dirty & /*tagValue*/ 4) star_changes.songRating = /*tagValue*/ ctx[2];
    			star.$set(star_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(star.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(star.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(star, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$6.name,
    		type: "else",
    		source: "(62:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (60:0) {#if tagName !== 'Rating'}
    function create_if_block$a(ctx) {
    	let span;
    	let t_value = /*parseTag*/ ctx[5](/*tagName*/ ctx[1], /*tagValue*/ ctx[2]) + "";
    	let t;
    	let span_class_value;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			attr_dev(span, "class", span_class_value = "" + (null_to_empty(/*tagName*/ ctx[1]) + " svelte-1787zh1"));
    			attr_dev(span, "data-tippy-content", /*originalTagValue*/ ctx[3]);
    			set_style(span, "text-align", /*align*/ ctx[0]);
    			add_location(span, file$M, 60, 1, 1772);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*tagName, tagValue*/ 6 && t_value !== (t_value = /*parseTag*/ ctx[5](/*tagName*/ ctx[1], /*tagValue*/ ctx[2]) + "")) set_data_dev(t, t_value);

    			if (dirty & /*tagName*/ 2 && span_class_value !== (span_class_value = "" + (null_to_empty(/*tagName*/ ctx[1]) + " svelte-1787zh1"))) {
    				attr_dev(span, "class", span_class_value);
    			}

    			if (dirty & /*originalTagValue*/ 8) {
    				attr_dev(span, "data-tippy-content", /*originalTagValue*/ ctx[3]);
    			}

    			if (dirty & /*align*/ 1) {
    				set_style(span, "text-align", /*align*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$a.name,
    		type: "if",
    		source: "(60:0) {#if tagName !== 'Rating'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$R(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$a, create_else_block$6];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*tagName*/ ctx[1] !== 'Rating') return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$R.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function bytesToMebibytes(bytesValue) {
    	return bytesValue / Math.pow(2, 20);
    }

    function truncateString(value) {
    	value = String(value).split('.');
    	return `${value[0]}.${value[1].substring(0, 2)}`;
    }

    function instance$R($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SongTag', slots, []);
    	let { align } = $$props;
    	let { tagName } = $$props;
    	let { tagValue } = $$props;
    	let originalTagValue;
    	let dispatch = createEventDispatcher();

    	function parseTag(tagName, tagValue) {
    		if (tagName === 'Duration') return parseDuration(tagValue);

    		if (tagName === 'PlayCount') {
    			if (tagValue > 999) {
    				$$invalidate(3, originalTagValue = tagValue);

    				setTimeout(
    					() => {
    						tippy('[data-tippy-content]', defaultTippyOptions);
    					},
    					1000
    				);

    				return '•••';
    			}

    			return tagValue || 0;
    		}

    		return tagValue;
    	}

    	const writable_props = ['align', 'tagName', 'tagValue'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SongTag> was created with unknown prop '${key}'`);
    	});

    	const starChange_handler = evt => dispatch('starChange', evt.detail);

    	$$self.$$set = $$props => {
    		if ('align' in $$props) $$invalidate(0, align = $$props.align);
    		if ('tagName' in $$props) $$invalidate(1, tagName = $$props.tagName);
    		if ('tagValue' in $$props) $$invalidate(2, tagValue = $$props.tagValue);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		tippy,
    		parseDuration,
    		defaultTippyOptions,
    		Star,
    		align,
    		tagName,
    		tagValue,
    		originalTagValue,
    		dispatch,
    		bytesToMebibytes,
    		truncateString,
    		parseTag
    	});

    	$$self.$inject_state = $$props => {
    		if ('align' in $$props) $$invalidate(0, align = $$props.align);
    		if ('tagName' in $$props) $$invalidate(1, tagName = $$props.tagName);
    		if ('tagValue' in $$props) $$invalidate(2, tagValue = $$props.tagValue);
    		if ('originalTagValue' in $$props) $$invalidate(3, originalTagValue = $$props.originalTagValue);
    		if ('dispatch' in $$props) $$invalidate(4, dispatch = $$props.dispatch);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		align,
    		tagName,
    		tagValue,
    		originalTagValue,
    		dispatch,
    		parseTag,
    		starChange_handler
    	];
    }

    class SongTag extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$R, create_fragment$R, safe_not_equal, { align: 0, tagName: 1, tagValue: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SongTag",
    			options,
    			id: create_fragment$R.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*align*/ ctx[0] === undefined && !('align' in props)) {
    			console.warn("<SongTag> was created without expected prop 'align'");
    		}

    		if (/*tagName*/ ctx[1] === undefined && !('tagName' in props)) {
    			console.warn("<SongTag> was created without expected prop 'tagName'");
    		}

    		if (/*tagValue*/ ctx[2] === undefined && !('tagValue' in props)) {
    			console.warn("<SongTag> was created without expected prop 'tagValue'");
    		}
    	}

    	get align() {
    		throw new Error("<SongTag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set align(value) {
    		throw new Error("<SongTag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tagName() {
    		throw new Error("<SongTag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tagName(value) {
    		throw new Error("<SongTag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tagValue() {
    		throw new Error("<SongTag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tagValue(value) {
    		throw new Error("<SongTag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function tagToGridStyleFn (tags) {
        let gridStyle = '';
        if (tags.length > 0) {
            tags.forEach(tag => {
                if (!(tag.value === 'DynamicArtists' && tags.find(t => t.value === 'Title'))) {
                    if (tag.isExpanded === false) {
                        gridStyle += ' max-content';
                    }
                    else if (tag.isExpanded === true) {
                        gridStyle += ' auto';
                    }
                }
            });
        }
        return gridStyle;
    }

    /* src/components/SongListItem.svelte generated by Svelte v3.49.0 */
    const file$L = "src/components/SongListItem.svelte";

    function get_each_context$b(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[12] = list[i];
    	child_ctx[1] = i;
    	return child_ctx;
    }

    // (68:1) {#if isSongPlaying === true}
    function create_if_block_2$2(ctx) {
    	let playbutton;
    	let current;

    	playbutton = new PlayButton({
    			props: {
    				customSize: "0.75rem",
    				customColor: "#fff"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(playbutton.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(playbutton, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(playbutton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(playbutton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(playbutton, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(68:1) {#if isSongPlaying === true}",
    		ctx
    	});

    	return block;
    }

    // (81:2) {:else}
    function create_else_block$5(ctx) {
    	let songtag;
    	let current;

    	songtag = new SongTag({
    			props: {
    				tagName: /*tag*/ ctx[12].value,
    				tagValue: /*song*/ ctx[0][/*tag*/ ctx[12].value] || '',
    				align: /*tag*/ ctx[12]?.align?.toLowerCase()
    			},
    			$$inline: true
    		});

    	songtag.$on("starChange", /*setStar*/ ctx[7]);

    	const block = {
    		c: function create() {
    			create_component(songtag.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(songtag, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const songtag_changes = {};
    			if (dirty & /*$config*/ 8) songtag_changes.tagName = /*tag*/ ctx[12].value;
    			if (dirty & /*song, $config*/ 9) songtag_changes.tagValue = /*song*/ ctx[0][/*tag*/ ctx[12].value] || '';
    			if (dirty & /*$config*/ 8) songtag_changes.align = /*tag*/ ctx[12]?.align?.toLowerCase();
    			songtag.$set(songtag_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(songtag.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(songtag.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(songtag, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$5.name,
    		type: "else",
    		source: "(81:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (79:115) 
    function create_if_block_1$4(ctx) {
    	const block = {
    		c: noop,
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(79:115) ",
    		ctx
    	});

    	return block;
    }

    // (72:2) {#if tag.value === 'Title' && $config.songListTags.find(configTag => configTag.value === 'DynamicArtists')}
    function create_if_block$9(ctx) {
    	let songtag;
    	let current;

    	songtag = new SongTag({
    			props: {
    				tagName: /*tag*/ ctx[12].value,
    				tagValue: `${/*song*/ ctx[0][/*tag*/ ctx[12].value]} ${/*song*/ ctx[0].DynamicArtists}` || '',
    				align: /*tag*/ ctx[12]?.align?.toLowerCase()
    			},
    			$$inline: true
    		});

    	songtag.$on("starChange", /*setStar*/ ctx[7]);

    	const block = {
    		c: function create() {
    			create_component(songtag.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(songtag, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const songtag_changes = {};
    			if (dirty & /*$config*/ 8) songtag_changes.tagName = /*tag*/ ctx[12].value;
    			if (dirty & /*song, $config*/ 9) songtag_changes.tagValue = `${/*song*/ ctx[0][/*tag*/ ctx[12].value]} ${/*song*/ ctx[0].DynamicArtists}` || '';
    			if (dirty & /*$config*/ 8) songtag_changes.align = /*tag*/ ctx[12]?.align?.toLowerCase();
    			songtag.$set(songtag_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(songtag.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(songtag.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(songtag, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$9.name,
    		type: "if",
    		source: "(72:2) {#if tag.value === 'Title' && $config.songListTags.find(configTag => configTag.value === 'DynamicArtists')}",
    		ctx
    	});

    	return block;
    }

    // (71:1) {#each $config.songListTags as tag, index (index)}
    function create_each_block$b(key_1, ctx) {
    	let first;
    	let show_if;
    	let show_if_1;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$9, create_if_block_1$4, create_else_block$5];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (dirty & /*$config*/ 8) show_if = null;
    		if (dirty & /*$config*/ 8) show_if_1 = null;
    		if (show_if == null) show_if = !!(/*tag*/ ctx[12].value === 'Title' && /*$config*/ ctx[3].songListTags.find(func));
    		if (show_if) return 0;
    		if (show_if_1 == null) show_if_1 = !!(/*tag*/ ctx[12].value === 'DynamicArtists' || !/*$config*/ ctx[3].songListTags.find(func_1));
    		if (show_if_1) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(ctx, -1);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			if_block.c();
    			if_block_anchor = empty();
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx, dirty);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$b.name,
    		type: "each",
    		source: "(71:1) {#each $config.songListTags as tag, index (index)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$Q(ctx) {
    	let song_list_item;
    	let t;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let song_list_item_data_id_value;
    	let song_list_item_class_value;
    	let current;
    	let if_block = /*isSongPlaying*/ ctx[2] === true && create_if_block_2$2(ctx);
    	let each_value = /*$config*/ ctx[3].songListTags;
    	validate_each_argument(each_value);
    	const get_key = ctx => /*index*/ ctx[1];
    	validate_each_keys(ctx, each_value, get_each_context$b, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$b(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$b(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			song_list_item = element("song-list-item");
    			if (if_block) if_block.c();
    			t = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			set_custom_element_data(song_list_item, "data-id", song_list_item_data_id_value = /*song*/ ctx[0].ID);
    			set_custom_element_data(song_list_item, "data-index", /*index*/ ctx[1]);
    			set_style(song_list_item, "grid-template-columns", /*gridStyle*/ ctx[4]);

    			set_custom_element_data(song_list_item, "class", song_list_item_class_value = "" + (/*song*/ ctx[0].isEnabled === false ? 'disabled' : '') + " " + (/*$activeSongStore*/ ctx[5] === /*song*/ ctx[0].ID
    			? 'active'
    			: '') + " " + (/*$selectedSongsStore*/ ctx[6].includes(/*song*/ ctx[0].ID)
    			? 'selected'
    			: '') + " svelte-ha0qo7");

    			add_location(song_list_item, file$L, 58, 0, 2057);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, song_list_item, anchor);
    			if (if_block) if_block.m(song_list_item, null);
    			append_dev(song_list_item, t);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(song_list_item, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*isSongPlaying*/ ctx[2] === true) {
    				if (if_block) {
    					if (dirty & /*isSongPlaying*/ 4) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_2$2(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(song_list_item, t);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (dirty & /*$config, song, setStar*/ 137) {
    				each_value = /*$config*/ ctx[3].songListTags;
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$b, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, song_list_item, outro_and_destroy_block, create_each_block$b, null, get_each_context$b);
    				check_outros();
    			}

    			if (!current || dirty & /*song*/ 1 && song_list_item_data_id_value !== (song_list_item_data_id_value = /*song*/ ctx[0].ID)) {
    				set_custom_element_data(song_list_item, "data-id", song_list_item_data_id_value);
    			}

    			if (!current || dirty & /*index*/ 2) {
    				set_custom_element_data(song_list_item, "data-index", /*index*/ ctx[1]);
    			}

    			if (!current || dirty & /*gridStyle*/ 16) {
    				set_style(song_list_item, "grid-template-columns", /*gridStyle*/ ctx[4]);
    			}

    			if (!current || dirty & /*song, $activeSongStore, $selectedSongsStore*/ 97 && song_list_item_class_value !== (song_list_item_class_value = "" + (/*song*/ ctx[0].isEnabled === false ? 'disabled' : '') + " " + (/*$activeSongStore*/ ctx[5] === /*song*/ ctx[0].ID
    			? 'active'
    			: '') + " " + (/*$selectedSongsStore*/ ctx[6].includes(/*song*/ ctx[0].ID)
    			? 'selected'
    			: '') + " svelte-ha0qo7")) {
    				set_custom_element_data(song_list_item, "class", song_list_item_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(song_list_item);
    			if (if_block) if_block.d();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const func = configTag => configTag.value === 'DynamicArtists';
    const func_1 = configTag => configTag.value === 'Title';

    function instance$Q($$self, $$props, $$invalidate) {
    	let $config;
    	let $songListItemElement;
    	let $playingSongStore;
    	let $activeSongStore;
    	let $selectedSongsStore;
    	validate_store(config, 'config');
    	component_subscribe($$self, config, $$value => $$invalidate(3, $config = $$value));
    	validate_store(songListItemElement, 'songListItemElement');
    	component_subscribe($$self, songListItemElement, $$value => $$invalidate(9, $songListItemElement = $$value));
    	validate_store(playingSongStore, 'playingSongStore');
    	component_subscribe($$self, playingSongStore, $$value => $$invalidate(8, $playingSongStore = $$value));
    	validate_store(activeSongStore, 'activeSongStore');
    	component_subscribe($$self, activeSongStore, $$value => $$invalidate(5, $activeSongStore = $$value));
    	validate_store(selectedSongsStore, 'selectedSongsStore');
    	component_subscribe($$self, selectedSongsStore, $$value => $$invalidate(6, $selectedSongsStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SongListItem', slots, []);
    	let { song } = $$props;
    	let { index } = $$props;
    	let isSongPlaying = false;
    	let gridStyle = '';

    	onMount(() => {
    		// let lastPlayedSongId = Number(localStorage.getItem('LastPlayedSongId'))
    		// $songPlayingIdStore = lastPlayedSongId
    		if ($songListItemElement === undefined) {
    			set_store_value(songListItemElement, $songListItemElement = document.querySelector('song-list-item'), $songListItemElement);
    		}
    	});

    	function buildGridStyle() {
    		let tempGridStyle = tagToGridStyleFn($config.songListTags);

    		if (song.isEnabled === false) {
    			tempGridStyle = 'max-content ' + tempGridStyle;
    		}

    		if (isSongPlaying) {
    			tempGridStyle = 'max-content ' + tempGridStyle;
    		}

    		$$invalidate(4, gridStyle = tempGridStyle);
    	}

    	function setDynamicArtists() {
    		if (!(song === null || song === void 0
    		? void 0
    		: song.AlbumArtist) || !(song === null || song === void 0 ? void 0 : song.Artist)) {
    			$$invalidate(0, song.DynamicArtists = '', song);
    			return;
    		}

    		let splitArtists = song.Artist.split('//').filter(artist => !song.AlbumArtist.includes(artist));

    		if (splitArtists.length > 0) {
    			$$invalidate(0, song.DynamicArtists = `(feat. ${splitArtists.join('//')})`, song);
    		} else {
    			$$invalidate(0, song.DynamicArtists = '', song);
    		}
    	}

    	function setStar(starChangeEvent) {
    		window.ipc.updateSongs([song], { Rating: starChangeEvent.detail.rating });
    	}

    	const writable_props = ['song', 'index'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SongListItem> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('song' in $$props) $$invalidate(0, song = $$props.song);
    		if ('index' in $$props) $$invalidate(1, index = $$props.index);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		activeSongStore,
    		config,
    		playingSongStore,
    		selectedSongsStore,
    		songListItemElement,
    		SongTag,
    		tagToGridStyleFn,
    		PlayButton,
    		song,
    		index,
    		isSongPlaying,
    		gridStyle,
    		buildGridStyle,
    		setDynamicArtists,
    		setStar,
    		$config,
    		$songListItemElement,
    		$playingSongStore,
    		$activeSongStore,
    		$selectedSongsStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('song' in $$props) $$invalidate(0, song = $$props.song);
    		if ('index' in $$props) $$invalidate(1, index = $$props.index);
    		if ('isSongPlaying' in $$props) $$invalidate(2, isSongPlaying = $$props.isSongPlaying);
    		if ('gridStyle' in $$props) $$invalidate(4, gridStyle = $$props.gridStyle);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$playingSongStore, song*/ 257) {
    			$$invalidate(2, isSongPlaying = ($playingSongStore === null || $playingSongStore === void 0
    			? void 0
    			: $playingSongStore.ID) === (song === null || song === void 0 ? void 0 : song.ID));
    		}

    		if ($$self.$$.dirty & /*song*/ 1) {
    			{
    				setDynamicArtists();
    			}
    		}

    		if ($$self.$$.dirty & /*song, $config, isSongPlaying*/ 13) {
    			{

    				// TODO Potential problem here.
    				$config.songListTags;
    				buildGridStyle();
    			}
    		}
    	};

    	return [
    		song,
    		index,
    		isSongPlaying,
    		$config,
    		gridStyle,
    		$activeSongStore,
    		$selectedSongsStore,
    		setStar,
    		$playingSongStore
    	];
    }

    class SongListItem extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Q, create_fragment$Q, safe_not_equal, { song: 0, index: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SongListItem",
    			options,
    			id: create_fragment$Q.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*song*/ ctx[0] === undefined && !('song' in props)) {
    			console.warn("<SongListItem> was created without expected prop 'song'");
    		}

    		if (/*index*/ ctx[1] === undefined && !('index' in props)) {
    			console.warn("<SongListItem> was created without expected prop 'index'");
    		}
    	}

    	get song() {
    		throw new Error("<SongListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set song(value) {
    		throw new Error("<SongListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get index() {
    		throw new Error("<SongListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set index(value) {
    		throw new Error("<SongListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function songListClickEventHandlerService (e) {
        let keyModifier = {
            ctrlKey: e.ctrlKey || e.metaKey,
            shiftKey: e.shiftKey,
            altKey: e.altKey
        };
        let element = getElementFromEvent(e, 'SONG-LIST-ITEM');
        if (element === undefined)
            return;
        let dataSet = element.dataset;
        if (keyModifier.ctrlKey === false && keyModifier.shiftKey === false && keyModifier.altKey === false) {
            selectedSongsStore.set([+dataSet.id]);
        }
        if (keyModifier.ctrlKey === true && keyModifier.shiftKey === false && keyModifier.altKey === false) {
            ctrlKeySelect(dataSet);
        }
        if (keyModifier.ctrlKey === false && keyModifier.shiftKey === true && keyModifier.altKey === false) {
            shiftKeySelect(dataSet);
        }
        return true;
    }
    function shiftKeySelect(dataSet) {
        let selectedSongs = undefined;
        let songList = undefined;
        selectedSongsStore.subscribe(_ => (selectedSongs = _));
        songListStore.subscribe(_ => (songList = _));
        let selectedSongIndex = songList.findIndex(song => song.ID === +dataSet.id);
        let lastSongIndex = songList.findIndex(song => song.ID === selectedSongs.at(-1));
        for (let i = selectedSongIndex; i !== lastSongIndex; selectedSongIndex < lastSongIndex ? i++ : i--) {
            let currentId = songList[i].ID;
            selectedSongs.push(currentId);
        }
        selectedSongsStore.set(selectedSongs);
    }
    function ctrlKeySelect(dataSet) {
        let selectedSongs = undefined;
        selectedSongsStore.subscribe(_ => (selectedSongs = _));
        let index = selectedSongs.indexOf(+dataSet.id);
        if (index === -1) {
            selectedSongs.push(+dataSet.id);
        }
        else {
            selectedSongs.splice(index, 1);
        }
        selectedSongsStore.set(selectedSongs);
    }
    function getElementFromEvent(event, targetElementName) {
        let elements = event.composedPath();
        for (let element of elements) {
            if (element.tagName === targetElementName) {
                return element;
            }
        }
        return undefined;
    }

    function isValidPathFn (event, validPaths) {
        return event
            .composedPath() // Return back an array of all elements clicked.
            .map((path) => path.tagName) // Gives only the tag name of the elements.
            .find(tag => validPaths.includes(tag)); // If the tag name matches the array of valid values.
    }

    /* src/layouts/components/SongListScrollBar.svelte generated by Svelte v3.49.0 */
    const file$K = "src/layouts/components/SongListScrollBar.svelte";

    function create_fragment$P(ctx) {
    	let song_list_scroll_bar;
    	let scrollbar_fill;

    	const block = {
    		c: function create() {
    			song_list_scroll_bar = element("song-list-scroll-bar");
    			scrollbar_fill = element("scrollbar-fill");
    			set_custom_element_data(scrollbar_fill, "class", "svelte-rcr1wd");
    			add_location(scrollbar_fill, file$K, 64, 1, 3247);
    			set_custom_element_data(song_list_scroll_bar, "class", "svelte-rcr1wd");
    			add_location(song_list_scroll_bar, file$K, 63, 0, 3223);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, song_list_scroll_bar, anchor);
    			append_dev(song_list_scroll_bar, scrollbar_fill);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(song_list_scroll_bar);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$P.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$P($$self, $$props, $$invalidate) {
    	let $songListStore;
    	validate_store(songListStore, 'songListStore');
    	component_subscribe($$self, songListStore, $$value => $$invalidate(2, $songListStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SongListScrollBar', slots, []);
    	const dispatch = createEventDispatcher();
    	let isMouseDownInScroll = false;

    	// Improves detection by reducing the amount of times the mousemove event is triggered and dispatches and event.
    	let previousScrollAmountDispatched = 0;

    	function scrollBarHandler() {
    		let songListScrollBar = document.querySelector('song-list-scroll-bar');

    		// Handles moving the cursor over the "scrollbar" then moving out of it so the "scrolling" does not stop abruptly.
    		document.addEventListener('mousemove', e => {
    			// Checks if the other event triggered a mouse down on the "scrollbar".
    			if (isMouseDownInScroll) {
    				// Returns the position (top and height) on screen of the "scrollbar".
    				let { top, height } = songListScrollBar.getBoundingClientRect();

    				// Calculates the difference between the current cursor position on screen relative to the "scrollbar".
    				let difference = e.clientY - top;

    				// Calculates the percentage of scroll.
    				// 0% and lower would mean that the cursor is at the top and beyond the scrollbar.
    				// 100% and above would mean that the cursor is at the bottom and beyond the scrollbar.
    				let percentage = 100 / height * difference;

    				// If the percent is higher than 100% block the percent to 100%.
    				if (percentage >= 100) {
    					percentage = 100;
    				} else if (percentage <= 0) {
    					percentage = 0; // If the percent is lower than 0% block the percent to 0%.
    				}

    				// Sets the scrollAmount value with the newly calculated one.
    				dispatchScrollAmount(($songListStore.length - 1) / 100 * percentage);
    			}
    		});

    		// If the user clicks on either the scroll bar or the progress fill, set isMouseDownInScroll to true.
    		document.addEventListener('mousedown', e => {
    			if (isValidPathFn(e, ['SONG-LIST-SCROLL-BAR', 'SCROLLBAR-FILL'])) {
    				isMouseDownInScroll = true;
    			}
    		});

    		// Anywhere the user releases the mouse button, sets isMouseDownInScroll to false.
    		document.addEventListener('mouseup', () => {
    			isMouseDownInScroll = false;
    		});

    		// If the user click on the scrollbar, calls setScrollAmountBar.
    		songListScrollBar.addEventListener('click', evt => setScrollAmountBar(songListScrollBar, evt));
    	}

    	// Sets the proper scrollAmount based of the percentage (in distance) of the bar clicked. 0% = top and 100% = bottom.
    	function setScrollAmountBar(songListScrollBar, e) {
    		let percentClick = 100 / songListScrollBar.clientHeight * e.offsetY;
    		dispatchScrollAmount($songListStore.length / 100 * percentClick);
    	}

    	function dispatchScrollAmount(scrollAmount) {
    		scrollAmount = Math.trunc(scrollAmount);

    		if (scrollAmount !== previousScrollAmountDispatched) {
    			dispatch('songListBarScrolled', scrollAmount);
    			previousScrollAmountDispatched = scrollAmount;
    		}
    	}

    	onMount(() => {
    		scrollBarHandler();
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SongListScrollBar> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		createEventDispatcher,
    		isValidPathFn,
    		songListStore,
    		dispatch,
    		isMouseDownInScroll,
    		previousScrollAmountDispatched,
    		scrollBarHandler,
    		setScrollAmountBar,
    		dispatchScrollAmount,
    		$songListStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('isMouseDownInScroll' in $$props) isMouseDownInScroll = $$props.isMouseDownInScroll;
    		if ('previousScrollAmountDispatched' in $$props) previousScrollAmountDispatched = $$props.previousScrollAmountDispatched;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [];
    }

    class SongListScrollBar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$P, create_fragment$P, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SongListScrollBar",
    			options,
    			id: create_fragment$P.name
    		});
    	}
    }

    /* src/layouts/library/SongList.svelte generated by Svelte v3.49.0 */
    const file$J = "src/layouts/library/SongList.svelte";

    function get_each_context$a(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i];
    	child_ctx[18] = i;
    	return child_ctx;
    }

    // (83:2) {#each songsToShow as song, index (song.ID)}
    function create_each_block$a(key_1, ctx) {
    	let first;
    	let songlistitem;
    	let current;

    	songlistitem = new SongListItem({
    			props: {
    				song: /*song*/ ctx[16],
    				index: /*index*/ ctx[18]
    			},
    			$$inline: true
    		});

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(songlistitem.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(songlistitem, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const songlistitem_changes = {};
    			if (dirty & /*songsToShow*/ 1) songlistitem_changes.song = /*song*/ ctx[16];
    			if (dirty & /*songsToShow*/ 1) songlistitem_changes.index = /*index*/ ctx[18];
    			songlistitem.$set(songlistitem_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(songlistitem.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(songlistitem.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(songlistitem, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$a.name,
    		type: "each",
    		source: "(83:2) {#each songsToShow as song, index (song.ID)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$O(ctx) {
    	let song_list_svlt;
    	let song_list;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let t;
    	let songlistscrollbar;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*songsToShow*/ ctx[0];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*song*/ ctx[16].ID;
    	validate_each_keys(ctx, each_value, get_each_context$a, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$a(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$a(key, child_ctx));
    	}

    	songlistscrollbar = new SongListScrollBar({ $$inline: true });
    	songlistscrollbar.$on("songListBarScrolled", /*onSongListBarScrolled*/ ctx[1]);

    	const block = {
    		c: function create() {
    			song_list_svlt = element("song-list-svlt");
    			song_list = element("song-list");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			create_component(songlistscrollbar.$$.fragment);
    			set_custom_element_data(song_list, "class", "svelte-91mkw9");
    			add_location(song_list, file$J, 81, 1, 2701);
    			set_custom_element_data(song_list_svlt, "class", "svelte-91mkw9");
    			add_location(song_list_svlt, file$J, 80, 0, 2591);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, song_list_svlt, anchor);
    			append_dev(song_list_svlt, song_list);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(song_list, null);
    			}

    			append_dev(song_list_svlt, t);
    			mount_component(songlistscrollbar, song_list_svlt, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(song_list_svlt, "mousewheel", /*mousewheel_handler*/ ctx[7], false, false, false),
    					listen_dev(song_list_svlt, "click", /*click_handler*/ ctx[8], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*songsToShow*/ 1) {
    				each_value = /*songsToShow*/ ctx[0];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$a, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, song_list, outro_and_destroy_block, create_each_block$a, null, get_each_context$a);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(songlistscrollbar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(songlistscrollbar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(song_list_svlt);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			destroy_component(songlistscrollbar);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$O.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$O($$self, $$props, $$invalidate) {
    	let $config;
    	let $songListStore;
    	let $triggerScrollToSongEvent;
    	let $selectedAlbumDir;
    	validate_store(config, 'config');
    	component_subscribe($$self, config, $$value => $$invalidate(3, $config = $$value));
    	validate_store(songListStore, 'songListStore');
    	component_subscribe($$self, songListStore, $$value => $$invalidate(4, $songListStore = $$value));
    	validate_store(triggerScrollToSongEvent, 'triggerScrollToSongEvent');
    	component_subscribe($$self, triggerScrollToSongEvent, $$value => $$invalidate(5, $triggerScrollToSongEvent = $$value));
    	validate_store(selectedAlbumDir, 'selectedAlbumDir');
    	component_subscribe($$self, selectedAlbumDir, $$value => $$invalidate(6, $selectedAlbumDir = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SongList', slots, []);
    	let songsToShow = [];
    	let scrollAmount = 0;
    	let previousScrollAmount = undefined;

    	// Trims the current song array to show a limited amount of songs.
    	function trimSongArray() {
    		if (scrollAmount !== previousScrollAmount) {
    			$$invalidate(0, songsToShow = $songListStore.slice(scrollAmount, scrollAmount + $config.userOptions.songAmount));

    			if (songsToShow.length > 0) {
    				previousScrollAmount = scrollAmount;
    			}
    		}
    	}

    	function setScrollAmount(amount) {
    		if ($songListStore.length <= 0) {
    			return;
    		}

    		if (amount <= 0) {
    			amount = 0;
    		} else if (amount > $songListStore.length - 1) {
    			amount = $songListStore.length - 1;
    		}

    		scrollAmount = amount;
    		trimSongArray();
    		setScrollProgress();
    	}

    	function onSongListBarScrolled(event) {
    		setScrollAmount(event.detail);
    	}

    	function setScrollProgress() {
    		let scrollValue = 100 / ($songListStore.length - 1) * scrollAmount | 0;
    		cssVariablesService.set('scrollbar-fill', `${scrollValue}%`);
    	}

    	function changeSongListHeight(songAmount) {
    		cssVariablesService.set('song-list-svlt-height', `${songAmount * 36 + 16}px`);
    	}

    	function scrollContainer(e) {
    		setScrollAmount(scrollAmount + Math.sign(e.deltaY));
    	}

    	// Manages to "scroll" to the proper song on demand.
    	function setScrollAmountFromSong(songId) {
    		let songIndex = $songListStore.findIndex(song => song.ID === songId);
    		let differenceAmount = Math.floor($config.userOptions.songAmount / 2);

    		if (songIndex !== -1) {
    			if (songIndex < differenceAmount) {
    				setScrollAmount(0);
    			} else {
    				setScrollAmount(songIndex - differenceAmount);
    			}
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SongList> was created with unknown prop '${key}'`);
    	});

    	const mousewheel_handler = e => scrollContainer(e);
    	const click_handler = e => songListClickEventHandlerService(e);

    	$$self.$capture_state = () => ({
    		SongListItem,
    		cssVariablesService,
    		songListClickEventHandlerService,
    		config,
    		selectedAlbumDir,
    		songListStore,
    		triggerScrollToSongEvent,
    		SongListScrollBar,
    		songsToShow,
    		scrollAmount,
    		previousScrollAmount,
    		trimSongArray,
    		setScrollAmount,
    		onSongListBarScrolled,
    		setScrollProgress,
    		changeSongListHeight,
    		scrollContainer,
    		setScrollAmountFromSong,
    		$config,
    		$songListStore,
    		$triggerScrollToSongEvent,
    		$selectedAlbumDir
    	});

    	$$self.$inject_state = $$props => {
    		if ('songsToShow' in $$props) $$invalidate(0, songsToShow = $$props.songsToShow);
    		if ('scrollAmount' in $$props) scrollAmount = $$props.scrollAmount;
    		if ('previousScrollAmount' in $$props) previousScrollAmount = $$props.previousScrollAmount;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$selectedAlbumDir*/ 64) {
    			{
    				previousScrollAmount = undefined;
    				setScrollAmount(0);
    			}
    		}

    		if ($$self.$$.dirty & /*$songListStore, $config*/ 24) {
    			// Main Song List refresh trigger
    			{
    				$config.userOptions.songAmount;
    				previousScrollAmount = undefined;
    				trimSongArray();
    			}
    		}

    		if ($$self.$$.dirty & /*$config*/ 8) {
    			{
    				changeSongListHeight($config.userOptions.songAmount);
    			}
    		}

    		if ($$self.$$.dirty & /*$triggerScrollToSongEvent*/ 32) {
    			{
    				if ($triggerScrollToSongEvent !== 0) {
    					setScrollAmountFromSong($triggerScrollToSongEvent);
    					set_store_value(triggerScrollToSongEvent, $triggerScrollToSongEvent = 0, $triggerScrollToSongEvent);
    				}
    			}
    		}
    	};

    	return [
    		songsToShow,
    		onSongListBarScrolled,
    		scrollContainer,
    		$config,
    		$songListStore,
    		$triggerScrollToSongEvent,
    		$selectedAlbumDir,
    		mousewheel_handler,
    		click_handler
    	];
    }

    class SongList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$O, create_fragment$O, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SongList",
    			options,
    			id: create_fragment$O.name
    		});
    	}
    }

    /* src/layouts/library/SongListBackground.svelte generated by Svelte v3.49.0 */
    const file$I = "src/layouts/library/SongListBackground.svelte";

    function create_fragment$N(ctx) {
    	let song_list_background_svlt;
    	let backdrop;
    	let t;
    	let albumart;
    	let current;

    	albumart = new AlbumArt({
    			props: {
    				imageSourceLocation: /*$selectedAlbumDir*/ ctx[0]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			song_list_background_svlt = element("song-list-background-svlt");
    			backdrop = element("backdrop");
    			t = space();
    			create_component(albumart.$$.fragment);
    			attr_dev(backdrop, "class", "svelte-1lseuey");
    			add_location(backdrop, file$I, 5, 1, 175);
    			set_custom_element_data(song_list_background_svlt, "class", "svelte-1lseuey");
    			add_location(song_list_background_svlt, file$I, 4, 0, 146);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, song_list_background_svlt, anchor);
    			append_dev(song_list_background_svlt, backdrop);
    			append_dev(song_list_background_svlt, t);
    			mount_component(albumart, song_list_background_svlt, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const albumart_changes = {};
    			if (dirty & /*$selectedAlbumDir*/ 1) albumart_changes.imageSourceLocation = /*$selectedAlbumDir*/ ctx[0];
    			albumart.$set(albumart_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(albumart.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(albumart.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(song_list_background_svlt);
    			destroy_component(albumart);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$N.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$N($$self, $$props, $$invalidate) {
    	let $selectedAlbumDir;
    	validate_store(selectedAlbumDir, 'selectedAlbumDir');
    	component_subscribe($$self, selectedAlbumDir, $$value => $$invalidate(0, $selectedAlbumDir = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SongListBackground', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SongListBackground> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		AlbumArt,
    		selectedAlbumDir,
    		$selectedAlbumDir
    	});

    	return [$selectedAlbumDir];
    }

    class SongListBackground extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$N, create_fragment$N, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SongListBackground",
    			options,
    			id: create_fragment$N.name
    		});
    	}
    }

    // Return selected songs data (from an array of IDs). If none are selected, then return all songs.
    function filterSongsToEdit(songList, selectedSongs) {
        return selectedSongs.length !== 0 ? songList.filter(song => selectedSongs.includes(song.ID)) : songList;
    }
    // Group tags by tag name. If a tag mismatches, it will be set to null. The purpose of this fn is to keep only the tag values that are common to all selected songs.
    function groupSongsByValues(songs) {
        let groupedValues = {};
        for (let song of songs) {
            for (let tag in song) {
                // If groupedValues doesn't have this tag yet, add it.
                if (groupedValues[tag] === undefined) {
                    groupedValues[tag] = song[tag];
                }
                else {
                    // If groupedValues already has this tag, check if the next value is the same.
                    if (groupedValues[tag] !== song[tag]) {
                        groupedValues[tag] = null;
                    }
                }
            }
        }
        return groupedValues;
    }
    function getObjectDifference(obj1, obj2) {
        let diff = {};
        for (let key in obj1) {
            if (obj1[key] !== obj2[key]) {
                diff[key] = obj2[key];
            }
        }
        return diff;
    }

    /* src/icons/UndoIcon.svelte generated by Svelte v3.49.0 */

    const file$H = "src/icons/UndoIcon.svelte";

    function create_fragment$M(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$H, 6, 2, 159);
    			attr_dev(path1, "d", "M5.828 7l2.536 2.536L6.95 10.95 2 6l4.95-4.95 1.414 1.414L5.828 5H13a8 8 0 1 1 0 16H4v-2h9a6 6 0 1 0 0-12H5.828z");
    			add_location(path1, file$H, 6, 40, 197);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "style", /*style*/ ctx[0]);
    			attr_dev(svg, "class", "svelte-am54ty");
    			add_location(svg, file$H, 5, 0, 89);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*style*/ 1) {
    				attr_dev(svg, "style", /*style*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$M.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$M($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('UndoIcon', slots, []);
    	let { style = '' } = $$props;
    	const writable_props = ['style'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<UndoIcon> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	$$self.$capture_state = () => ({ style });

    	$$self.$inject_state = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [style];
    }

    class UndoIcon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$M, create_fragment$M, safe_not_equal, { style: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "UndoIcon",
    			options,
    			id: create_fragment$M.name
    		});
    	}

    	get style() {
    		throw new Error("<UndoIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<UndoIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/icons/UpdateIcon.svelte generated by Svelte v3.49.0 */

    const file$G = "src/icons/UpdateIcon.svelte";

    function create_fragment$L(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$G, 6, 2, 159);
    			attr_dev(path1, "d", "M6.414 16L16.556 5.858l-1.414-1.414L5 14.586V16h1.414zm.829 2H3v-4.243L14.435 2.322a1 1 0 0 1 1.414 0l2.829 2.829a1 1 0 0 1 0 1.414L7.243 18zM3 20h18v2H3v-2z");
    			add_location(path1, file$G, 6, 40, 197);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "style", /*style*/ ctx[0]);
    			add_location(svg, file$G, 5, 0, 89);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*style*/ 1) {
    				attr_dev(svg, "style", /*style*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$L.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$L($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('UpdateIcon', slots, []);
    	let { style = '' } = $$props;
    	const writable_props = ['style'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<UpdateIcon> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	$$self.$capture_state = () => ({ style });

    	$$self.$inject_state = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [style];
    }

    class UpdateIcon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$L, create_fragment$L, safe_not_equal, { style: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "UpdateIcon",
    			options,
    			id: create_fragment$L.name
    		});
    	}

    	get style() {
    		throw new Error("<UpdateIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<UpdateIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function isEmptyObject(object) {
        return Object.keys(object).length === 0;
    }

    /**
     * Fuse.js v6.6.2 - Lightweight fuzzy-search (http://fusejs.io)
     *
     * Copyright (c) 2022 Kiro Risk (http://kiro.me)
     * All Rights Reserved. Apache Software License 2.0
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     */

    function isArray(value) {
      return !Array.isArray
        ? getTag(value) === '[object Array]'
        : Array.isArray(value)
    }

    // Adapted from: https://github.com/lodash/lodash/blob/master/.internal/baseToString.js
    const INFINITY = 1 / 0;
    function baseToString(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value
      }
      let result = value + '';
      return result == '0' && 1 / value == -INFINITY ? '-0' : result
    }

    function toString(value) {
      return value == null ? '' : baseToString(value)
    }

    function isString(value) {
      return typeof value === 'string'
    }

    function isNumber(value) {
      return typeof value === 'number'
    }

    // Adapted from: https://github.com/lodash/lodash/blob/master/isBoolean.js
    function isBoolean(value) {
      return (
        value === true ||
        value === false ||
        (isObjectLike(value) && getTag(value) == '[object Boolean]')
      )
    }

    function isObject(value) {
      return typeof value === 'object'
    }

    // Checks if `value` is object-like.
    function isObjectLike(value) {
      return isObject(value) && value !== null
    }

    function isDefined(value) {
      return value !== undefined && value !== null
    }

    function isBlank(value) {
      return !value.trim().length
    }

    // Gets the `toStringTag` of `value`.
    // Adapted from: https://github.com/lodash/lodash/blob/master/.internal/getTag.js
    function getTag(value) {
      return value == null
        ? value === undefined
          ? '[object Undefined]'
          : '[object Null]'
        : Object.prototype.toString.call(value)
    }

    const EXTENDED_SEARCH_UNAVAILABLE = 'Extended search is not available';

    const INCORRECT_INDEX_TYPE = "Incorrect 'index' type";

    const LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) =>
      `Invalid value for key ${key}`;

    const PATTERN_LENGTH_TOO_LARGE = (max) =>
      `Pattern length exceeds max of ${max}.`;

    const MISSING_KEY_PROPERTY = (name) => `Missing ${name} property in key`;

    const INVALID_KEY_WEIGHT_VALUE = (key) =>
      `Property 'weight' in key '${key}' must be a positive integer`;

    const hasOwn = Object.prototype.hasOwnProperty;

    class KeyStore {
      constructor(keys) {
        this._keys = [];
        this._keyMap = {};

        let totalWeight = 0;

        keys.forEach((key) => {
          let obj = createKey(key);

          totalWeight += obj.weight;

          this._keys.push(obj);
          this._keyMap[obj.id] = obj;

          totalWeight += obj.weight;
        });

        // Normalize weights so that their sum is equal to 1
        this._keys.forEach((key) => {
          key.weight /= totalWeight;
        });
      }
      get(keyId) {
        return this._keyMap[keyId]
      }
      keys() {
        return this._keys
      }
      toJSON() {
        return JSON.stringify(this._keys)
      }
    }

    function createKey(key) {
      let path = null;
      let id = null;
      let src = null;
      let weight = 1;
      let getFn = null;

      if (isString(key) || isArray(key)) {
        src = key;
        path = createKeyPath(key);
        id = createKeyId(key);
      } else {
        if (!hasOwn.call(key, 'name')) {
          throw new Error(MISSING_KEY_PROPERTY('name'))
        }

        const name = key.name;
        src = name;

        if (hasOwn.call(key, 'weight')) {
          weight = key.weight;

          if (weight <= 0) {
            throw new Error(INVALID_KEY_WEIGHT_VALUE(name))
          }
        }

        path = createKeyPath(name);
        id = createKeyId(name);
        getFn = key.getFn;
      }

      return { path, id, weight, src, getFn }
    }

    function createKeyPath(key) {
      return isArray(key) ? key : key.split('.')
    }

    function createKeyId(key) {
      return isArray(key) ? key.join('.') : key
    }

    function get(obj, path) {
      let list = [];
      let arr = false;

      const deepGet = (obj, path, index) => {
        if (!isDefined(obj)) {
          return
        }
        if (!path[index]) {
          // If there's no path left, we've arrived at the object we care about.
          list.push(obj);
        } else {
          let key = path[index];

          const value = obj[key];

          if (!isDefined(value)) {
            return
          }

          // If we're at the last value in the path, and if it's a string/number/bool,
          // add it to the list
          if (
            index === path.length - 1 &&
            (isString(value) || isNumber(value) || isBoolean(value))
          ) {
            list.push(toString(value));
          } else if (isArray(value)) {
            arr = true;
            // Search each item in the array.
            for (let i = 0, len = value.length; i < len; i += 1) {
              deepGet(value[i], path, index + 1);
            }
          } else if (path.length) {
            // An object. Recurse further.
            deepGet(value, path, index + 1);
          }
        }
      };

      // Backwards compatibility (since path used to be a string)
      deepGet(obj, isString(path) ? path.split('.') : path, 0);

      return arr ? list : list[0]
    }

    const MatchOptions = {
      // Whether the matches should be included in the result set. When `true`, each record in the result
      // set will include the indices of the matched characters.
      // These can consequently be used for highlighting purposes.
      includeMatches: false,
      // When `true`, the matching function will continue to the end of a search pattern even if
      // a perfect match has already been located in the string.
      findAllMatches: false,
      // Minimum number of characters that must be matched before a result is considered a match
      minMatchCharLength: 1
    };

    const BasicOptions = {
      // When `true`, the algorithm continues searching to the end of the input even if a perfect
      // match is found before the end of the same input.
      isCaseSensitive: false,
      // When true, the matching function will continue to the end of a search pattern even if
      includeScore: false,
      // List of properties that will be searched. This also supports nested properties.
      keys: [],
      // Whether to sort the result list, by score
      shouldSort: true,
      // Default sort function: sort by ascending score, ascending index
      sortFn: (a, b) =>
        a.score === b.score ? (a.idx < b.idx ? -1 : 1) : a.score < b.score ? -1 : 1
    };

    const FuzzyOptions = {
      // Approximately where in the text is the pattern expected to be found?
      location: 0,
      // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
      // (of both letters and location), a threshold of '1.0' would match anything.
      threshold: 0.6,
      // Determines how close the match must be to the fuzzy location (specified above).
      // An exact letter match which is 'distance' characters away from the fuzzy location
      // would score as a complete mismatch. A distance of '0' requires the match be at
      // the exact location specified, a threshold of '1000' would require a perfect match
      // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
      distance: 100
    };

    const AdvancedOptions = {
      // When `true`, it enables the use of unix-like search commands
      useExtendedSearch: false,
      // The get function to use when fetching an object's properties.
      // The default will search nested paths *ie foo.bar.baz*
      getFn: get,
      // When `true`, search will ignore `location` and `distance`, so it won't matter
      // where in the string the pattern appears.
      // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score
      ignoreLocation: false,
      // When `true`, the calculation for the relevance score (used for sorting) will
      // ignore the field-length norm.
      // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm
      ignoreFieldNorm: false,
      // The weight to determine how much field length norm effects scoring.
      fieldNormWeight: 1
    };

    var Config = {
      ...BasicOptions,
      ...MatchOptions,
      ...FuzzyOptions,
      ...AdvancedOptions
    };

    const SPACE = /[^ ]+/g;

    // Field-length norm: the shorter the field, the higher the weight.
    // Set to 3 decimals to reduce index size.
    function norm(weight = 1, mantissa = 3) {
      const cache = new Map();
      const m = Math.pow(10, mantissa);

      return {
        get(value) {
          const numTokens = value.match(SPACE).length;

          if (cache.has(numTokens)) {
            return cache.get(numTokens)
          }

          // Default function is 1/sqrt(x), weight makes that variable
          const norm = 1 / Math.pow(numTokens, 0.5 * weight);

          // In place of `toFixed(mantissa)`, for faster computation
          const n = parseFloat(Math.round(norm * m) / m);

          cache.set(numTokens, n);

          return n
        },
        clear() {
          cache.clear();
        }
      }
    }

    class FuseIndex {
      constructor({
        getFn = Config.getFn,
        fieldNormWeight = Config.fieldNormWeight
      } = {}) {
        this.norm = norm(fieldNormWeight, 3);
        this.getFn = getFn;
        this.isCreated = false;

        this.setIndexRecords();
      }
      setSources(docs = []) {
        this.docs = docs;
      }
      setIndexRecords(records = []) {
        this.records = records;
      }
      setKeys(keys = []) {
        this.keys = keys;
        this._keysMap = {};
        keys.forEach((key, idx) => {
          this._keysMap[key.id] = idx;
        });
      }
      create() {
        if (this.isCreated || !this.docs.length) {
          return
        }

        this.isCreated = true;

        // List is Array<String>
        if (isString(this.docs[0])) {
          this.docs.forEach((doc, docIndex) => {
            this._addString(doc, docIndex);
          });
        } else {
          // List is Array<Object>
          this.docs.forEach((doc, docIndex) => {
            this._addObject(doc, docIndex);
          });
        }

        this.norm.clear();
      }
      // Adds a doc to the end of the index
      add(doc) {
        const idx = this.size();

        if (isString(doc)) {
          this._addString(doc, idx);
        } else {
          this._addObject(doc, idx);
        }
      }
      // Removes the doc at the specified index of the index
      removeAt(idx) {
        this.records.splice(idx, 1);

        // Change ref index of every subsquent doc
        for (let i = idx, len = this.size(); i < len; i += 1) {
          this.records[i].i -= 1;
        }
      }
      getValueForItemAtKeyId(item, keyId) {
        return item[this._keysMap[keyId]]
      }
      size() {
        return this.records.length
      }
      _addString(doc, docIndex) {
        if (!isDefined(doc) || isBlank(doc)) {
          return
        }

        let record = {
          v: doc,
          i: docIndex,
          n: this.norm.get(doc)
        };

        this.records.push(record);
      }
      _addObject(doc, docIndex) {
        let record = { i: docIndex, $: {} };

        // Iterate over every key (i.e, path), and fetch the value at that key
        this.keys.forEach((key, keyIndex) => {
          let value = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);

          if (!isDefined(value)) {
            return
          }

          if (isArray(value)) {
            let subRecords = [];
            const stack = [{ nestedArrIndex: -1, value }];

            while (stack.length) {
              const { nestedArrIndex, value } = stack.pop();

              if (!isDefined(value)) {
                continue
              }

              if (isString(value) && !isBlank(value)) {
                let subRecord = {
                  v: value,
                  i: nestedArrIndex,
                  n: this.norm.get(value)
                };

                subRecords.push(subRecord);
              } else if (isArray(value)) {
                value.forEach((item, k) => {
                  stack.push({
                    nestedArrIndex: k,
                    value: item
                  });
                });
              } else ;
            }
            record.$[keyIndex] = subRecords;
          } else if (isString(value) && !isBlank(value)) {
            let subRecord = {
              v: value,
              n: this.norm.get(value)
            };

            record.$[keyIndex] = subRecord;
          }
        });

        this.records.push(record);
      }
      toJSON() {
        return {
          keys: this.keys,
          records: this.records
        }
      }
    }

    function createIndex(
      keys,
      docs,
      { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}
    ) {
      const myIndex = new FuseIndex({ getFn, fieldNormWeight });
      myIndex.setKeys(keys.map(createKey));
      myIndex.setSources(docs);
      myIndex.create();
      return myIndex
    }

    function parseIndex(
      data,
      { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}
    ) {
      const { keys, records } = data;
      const myIndex = new FuseIndex({ getFn, fieldNormWeight });
      myIndex.setKeys(keys);
      myIndex.setIndexRecords(records);
      return myIndex
    }

    function computeScore$1(
      pattern,
      {
        errors = 0,
        currentLocation = 0,
        expectedLocation = 0,
        distance = Config.distance,
        ignoreLocation = Config.ignoreLocation
      } = {}
    ) {
      const accuracy = errors / pattern.length;

      if (ignoreLocation) {
        return accuracy
      }

      const proximity = Math.abs(expectedLocation - currentLocation);

      if (!distance) {
        // Dodge divide by zero error.
        return proximity ? 1.0 : accuracy
      }

      return accuracy + proximity / distance
    }

    function convertMaskToIndices(
      matchmask = [],
      minMatchCharLength = Config.minMatchCharLength
    ) {
      let indices = [];
      let start = -1;
      let end = -1;
      let i = 0;

      for (let len = matchmask.length; i < len; i += 1) {
        let match = matchmask[i];
        if (match && start === -1) {
          start = i;
        } else if (!match && start !== -1) {
          end = i - 1;
          if (end - start + 1 >= minMatchCharLength) {
            indices.push([start, end]);
          }
          start = -1;
        }
      }

      // (i-1 - start) + 1 => i - start
      if (matchmask[i - 1] && i - start >= minMatchCharLength) {
        indices.push([start, i - 1]);
      }

      return indices
    }

    // Machine word size
    const MAX_BITS = 32;

    function search(
      text,
      pattern,
      patternAlphabet,
      {
        location = Config.location,
        distance = Config.distance,
        threshold = Config.threshold,
        findAllMatches = Config.findAllMatches,
        minMatchCharLength = Config.minMatchCharLength,
        includeMatches = Config.includeMatches,
        ignoreLocation = Config.ignoreLocation
      } = {}
    ) {
      if (pattern.length > MAX_BITS) {
        throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS))
      }

      const patternLen = pattern.length;
      // Set starting location at beginning text and initialize the alphabet.
      const textLen = text.length;
      // Handle the case when location > text.length
      const expectedLocation = Math.max(0, Math.min(location, textLen));
      // Highest score beyond which we give up.
      let currentThreshold = threshold;
      // Is there a nearby exact match? (speedup)
      let bestLocation = expectedLocation;

      // Performance: only computer matches when the minMatchCharLength > 1
      // OR if `includeMatches` is true.
      const computeMatches = minMatchCharLength > 1 || includeMatches;
      // A mask of the matches, used for building the indices
      const matchMask = computeMatches ? Array(textLen) : [];

      let index;

      // Get all exact matches, here for speed up
      while ((index = text.indexOf(pattern, bestLocation)) > -1) {
        let score = computeScore$1(pattern, {
          currentLocation: index,
          expectedLocation,
          distance,
          ignoreLocation
        });

        currentThreshold = Math.min(score, currentThreshold);
        bestLocation = index + patternLen;

        if (computeMatches) {
          let i = 0;
          while (i < patternLen) {
            matchMask[index + i] = 1;
            i += 1;
          }
        }
      }

      // Reset the best location
      bestLocation = -1;

      let lastBitArr = [];
      let finalScore = 1;
      let binMax = patternLen + textLen;

      const mask = 1 << (patternLen - 1);

      for (let i = 0; i < patternLen; i += 1) {
        // Scan for the best match; each iteration allows for one more error.
        // Run a binary search to determine how far from the match location we can stray
        // at this error level.
        let binMin = 0;
        let binMid = binMax;

        while (binMin < binMid) {
          const score = computeScore$1(pattern, {
            errors: i,
            currentLocation: expectedLocation + binMid,
            expectedLocation,
            distance,
            ignoreLocation
          });

          if (score <= currentThreshold) {
            binMin = binMid;
          } else {
            binMax = binMid;
          }

          binMid = Math.floor((binMax - binMin) / 2 + binMin);
        }

        // Use the result from this iteration as the maximum for the next.
        binMax = binMid;

        let start = Math.max(1, expectedLocation - binMid + 1);
        let finish = findAllMatches
          ? textLen
          : Math.min(expectedLocation + binMid, textLen) + patternLen;

        // Initialize the bit array
        let bitArr = Array(finish + 2);

        bitArr[finish + 1] = (1 << i) - 1;

        for (let j = finish; j >= start; j -= 1) {
          let currentLocation = j - 1;
          let charMatch = patternAlphabet[text.charAt(currentLocation)];

          if (computeMatches) {
            // Speed up: quick bool to int conversion (i.e, `charMatch ? 1 : 0`)
            matchMask[currentLocation] = +!!charMatch;
          }

          // First pass: exact match
          bitArr[j] = ((bitArr[j + 1] << 1) | 1) & charMatch;

          // Subsequent passes: fuzzy match
          if (i) {
            bitArr[j] |=
              ((lastBitArr[j + 1] | lastBitArr[j]) << 1) | 1 | lastBitArr[j + 1];
          }

          if (bitArr[j] & mask) {
            finalScore = computeScore$1(pattern, {
              errors: i,
              currentLocation,
              expectedLocation,
              distance,
              ignoreLocation
            });

            // This match will almost certainly be better than any existing match.
            // But check anyway.
            if (finalScore <= currentThreshold) {
              // Indeed it is
              currentThreshold = finalScore;
              bestLocation = currentLocation;

              // Already passed `loc`, downhill from here on in.
              if (bestLocation <= expectedLocation) {
                break
              }

              // When passing `bestLocation`, don't exceed our current distance from `expectedLocation`.
              start = Math.max(1, 2 * expectedLocation - bestLocation);
            }
          }
        }

        // No hope for a (better) match at greater error levels.
        const score = computeScore$1(pattern, {
          errors: i + 1,
          currentLocation: expectedLocation,
          expectedLocation,
          distance,
          ignoreLocation
        });

        if (score > currentThreshold) {
          break
        }

        lastBitArr = bitArr;
      }

      const result = {
        isMatch: bestLocation >= 0,
        // Count exact matches (those with a score of 0) to be "almost" exact
        score: Math.max(0.001, finalScore)
      };

      if (computeMatches) {
        const indices = convertMaskToIndices(matchMask, minMatchCharLength);
        if (!indices.length) {
          result.isMatch = false;
        } else if (includeMatches) {
          result.indices = indices;
        }
      }

      return result
    }

    function createPatternAlphabet(pattern) {
      let mask = {};

      for (let i = 0, len = pattern.length; i < len; i += 1) {
        const char = pattern.charAt(i);
        mask[char] = (mask[char] || 0) | (1 << (len - i - 1));
      }

      return mask
    }

    class BitapSearch {
      constructor(
        pattern,
        {
          location = Config.location,
          threshold = Config.threshold,
          distance = Config.distance,
          includeMatches = Config.includeMatches,
          findAllMatches = Config.findAllMatches,
          minMatchCharLength = Config.minMatchCharLength,
          isCaseSensitive = Config.isCaseSensitive,
          ignoreLocation = Config.ignoreLocation
        } = {}
      ) {
        this.options = {
          location,
          threshold,
          distance,
          includeMatches,
          findAllMatches,
          minMatchCharLength,
          isCaseSensitive,
          ignoreLocation
        };

        this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();

        this.chunks = [];

        if (!this.pattern.length) {
          return
        }

        const addChunk = (pattern, startIndex) => {
          this.chunks.push({
            pattern,
            alphabet: createPatternAlphabet(pattern),
            startIndex
          });
        };

        const len = this.pattern.length;

        if (len > MAX_BITS) {
          let i = 0;
          const remainder = len % MAX_BITS;
          const end = len - remainder;

          while (i < end) {
            addChunk(this.pattern.substr(i, MAX_BITS), i);
            i += MAX_BITS;
          }

          if (remainder) {
            const startIndex = len - MAX_BITS;
            addChunk(this.pattern.substr(startIndex), startIndex);
          }
        } else {
          addChunk(this.pattern, 0);
        }
      }

      searchIn(text) {
        const { isCaseSensitive, includeMatches } = this.options;

        if (!isCaseSensitive) {
          text = text.toLowerCase();
        }

        // Exact match
        if (this.pattern === text) {
          let result = {
            isMatch: true,
            score: 0
          };

          if (includeMatches) {
            result.indices = [[0, text.length - 1]];
          }

          return result
        }

        // Otherwise, use Bitap algorithm
        const {
          location,
          distance,
          threshold,
          findAllMatches,
          minMatchCharLength,
          ignoreLocation
        } = this.options;

        let allIndices = [];
        let totalScore = 0;
        let hasMatches = false;

        this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
          const { isMatch, score, indices } = search(text, pattern, alphabet, {
            location: location + startIndex,
            distance,
            threshold,
            findAllMatches,
            minMatchCharLength,
            includeMatches,
            ignoreLocation
          });

          if (isMatch) {
            hasMatches = true;
          }

          totalScore += score;

          if (isMatch && indices) {
            allIndices = [...allIndices, ...indices];
          }
        });

        let result = {
          isMatch: hasMatches,
          score: hasMatches ? totalScore / this.chunks.length : 1
        };

        if (hasMatches && includeMatches) {
          result.indices = allIndices;
        }

        return result
      }
    }

    class BaseMatch {
      constructor(pattern) {
        this.pattern = pattern;
      }
      static isMultiMatch(pattern) {
        return getMatch(pattern, this.multiRegex)
      }
      static isSingleMatch(pattern) {
        return getMatch(pattern, this.singleRegex)
      }
      search(/*text*/) {}
    }

    function getMatch(pattern, exp) {
      const matches = pattern.match(exp);
      return matches ? matches[1] : null
    }

    // Token: 'file

    class ExactMatch extends BaseMatch {
      constructor(pattern) {
        super(pattern);
      }
      static get type() {
        return 'exact'
      }
      static get multiRegex() {
        return /^="(.*)"$/
      }
      static get singleRegex() {
        return /^=(.*)$/
      }
      search(text) {
        const isMatch = text === this.pattern;

        return {
          isMatch,
          score: isMatch ? 0 : 1,
          indices: [0, this.pattern.length - 1]
        }
      }
    }

    // Token: !fire

    class InverseExactMatch extends BaseMatch {
      constructor(pattern) {
        super(pattern);
      }
      static get type() {
        return 'inverse-exact'
      }
      static get multiRegex() {
        return /^!"(.*)"$/
      }
      static get singleRegex() {
        return /^!(.*)$/
      }
      search(text) {
        const index = text.indexOf(this.pattern);
        const isMatch = index === -1;

        return {
          isMatch,
          score: isMatch ? 0 : 1,
          indices: [0, text.length - 1]
        }
      }
    }

    // Token: ^file

    class PrefixExactMatch extends BaseMatch {
      constructor(pattern) {
        super(pattern);
      }
      static get type() {
        return 'prefix-exact'
      }
      static get multiRegex() {
        return /^\^"(.*)"$/
      }
      static get singleRegex() {
        return /^\^(.*)$/
      }
      search(text) {
        const isMatch = text.startsWith(this.pattern);

        return {
          isMatch,
          score: isMatch ? 0 : 1,
          indices: [0, this.pattern.length - 1]
        }
      }
    }

    // Token: !^fire

    class InversePrefixExactMatch extends BaseMatch {
      constructor(pattern) {
        super(pattern);
      }
      static get type() {
        return 'inverse-prefix-exact'
      }
      static get multiRegex() {
        return /^!\^"(.*)"$/
      }
      static get singleRegex() {
        return /^!\^(.*)$/
      }
      search(text) {
        const isMatch = !text.startsWith(this.pattern);

        return {
          isMatch,
          score: isMatch ? 0 : 1,
          indices: [0, text.length - 1]
        }
      }
    }

    // Token: .file$

    class SuffixExactMatch extends BaseMatch {
      constructor(pattern) {
        super(pattern);
      }
      static get type() {
        return 'suffix-exact'
      }
      static get multiRegex() {
        return /^"(.*)"\$$/
      }
      static get singleRegex() {
        return /^(.*)\$$/
      }
      search(text) {
        const isMatch = text.endsWith(this.pattern);

        return {
          isMatch,
          score: isMatch ? 0 : 1,
          indices: [text.length - this.pattern.length, text.length - 1]
        }
      }
    }

    // Token: !.file$

    class InverseSuffixExactMatch extends BaseMatch {
      constructor(pattern) {
        super(pattern);
      }
      static get type() {
        return 'inverse-suffix-exact'
      }
      static get multiRegex() {
        return /^!"(.*)"\$$/
      }
      static get singleRegex() {
        return /^!(.*)\$$/
      }
      search(text) {
        const isMatch = !text.endsWith(this.pattern);
        return {
          isMatch,
          score: isMatch ? 0 : 1,
          indices: [0, text.length - 1]
        }
      }
    }

    class FuzzyMatch extends BaseMatch {
      constructor(
        pattern,
        {
          location = Config.location,
          threshold = Config.threshold,
          distance = Config.distance,
          includeMatches = Config.includeMatches,
          findAllMatches = Config.findAllMatches,
          minMatchCharLength = Config.minMatchCharLength,
          isCaseSensitive = Config.isCaseSensitive,
          ignoreLocation = Config.ignoreLocation
        } = {}
      ) {
        super(pattern);
        this._bitapSearch = new BitapSearch(pattern, {
          location,
          threshold,
          distance,
          includeMatches,
          findAllMatches,
          minMatchCharLength,
          isCaseSensitive,
          ignoreLocation
        });
      }
      static get type() {
        return 'fuzzy'
      }
      static get multiRegex() {
        return /^"(.*)"$/
      }
      static get singleRegex() {
        return /^(.*)$/
      }
      search(text) {
        return this._bitapSearch.searchIn(text)
      }
    }

    // Token: 'file

    class IncludeMatch extends BaseMatch {
      constructor(pattern) {
        super(pattern);
      }
      static get type() {
        return 'include'
      }
      static get multiRegex() {
        return /^'"(.*)"$/
      }
      static get singleRegex() {
        return /^'(.*)$/
      }
      search(text) {
        let location = 0;
        let index;

        const indices = [];
        const patternLen = this.pattern.length;

        // Get all exact matches
        while ((index = text.indexOf(this.pattern, location)) > -1) {
          location = index + patternLen;
          indices.push([index, location - 1]);
        }

        const isMatch = !!indices.length;

        return {
          isMatch,
          score: isMatch ? 0 : 1,
          indices
        }
      }
    }

    // ❗Order is important. DO NOT CHANGE.
    const searchers = [
      ExactMatch,
      IncludeMatch,
      PrefixExactMatch,
      InversePrefixExactMatch,
      InverseSuffixExactMatch,
      SuffixExactMatch,
      InverseExactMatch,
      FuzzyMatch
    ];

    const searchersLen = searchers.length;

    // Regex to split by spaces, but keep anything in quotes together
    const SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
    const OR_TOKEN = '|';

    // Return a 2D array representation of the query, for simpler parsing.
    // Example:
    // "^core go$ | rb$ | py$ xy$" => [["^core", "go$"], ["rb$"], ["py$", "xy$"]]
    function parseQuery(pattern, options = {}) {
      return pattern.split(OR_TOKEN).map((item) => {
        let query = item
          .trim()
          .split(SPACE_RE)
          .filter((item) => item && !!item.trim());

        let results = [];
        for (let i = 0, len = query.length; i < len; i += 1) {
          const queryItem = query[i];

          // 1. Handle multiple query match (i.e, once that are quoted, like `"hello world"`)
          let found = false;
          let idx = -1;
          while (!found && ++idx < searchersLen) {
            const searcher = searchers[idx];
            let token = searcher.isMultiMatch(queryItem);
            if (token) {
              results.push(new searcher(token, options));
              found = true;
            }
          }

          if (found) {
            continue
          }

          // 2. Handle single query matches (i.e, once that are *not* quoted)
          idx = -1;
          while (++idx < searchersLen) {
            const searcher = searchers[idx];
            let token = searcher.isSingleMatch(queryItem);
            if (token) {
              results.push(new searcher(token, options));
              break
            }
          }
        }

        return results
      })
    }

    // These extended matchers can return an array of matches, as opposed
    // to a singl match
    const MultiMatchSet = new Set([FuzzyMatch.type, IncludeMatch.type]);

    /**
     * Command-like searching
     * ======================
     *
     * Given multiple search terms delimited by spaces.e.g. `^jscript .python$ ruby !java`,
     * search in a given text.
     *
     * Search syntax:
     *
     * | Token       | Match type                 | Description                            |
     * | ----------- | -------------------------- | -------------------------------------- |
     * | `jscript`   | fuzzy-match                | Items that fuzzy match `jscript`       |
     * | `=scheme`   | exact-match                | Items that are `scheme`                |
     * | `'python`   | include-match              | Items that include `python`            |
     * | `!ruby`     | inverse-exact-match        | Items that do not include `ruby`       |
     * | `^java`     | prefix-exact-match         | Items that start with `java`           |
     * | `!^earlang` | inverse-prefix-exact-match | Items that do not start with `earlang` |
     * | `.js$`      | suffix-exact-match         | Items that end with `.js`              |
     * | `!.go$`     | inverse-suffix-exact-match | Items that do not end with `.go`       |
     *
     * A single pipe character acts as an OR operator. For example, the following
     * query matches entries that start with `core` and end with either`go`, `rb`,
     * or`py`.
     *
     * ```
     * ^core go$ | rb$ | py$
     * ```
     */
    class ExtendedSearch {
      constructor(
        pattern,
        {
          isCaseSensitive = Config.isCaseSensitive,
          includeMatches = Config.includeMatches,
          minMatchCharLength = Config.minMatchCharLength,
          ignoreLocation = Config.ignoreLocation,
          findAllMatches = Config.findAllMatches,
          location = Config.location,
          threshold = Config.threshold,
          distance = Config.distance
        } = {}
      ) {
        this.query = null;
        this.options = {
          isCaseSensitive,
          includeMatches,
          minMatchCharLength,
          findAllMatches,
          ignoreLocation,
          location,
          threshold,
          distance
        };

        this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
        this.query = parseQuery(this.pattern, this.options);
      }

      static condition(_, options) {
        return options.useExtendedSearch
      }

      searchIn(text) {
        const query = this.query;

        if (!query) {
          return {
            isMatch: false,
            score: 1
          }
        }

        const { includeMatches, isCaseSensitive } = this.options;

        text = isCaseSensitive ? text : text.toLowerCase();

        let numMatches = 0;
        let allIndices = [];
        let totalScore = 0;

        // ORs
        for (let i = 0, qLen = query.length; i < qLen; i += 1) {
          const searchers = query[i];

          // Reset indices
          allIndices.length = 0;
          numMatches = 0;

          // ANDs
          for (let j = 0, pLen = searchers.length; j < pLen; j += 1) {
            const searcher = searchers[j];
            const { isMatch, indices, score } = searcher.search(text);

            if (isMatch) {
              numMatches += 1;
              totalScore += score;
              if (includeMatches) {
                const type = searcher.constructor.type;
                if (MultiMatchSet.has(type)) {
                  allIndices = [...allIndices, ...indices];
                } else {
                  allIndices.push(indices);
                }
              }
            } else {
              totalScore = 0;
              numMatches = 0;
              allIndices.length = 0;
              break
            }
          }

          // OR condition, so if TRUE, return
          if (numMatches) {
            let result = {
              isMatch: true,
              score: totalScore / numMatches
            };

            if (includeMatches) {
              result.indices = allIndices;
            }

            return result
          }
        }

        // Nothing was matched
        return {
          isMatch: false,
          score: 1
        }
      }
    }

    const registeredSearchers = [];

    function register(...args) {
      registeredSearchers.push(...args);
    }

    function createSearcher(pattern, options) {
      for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {
        let searcherClass = registeredSearchers[i];
        if (searcherClass.condition(pattern, options)) {
          return new searcherClass(pattern, options)
        }
      }

      return new BitapSearch(pattern, options)
    }

    const LogicalOperator = {
      AND: '$and',
      OR: '$or'
    };

    const KeyType = {
      PATH: '$path',
      PATTERN: '$val'
    };

    const isExpression = (query) =>
      !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);

    const isPath = (query) => !!query[KeyType.PATH];

    const isLeaf = (query) =>
      !isArray(query) && isObject(query) && !isExpression(query);

    const convertToExplicit = (query) => ({
      [LogicalOperator.AND]: Object.keys(query).map((key) => ({
        [key]: query[key]
      }))
    });

    // When `auto` is `true`, the parse function will infer and initialize and add
    // the appropriate `Searcher` instance
    function parse(query, options, { auto = true } = {}) {
      const next = (query) => {
        let keys = Object.keys(query);

        const isQueryPath = isPath(query);

        if (!isQueryPath && keys.length > 1 && !isExpression(query)) {
          return next(convertToExplicit(query))
        }

        if (isLeaf(query)) {
          const key = isQueryPath ? query[KeyType.PATH] : keys[0];

          const pattern = isQueryPath ? query[KeyType.PATTERN] : query[key];

          if (!isString(pattern)) {
            throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key))
          }

          const obj = {
            keyId: createKeyId(key),
            pattern
          };

          if (auto) {
            obj.searcher = createSearcher(pattern, options);
          }

          return obj
        }

        let node = {
          children: [],
          operator: keys[0]
        };

        keys.forEach((key) => {
          const value = query[key];

          if (isArray(value)) {
            value.forEach((item) => {
              node.children.push(next(item));
            });
          }
        });

        return node
      };

      if (!isExpression(query)) {
        query = convertToExplicit(query);
      }

      return next(query)
    }

    // Practical scoring function
    function computeScore(
      results,
      { ignoreFieldNorm = Config.ignoreFieldNorm }
    ) {
      results.forEach((result) => {
        let totalScore = 1;

        result.matches.forEach(({ key, norm, score }) => {
          const weight = key ? key.weight : null;

          totalScore *= Math.pow(
            score === 0 && weight ? Number.EPSILON : score,
            (weight || 1) * (ignoreFieldNorm ? 1 : norm)
          );
        });

        result.score = totalScore;
      });
    }

    function transformMatches(result, data) {
      const matches = result.matches;
      data.matches = [];

      if (!isDefined(matches)) {
        return
      }

      matches.forEach((match) => {
        if (!isDefined(match.indices) || !match.indices.length) {
          return
        }

        const { indices, value } = match;

        let obj = {
          indices,
          value
        };

        if (match.key) {
          obj.key = match.key.src;
        }

        if (match.idx > -1) {
          obj.refIndex = match.idx;
        }

        data.matches.push(obj);
      });
    }

    function transformScore(result, data) {
      data.score = result.score;
    }

    function format(
      results,
      docs,
      {
        includeMatches = Config.includeMatches,
        includeScore = Config.includeScore
      } = {}
    ) {
      const transformers = [];

      if (includeMatches) transformers.push(transformMatches);
      if (includeScore) transformers.push(transformScore);

      return results.map((result) => {
        const { idx } = result;

        const data = {
          item: docs[idx],
          refIndex: idx
        };

        if (transformers.length) {
          transformers.forEach((transformer) => {
            transformer(result, data);
          });
        }

        return data
      })
    }

    class Fuse {
      constructor(docs, options = {}, index) {
        this.options = { ...Config, ...options };

        if (
          this.options.useExtendedSearch &&
          !true
        ) {
          throw new Error(EXTENDED_SEARCH_UNAVAILABLE)
        }

        this._keyStore = new KeyStore(this.options.keys);

        this.setCollection(docs, index);
      }

      setCollection(docs, index) {
        this._docs = docs;

        if (index && !(index instanceof FuseIndex)) {
          throw new Error(INCORRECT_INDEX_TYPE)
        }

        this._myIndex =
          index ||
          createIndex(this.options.keys, this._docs, {
            getFn: this.options.getFn,
            fieldNormWeight: this.options.fieldNormWeight
          });
      }

      add(doc) {
        if (!isDefined(doc)) {
          return
        }

        this._docs.push(doc);
        this._myIndex.add(doc);
      }

      remove(predicate = (/* doc, idx */) => false) {
        const results = [];

        for (let i = 0, len = this._docs.length; i < len; i += 1) {
          const doc = this._docs[i];
          if (predicate(doc, i)) {
            this.removeAt(i);
            i -= 1;
            len -= 1;

            results.push(doc);
          }
        }

        return results
      }

      removeAt(idx) {
        this._docs.splice(idx, 1);
        this._myIndex.removeAt(idx);
      }

      getIndex() {
        return this._myIndex
      }

      search(query, { limit = -1 } = {}) {
        const {
          includeMatches,
          includeScore,
          shouldSort,
          sortFn,
          ignoreFieldNorm
        } = this.options;

        let results = isString(query)
          ? isString(this._docs[0])
            ? this._searchStringList(query)
            : this._searchObjectList(query)
          : this._searchLogical(query);

        computeScore(results, { ignoreFieldNorm });

        if (shouldSort) {
          results.sort(sortFn);
        }

        if (isNumber(limit) && limit > -1) {
          results = results.slice(0, limit);
        }

        return format(results, this._docs, {
          includeMatches,
          includeScore
        })
      }

      _searchStringList(query) {
        const searcher = createSearcher(query, this.options);
        const { records } = this._myIndex;
        const results = [];

        // Iterate over every string in the index
        records.forEach(({ v: text, i: idx, n: norm }) => {
          if (!isDefined(text)) {
            return
          }

          const { isMatch, score, indices } = searcher.searchIn(text);

          if (isMatch) {
            results.push({
              item: text,
              idx,
              matches: [{ score, value: text, norm, indices }]
            });
          }
        });

        return results
      }

      _searchLogical(query) {

        const expression = parse(query, this.options);

        const evaluate = (node, item, idx) => {
          if (!node.children) {
            const { keyId, searcher } = node;

            const matches = this._findMatches({
              key: this._keyStore.get(keyId),
              value: this._myIndex.getValueForItemAtKeyId(item, keyId),
              searcher
            });

            if (matches && matches.length) {
              return [
                {
                  idx,
                  item,
                  matches
                }
              ]
            }

            return []
          }

          const res = [];
          for (let i = 0, len = node.children.length; i < len; i += 1) {
            const child = node.children[i];
            const result = evaluate(child, item, idx);
            if (result.length) {
              res.push(...result);
            } else if (node.operator === LogicalOperator.AND) {
              return []
            }
          }
          return res
        };

        const records = this._myIndex.records;
        const resultMap = {};
        const results = [];

        records.forEach(({ $: item, i: idx }) => {
          if (isDefined(item)) {
            let expResults = evaluate(expression, item, idx);

            if (expResults.length) {
              // Dedupe when adding
              if (!resultMap[idx]) {
                resultMap[idx] = { idx, item, matches: [] };
                results.push(resultMap[idx]);
              }
              expResults.forEach(({ matches }) => {
                resultMap[idx].matches.push(...matches);
              });
            }
          }
        });

        return results
      }

      _searchObjectList(query) {
        const searcher = createSearcher(query, this.options);
        const { keys, records } = this._myIndex;
        const results = [];

        // List is Array<Object>
        records.forEach(({ $: item, i: idx }) => {
          if (!isDefined(item)) {
            return
          }

          let matches = [];

          // Iterate over every key (i.e, path), and fetch the value at that key
          keys.forEach((key, keyIndex) => {
            matches.push(
              ...this._findMatches({
                key,
                value: item[keyIndex],
                searcher
              })
            );
          });

          if (matches.length) {
            results.push({
              idx,
              item,
              matches
            });
          }
        });

        return results
      }
      _findMatches({ key, value, searcher }) {
        if (!isDefined(value)) {
          return []
        }

        let matches = [];

        if (isArray(value)) {
          value.forEach(({ v: text, i: idx, n: norm }) => {
            if (!isDefined(text)) {
              return
            }

            const { isMatch, score, indices } = searcher.searchIn(text);

            if (isMatch) {
              matches.push({
                score,
                key,
                value: text,
                idx,
                norm,
                indices
              });
            }
          });
        } else {
          const { v: text, n: norm } = value;

          const { isMatch, score, indices } = searcher.searchIn(text);

          if (isMatch) {
            matches.push({ score, key, value: text, norm, indices });
          }
        }

        return matches
      }
    }

    Fuse.version = '6.6.2';
    Fuse.createIndex = createIndex;
    Fuse.parseIndex = parseIndex;
    Fuse.config = Config;

    {
      Fuse.parseQuery = parse;
    }

    {
      register(ExtendedSearch);
    }

    const fuseOptions = {
        shouldSort: true,
        includeScore: true
    };
    function tagEditSuggestionFn (elementToHook, tagToSearch, userInput) {
        return new Promise((resolve, reject) => {
            if (userInput === '') {
                userInput = undefined;
            }
            let songList = [];
            songListStore.subscribe(_ => (songList = _))();
            let suggestions = filterDistinctObjectArray(songList, tagToSearch);
            let results = [];
            if (userInput !== undefined) {
                const fuse = new Fuse(suggestions, fuseOptions);
                results = fuse.search(userInput).slice(0, 5);
            }
            else {
                results = suggestions.sort((a, b) => String(a).localeCompare(String(b), undefined, { numeric: true })).slice(0, 5);
            }
            let suggestionElement = elementToHook.querySelector('tag-suggestions');
            if (suggestionElement) {
                suggestionElement.innerHTML = '';
            }
            else {
                suggestionElement = document.createElement('tag-suggestions');
            }
            if (results.length > 0) {
                results.forEach((result, index) => {
                    if (!((result === null || result === void 0 ? void 0 : result.item) || result))
                        return;
                    let suggestionContainerElement = document.createElement('tag-suggestion');
                    suggestionContainerElement.setAttribute('data-content', `${result.item || result}`);
                    suggestionContainerElement.setAttribute('data-index', `${index}`);
                    suggestionContainerElement.setAttribute('data-tag', `${tagToSearch}`);
                    suggestionContainerElement.addEventListener('click', evt => {
                        resolve(result.item || result);
                    });
                    suggestionContainerElement.addEventListener('click', evt => {
                        resolve(result.item || result);
                    });
                    suggestionElement.appendChild(suggestionContainerElement);
                });
                elementToHook.appendChild(suggestionElement);
            }
        });
    }
    function filterDistinctObjectArray(array, key) {
        return array.map(item => item[key]).filter((item, index, self) => self.indexOf(item) === index);
    }

    /* src/layouts/library/TagEdit.svelte generated by Svelte v3.49.0 */

    const { Object: Object_1$1, console: console_1$1 } = globals;
    const file$F = "src/layouts/library/TagEdit.svelte";

    function create_fragment$K(ctx) {
    	let tag_edit_svlt;
    	let songs_to_edit;
    	let t0;
    	let t1_value = (/*songsToEdit*/ ctx[1].length > 1 ? 's' : '') + "";
    	let t1;
    	let t2;
    	let t3_value = (/*songsToEdit*/ ctx[1].length > 0 ? 'ing' : '') + "";
    	let t3;
    	let t4;
    	let t5_value = /*songsToEdit*/ ctx[1].length + "";
    	let t5;
    	let t6;
    	let tag_container0;
    	let tag_name0;
    	let t7;
    	let undoicon0;
    	let t8;
    	let textarea0;
    	let t9;
    	let tag_container1;
    	let tag_name1;
    	let t10;
    	let undoicon1;
    	let t11;
    	let textarea1;
    	let t12;
    	let tag_container2;
    	let tag_name2;
    	let t13;
    	let undoicon2;
    	let t14;
    	let textarea2;
    	let t15;
    	let tag_container3;
    	let tag_name3;
    	let t16;
    	let undoicon3;
    	let t17;
    	let textarea3;
    	let t18;
    	let tag_container4;
    	let tag_name4;
    	let t19;
    	let undoicon4;
    	let t20;
    	let textarea4;
    	let t21;
    	let tag_container5;
    	let tag_name5;
    	let t22;
    	let undoicon5;
    	let t23;
    	let textarea5;
    	let t24;
    	let tag_container6;
    	let tag_name6;
    	let t25;
    	let undoicon6;
    	let t26;
    	let textarea6;
    	let t27;
    	let tag_container7;
    	let tag_name7;
    	let t28;
    	let undoicon7;
    	let t29;
    	let textarea7;
    	let t30;
    	let tag_container8;
    	let tag_name8;
    	let t31;
    	let undoicon8;
    	let t32;
    	let textarea8;
    	let t33;
    	let tag_container9;
    	let tag_name9;
    	let t34;
    	let undoicon9;
    	let t35;
    	let textarea9;
    	let t36;
    	let tag_container10;
    	let tag_name10;
    	let t37;
    	let undoicon10;
    	let t38;
    	let textarea10;
    	let t39;
    	let tag_container11;
    	let tag_name11;
    	let t40;
    	let undoicon11;
    	let t41;
    	let textarea11;
    	let t42;
    	let tag_container12;
    	let tag_name12;
    	let t43;
    	let undoicon12;
    	let t44;
    	let star;
    	let t45;
    	let album_art;
    	let albumart;
    	let t46;
    	let button_container;
    	let button0;
    	let undoicon13;
    	let t47;
    	let button0_disabled_value;
    	let t48;
    	let button1;
    	let updateicon;
    	let t49;
    	let button1_disabled_value;
    	let current;
    	let mounted;
    	let dispose;
    	undoicon0 = new UndoIcon({ $$inline: true });
    	undoicon1 = new UndoIcon({ $$inline: true });
    	undoicon2 = new UndoIcon({ $$inline: true });
    	undoicon3 = new UndoIcon({ $$inline: true });
    	undoicon4 = new UndoIcon({ $$inline: true });
    	undoicon5 = new UndoIcon({ $$inline: true });
    	undoicon6 = new UndoIcon({ $$inline: true });
    	undoicon7 = new UndoIcon({ $$inline: true });
    	undoicon8 = new UndoIcon({ $$inline: true });
    	undoicon9 = new UndoIcon({ $$inline: true });
    	undoicon10 = new UndoIcon({ $$inline: true });
    	undoicon11 = new UndoIcon({ $$inline: true });
    	undoicon12 = new UndoIcon({ $$inline: true });

    	star = new Star({
    			props: {
    				songRating: Number(/*bindingTags*/ ctx[0].Rating),
    				hook: "tag-edit-svlt",
    				klass: "tag-edit-star"
    			},
    			$$inline: true
    		});

    	star.$on("starChange", /*setStar*/ ctx[4]);

    	albumart = new AlbumArt({
    			props: {
    				imageSourceLocation: /*songsToEdit*/ ctx[1][0]?.SourceFile,
    				intersectionRoot: undefined
    			},
    			$$inline: true
    		});

    	undoicon13 = new UndoIcon({
    			props: {
    				style: "height:1.25rem;width:auto;fill:#fff;margin-right:0.25rem;opacity: 1;"
    			},
    			$$inline: true
    		});

    	updateicon = new UpdateIcon({
    			props: {
    				style: "height:1.25rem;width:auto;fill:#fff;margin-right:0.25rem;"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			tag_edit_svlt = element("tag-edit-svlt");
    			songs_to_edit = element("songs-to-edit");
    			t0 = text("Song");
    			t1 = text(t1_value);
    			t2 = text(" Edit");
    			t3 = text(t3_value);
    			t4 = text(": ");
    			t5 = text(t5_value);
    			t6 = space();
    			tag_container0 = element("tag-container");
    			tag_name0 = element("tag-name");
    			t7 = text("Title ");
    			create_component(undoicon0.$$.fragment);
    			t8 = space();
    			textarea0 = element("textarea");
    			t9 = space();
    			tag_container1 = element("tag-container");
    			tag_name1 = element("tag-name");
    			t10 = text("Album ");
    			create_component(undoicon1.$$.fragment);
    			t11 = space();
    			textarea1 = element("textarea");
    			t12 = space();
    			tag_container2 = element("tag-container");
    			tag_name2 = element("tag-name");
    			t13 = text("Track # ");
    			create_component(undoicon2.$$.fragment);
    			t14 = space();
    			textarea2 = element("textarea");
    			t15 = space();
    			tag_container3 = element("tag-container");
    			tag_name3 = element("tag-name");
    			t16 = text("Disc # ");
    			create_component(undoicon3.$$.fragment);
    			t17 = space();
    			textarea3 = element("textarea");
    			t18 = space();
    			tag_container4 = element("tag-container");
    			tag_name4 = element("tag-name");
    			t19 = text("Artist ");
    			create_component(undoicon4.$$.fragment);
    			t20 = space();
    			textarea4 = element("textarea");
    			t21 = space();
    			tag_container5 = element("tag-container");
    			tag_name5 = element("tag-name");
    			t22 = text("Album Artist ");
    			create_component(undoicon5.$$.fragment);
    			t23 = space();
    			textarea5 = element("textarea");
    			t24 = space();
    			tag_container6 = element("tag-container");
    			tag_name6 = element("tag-name");
    			t25 = text("Genre ");
    			create_component(undoicon6.$$.fragment);
    			t26 = space();
    			textarea6 = element("textarea");
    			t27 = space();
    			tag_container7 = element("tag-container");
    			tag_name7 = element("tag-name");
    			t28 = text("Composer ");
    			create_component(undoicon7.$$.fragment);
    			t29 = space();
    			textarea7 = element("textarea");
    			t30 = space();
    			tag_container8 = element("tag-container");
    			tag_name8 = element("tag-name");
    			t31 = text("Comment ");
    			create_component(undoicon8.$$.fragment);
    			t32 = space();
    			textarea8 = element("textarea");
    			t33 = space();
    			tag_container9 = element("tag-container");
    			tag_name9 = element("tag-name");
    			t34 = text("Year ");
    			create_component(undoicon9.$$.fragment);
    			t35 = space();
    			textarea9 = element("textarea");
    			t36 = space();
    			tag_container10 = element("tag-container");
    			tag_name10 = element("tag-name");
    			t37 = text("Month ");
    			create_component(undoicon10.$$.fragment);
    			t38 = space();
    			textarea10 = element("textarea");
    			t39 = space();
    			tag_container11 = element("tag-container");
    			tag_name11 = element("tag-name");
    			t40 = text("Day ");
    			create_component(undoicon11.$$.fragment);
    			t41 = space();
    			textarea11 = element("textarea");
    			t42 = space();
    			tag_container12 = element("tag-container");
    			tag_name12 = element("tag-name");
    			t43 = text("Rating ");
    			create_component(undoicon12.$$.fragment);
    			t44 = space();
    			create_component(star.$$.fragment);
    			t45 = space();
    			album_art = element("album-art");
    			create_component(albumart.$$.fragment);
    			t46 = space();
    			button_container = element("button-container");
    			button0 = element("button");
    			create_component(undoicon13.$$.fragment);
    			t47 = text("\n\t\t\tCancel");
    			t48 = space();
    			button1 = element("button");
    			create_component(updateicon.$$.fragment);
    			t49 = text("\n\t\t\tUpdate");
    			set_custom_element_data(songs_to_edit, "class", "svelte-vj0jal");
    			add_location(songs_to_edit, file$F, 193, 1, 7915);
    			set_custom_element_data(tag_name0, "class", "svelte-vj0jal");
    			add_location(tag_name0, file$F, 198, 2, 8092);
    			attr_dev(textarea0, "class", "svelte-vj0jal");
    			add_location(textarea0, file$F, 199, 2, 8135);
    			set_custom_element_data(tag_container0, "data-tag", "Title");
    			set_custom_element_data(tag_container0, "class", "svelte-vj0jal");
    			add_location(tag_container0, file$F, 197, 1, 8057);
    			set_custom_element_data(tag_name1, "class", "svelte-vj0jal");
    			add_location(tag_name1, file$F, 203, 2, 8234);
    			attr_dev(textarea1, "class", "svelte-vj0jal");
    			add_location(textarea1, file$F, 204, 2, 8277);
    			set_custom_element_data(tag_container1, "data-tag", "Album");
    			set_custom_element_data(tag_container1, "class", "svelte-vj0jal");
    			add_location(tag_container1, file$F, 202, 1, 8199);
    			set_custom_element_data(tag_name2, "class", "svelte-vj0jal");
    			add_location(tag_name2, file$F, 208, 2, 8395);
    			attr_dev(textarea2, "class", "svelte-vj0jal");
    			add_location(textarea2, file$F, 209, 2, 8440);
    			set_custom_element_data(tag_container2, "data-tag", "Track");
    			set_custom_element_data(tag_container2, "data-type", "number");
    			set_custom_element_data(tag_container2, "class", "svelte-vj0jal");
    			add_location(tag_container2, file$F, 207, 1, 8341);
    			set_custom_element_data(tag_name3, "class", "svelte-vj0jal");
    			add_location(tag_name3, file$F, 213, 2, 8563);
    			attr_dev(textarea3, "class", "svelte-vj0jal");
    			add_location(textarea3, file$F, 214, 2, 8607);
    			set_custom_element_data(tag_container3, "data-tag", "DiscNumber");
    			set_custom_element_data(tag_container3, "data-type", "number");
    			set_custom_element_data(tag_container3, "class", "svelte-vj0jal");
    			add_location(tag_container3, file$F, 212, 1, 8504);
    			set_custom_element_data(tag_name4, "class", "svelte-vj0jal");
    			add_location(tag_name4, file$F, 218, 2, 8712);
    			attr_dev(textarea4, "class", "svelte-vj0jal");
    			add_location(textarea4, file$F, 219, 2, 8756);
    			set_custom_element_data(tag_container4, "data-tag", "Artist");
    			set_custom_element_data(tag_container4, "class", "svelte-vj0jal");
    			add_location(tag_container4, file$F, 217, 1, 8676);
    			set_custom_element_data(tag_name5, "class", "svelte-vj0jal");
    			add_location(tag_name5, file$F, 223, 2, 8862);
    			attr_dev(textarea5, "class", "svelte-vj0jal");
    			add_location(textarea5, file$F, 224, 2, 8912);
    			set_custom_element_data(tag_container5, "data-tag", "AlbumArtist");
    			set_custom_element_data(tag_container5, "class", "svelte-vj0jal");
    			add_location(tag_container5, file$F, 222, 1, 8821);
    			set_custom_element_data(tag_name6, "class", "svelte-vj0jal");
    			add_location(tag_name6, file$F, 228, 2, 9017);
    			attr_dev(textarea6, "class", "svelte-vj0jal");
    			add_location(textarea6, file$F, 229, 2, 9060);
    			set_custom_element_data(tag_container6, "data-tag", "Genre");
    			set_custom_element_data(tag_container6, "class", "svelte-vj0jal");
    			add_location(tag_container6, file$F, 227, 1, 8982);
    			set_custom_element_data(tag_name7, "class", "svelte-vj0jal");
    			add_location(tag_name7, file$F, 233, 2, 9162);
    			attr_dev(textarea7, "class", "svelte-vj0jal");
    			add_location(textarea7, file$F, 234, 2, 9208);
    			set_custom_element_data(tag_container7, "data-tag", "Composer");
    			set_custom_element_data(tag_container7, "class", "svelte-vj0jal");
    			add_location(tag_container7, file$F, 232, 1, 9124);
    			set_custom_element_data(tag_name8, "class", "svelte-vj0jal");
    			add_location(tag_name8, file$F, 238, 2, 9312);
    			attr_dev(textarea8, "class", "svelte-vj0jal");
    			add_location(textarea8, file$F, 239, 2, 9357);
    			set_custom_element_data(tag_container8, "data-tag", "Comment");
    			set_custom_element_data(tag_container8, "class", "svelte-vj0jal");
    			add_location(tag_container8, file$F, 237, 1, 9275);
    			set_custom_element_data(tag_name9, "class", "svelte-vj0jal");
    			add_location(tag_name9, file$F, 243, 2, 9481);
    			attr_dev(textarea9, "class", "svelte-vj0jal");
    			add_location(textarea9, file$F, 244, 2, 9523);
    			set_custom_element_data(tag_container9, "data-tag", "Date_Year");
    			set_custom_element_data(tag_container9, "data-type", "number");
    			set_custom_element_data(tag_container9, "class", "svelte-vj0jal");
    			add_location(tag_container9, file$F, 242, 1, 9423);
    			set_custom_element_data(tag_name10, "class", "svelte-vj0jal");
    			add_location(tag_name10, file$F, 248, 2, 9650);
    			attr_dev(textarea10, "class", "svelte-vj0jal");
    			add_location(textarea10, file$F, 249, 2, 9693);
    			set_custom_element_data(tag_container10, "data-tag", "Date_Month");
    			set_custom_element_data(tag_container10, "data-type", "number");
    			set_custom_element_data(tag_container10, "class", "svelte-vj0jal");
    			add_location(tag_container10, file$F, 247, 1, 9591);
    			set_custom_element_data(tag_name11, "class", "svelte-vj0jal");
    			add_location(tag_name11, file$F, 253, 2, 9819);
    			attr_dev(textarea11, "class", "svelte-vj0jal");
    			add_location(textarea11, file$F, 254, 2, 9860);
    			set_custom_element_data(tag_container11, "data-tag", "Date_Day");
    			set_custom_element_data(tag_container11, "data-type", "number");
    			set_custom_element_data(tag_container11, "class", "svelte-vj0jal");
    			add_location(tag_container11, file$F, 252, 1, 9762);
    			set_custom_element_data(tag_name12, "class", "svelte-vj0jal");
    			add_location(tag_name12, file$F, 258, 2, 9963);
    			set_custom_element_data(tag_container12, "data-tag", "Rating");
    			set_custom_element_data(tag_container12, "class", "svelte-vj0jal");
    			add_location(tag_container12, file$F, 257, 1, 9927);
    			set_custom_element_data(album_art, "class", "svelte-vj0jal");
    			add_location(album_art, file$F, 262, 1, 10143);
    			attr_dev(button0, "class", "danger");
    			button0.disabled = button0_disabled_value = isEmptyObject(/*newTags*/ ctx[2]);
    			add_location(button0, file$F, 267, 2, 10285);
    			attr_dev(button1, "class", "info");
    			button1.disabled = button1_disabled_value = isEmptyObject(/*newTags*/ ctx[2]);
    			add_location(button1, file$F, 271, 2, 10491);
    			set_custom_element_data(button_container, "class", "svelte-vj0jal");
    			add_location(button_container, file$F, 266, 1, 10264);
    			set_custom_element_data(tag_edit_svlt, "class", "svelte-vj0jal");
    			add_location(tag_edit_svlt, file$F, 192, 0, 7898);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tag_edit_svlt, anchor);
    			append_dev(tag_edit_svlt, songs_to_edit);
    			append_dev(songs_to_edit, t0);
    			append_dev(songs_to_edit, t1);
    			append_dev(songs_to_edit, t2);
    			append_dev(songs_to_edit, t3);
    			append_dev(songs_to_edit, t4);
    			append_dev(songs_to_edit, t5);
    			append_dev(tag_edit_svlt, t6);
    			append_dev(tag_edit_svlt, tag_container0);
    			append_dev(tag_container0, tag_name0);
    			append_dev(tag_name0, t7);
    			mount_component(undoicon0, tag_name0, null);
    			append_dev(tag_container0, t8);
    			append_dev(tag_container0, textarea0);
    			set_input_value(textarea0, /*bindingTags*/ ctx[0].Title);
    			append_dev(tag_edit_svlt, t9);
    			append_dev(tag_edit_svlt, tag_container1);
    			append_dev(tag_container1, tag_name1);
    			append_dev(tag_name1, t10);
    			mount_component(undoicon1, tag_name1, null);
    			append_dev(tag_container1, t11);
    			append_dev(tag_container1, textarea1);
    			set_input_value(textarea1, /*bindingTags*/ ctx[0].Album);
    			append_dev(tag_edit_svlt, t12);
    			append_dev(tag_edit_svlt, tag_container2);
    			append_dev(tag_container2, tag_name2);
    			append_dev(tag_name2, t13);
    			mount_component(undoicon2, tag_name2, null);
    			append_dev(tag_container2, t14);
    			append_dev(tag_container2, textarea2);
    			set_input_value(textarea2, /*bindingTags*/ ctx[0].Track);
    			append_dev(tag_edit_svlt, t15);
    			append_dev(tag_edit_svlt, tag_container3);
    			append_dev(tag_container3, tag_name3);
    			append_dev(tag_name3, t16);
    			mount_component(undoicon3, tag_name3, null);
    			append_dev(tag_container3, t17);
    			append_dev(tag_container3, textarea3);
    			set_input_value(textarea3, /*bindingTags*/ ctx[0].DiscNumber);
    			append_dev(tag_edit_svlt, t18);
    			append_dev(tag_edit_svlt, tag_container4);
    			append_dev(tag_container4, tag_name4);
    			append_dev(tag_name4, t19);
    			mount_component(undoicon4, tag_name4, null);
    			append_dev(tag_container4, t20);
    			append_dev(tag_container4, textarea4);
    			set_input_value(textarea4, /*bindingTags*/ ctx[0].Artist);
    			append_dev(tag_edit_svlt, t21);
    			append_dev(tag_edit_svlt, tag_container5);
    			append_dev(tag_container5, tag_name5);
    			append_dev(tag_name5, t22);
    			mount_component(undoicon5, tag_name5, null);
    			append_dev(tag_container5, t23);
    			append_dev(tag_container5, textarea5);
    			set_input_value(textarea5, /*bindingTags*/ ctx[0].AlbumArtist);
    			append_dev(tag_edit_svlt, t24);
    			append_dev(tag_edit_svlt, tag_container6);
    			append_dev(tag_container6, tag_name6);
    			append_dev(tag_name6, t25);
    			mount_component(undoicon6, tag_name6, null);
    			append_dev(tag_container6, t26);
    			append_dev(tag_container6, textarea6);
    			set_input_value(textarea6, /*bindingTags*/ ctx[0].Genre);
    			append_dev(tag_edit_svlt, t27);
    			append_dev(tag_edit_svlt, tag_container7);
    			append_dev(tag_container7, tag_name7);
    			append_dev(tag_name7, t28);
    			mount_component(undoicon7, tag_name7, null);
    			append_dev(tag_container7, t29);
    			append_dev(tag_container7, textarea7);
    			set_input_value(textarea7, /*bindingTags*/ ctx[0].Composer);
    			append_dev(tag_edit_svlt, t30);
    			append_dev(tag_edit_svlt, tag_container8);
    			append_dev(tag_container8, tag_name8);
    			append_dev(tag_name8, t31);
    			mount_component(undoicon8, tag_name8, null);
    			append_dev(tag_container8, t32);
    			append_dev(tag_container8, textarea8);
    			set_input_value(textarea8, /*bindingTags*/ ctx[0].Comment);
    			append_dev(tag_edit_svlt, t33);
    			append_dev(tag_edit_svlt, tag_container9);
    			append_dev(tag_container9, tag_name9);
    			append_dev(tag_name9, t34);
    			mount_component(undoicon9, tag_name9, null);
    			append_dev(tag_container9, t35);
    			append_dev(tag_container9, textarea9);
    			set_input_value(textarea9, /*bindingTags*/ ctx[0].Date_Year);
    			append_dev(tag_edit_svlt, t36);
    			append_dev(tag_edit_svlt, tag_container10);
    			append_dev(tag_container10, tag_name10);
    			append_dev(tag_name10, t37);
    			mount_component(undoicon10, tag_name10, null);
    			append_dev(tag_container10, t38);
    			append_dev(tag_container10, textarea10);
    			set_input_value(textarea10, /*bindingTags*/ ctx[0].Date_Month);
    			append_dev(tag_edit_svlt, t39);
    			append_dev(tag_edit_svlt, tag_container11);
    			append_dev(tag_container11, tag_name11);
    			append_dev(tag_name11, t40);
    			mount_component(undoicon11, tag_name11, null);
    			append_dev(tag_container11, t41);
    			append_dev(tag_container11, textarea11);
    			set_input_value(textarea11, /*bindingTags*/ ctx[0].Date_Day);
    			append_dev(tag_edit_svlt, t42);
    			append_dev(tag_edit_svlt, tag_container12);
    			append_dev(tag_container12, tag_name12);
    			append_dev(tag_name12, t43);
    			mount_component(undoicon12, tag_name12, null);
    			append_dev(tag_container12, t44);
    			mount_component(star, tag_container12, null);
    			append_dev(tag_edit_svlt, t45);
    			append_dev(tag_edit_svlt, album_art);
    			mount_component(albumart, album_art, null);
    			append_dev(tag_edit_svlt, t46);
    			append_dev(tag_edit_svlt, button_container);
    			append_dev(button_container, button0);
    			mount_component(undoicon13, button0, null);
    			append_dev(button0, t47);
    			append_dev(button_container, t48);
    			append_dev(button_container, button1);
    			mount_component(updateicon, button1, null);
    			append_dev(button1, t49);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(textarea0, "input", /*textarea0_input_handler*/ ctx[9]),
    					listen_dev(textarea1, "input", /*textarea1_input_handler*/ ctx[10]),
    					listen_dev(textarea2, "input", /*textarea2_input_handler*/ ctx[11]),
    					listen_dev(textarea3, "input", /*textarea3_input_handler*/ ctx[12]),
    					listen_dev(textarea4, "input", /*textarea4_input_handler*/ ctx[13]),
    					listen_dev(textarea5, "input", /*textarea5_input_handler*/ ctx[14]),
    					listen_dev(textarea6, "input", /*textarea6_input_handler*/ ctx[15]),
    					listen_dev(textarea7, "input", /*textarea7_input_handler*/ ctx[16]),
    					listen_dev(textarea8, "input", /*textarea8_input_handler*/ ctx[17]),
    					listen_dev(textarea9, "input", /*textarea9_input_handler*/ ctx[18]),
    					listen_dev(textarea10, "input", /*textarea10_input_handler*/ ctx[19]),
    					listen_dev(textarea11, "input", /*textarea11_input_handler*/ ctx[20]),
    					listen_dev(button0, "click", /*click_handler*/ ctx[21], false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[22], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*songsToEdit*/ 2) && t1_value !== (t1_value = (/*songsToEdit*/ ctx[1].length > 1 ? 's' : '') + "")) set_data_dev(t1, t1_value);
    			if ((!current || dirty & /*songsToEdit*/ 2) && t3_value !== (t3_value = (/*songsToEdit*/ ctx[1].length > 0 ? 'ing' : '') + "")) set_data_dev(t3, t3_value);
    			if ((!current || dirty & /*songsToEdit*/ 2) && t5_value !== (t5_value = /*songsToEdit*/ ctx[1].length + "")) set_data_dev(t5, t5_value);

    			if (dirty & /*bindingTags*/ 1) {
    				set_input_value(textarea0, /*bindingTags*/ ctx[0].Title);
    			}

    			if (dirty & /*bindingTags*/ 1) {
    				set_input_value(textarea1, /*bindingTags*/ ctx[0].Album);
    			}

    			if (dirty & /*bindingTags*/ 1) {
    				set_input_value(textarea2, /*bindingTags*/ ctx[0].Track);
    			}

    			if (dirty & /*bindingTags*/ 1) {
    				set_input_value(textarea3, /*bindingTags*/ ctx[0].DiscNumber);
    			}

    			if (dirty & /*bindingTags*/ 1) {
    				set_input_value(textarea4, /*bindingTags*/ ctx[0].Artist);
    			}

    			if (dirty & /*bindingTags*/ 1) {
    				set_input_value(textarea5, /*bindingTags*/ ctx[0].AlbumArtist);
    			}

    			if (dirty & /*bindingTags*/ 1) {
    				set_input_value(textarea6, /*bindingTags*/ ctx[0].Genre);
    			}

    			if (dirty & /*bindingTags*/ 1) {
    				set_input_value(textarea7, /*bindingTags*/ ctx[0].Composer);
    			}

    			if (dirty & /*bindingTags*/ 1) {
    				set_input_value(textarea8, /*bindingTags*/ ctx[0].Comment);
    			}

    			if (dirty & /*bindingTags*/ 1) {
    				set_input_value(textarea9, /*bindingTags*/ ctx[0].Date_Year);
    			}

    			if (dirty & /*bindingTags*/ 1) {
    				set_input_value(textarea10, /*bindingTags*/ ctx[0].Date_Month);
    			}

    			if (dirty & /*bindingTags*/ 1) {
    				set_input_value(textarea11, /*bindingTags*/ ctx[0].Date_Day);
    			}

    			const star_changes = {};
    			if (dirty & /*bindingTags*/ 1) star_changes.songRating = Number(/*bindingTags*/ ctx[0].Rating);
    			star.$set(star_changes);
    			const albumart_changes = {};
    			if (dirty & /*songsToEdit*/ 2) albumart_changes.imageSourceLocation = /*songsToEdit*/ ctx[1][0]?.SourceFile;
    			albumart.$set(albumart_changes);

    			if (!current || dirty & /*newTags*/ 4 && button0_disabled_value !== (button0_disabled_value = isEmptyObject(/*newTags*/ ctx[2]))) {
    				prop_dev(button0, "disabled", button0_disabled_value);
    			}

    			if (!current || dirty & /*newTags*/ 4 && button1_disabled_value !== (button1_disabled_value = isEmptyObject(/*newTags*/ ctx[2]))) {
    				prop_dev(button1, "disabled", button1_disabled_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(undoicon0.$$.fragment, local);
    			transition_in(undoicon1.$$.fragment, local);
    			transition_in(undoicon2.$$.fragment, local);
    			transition_in(undoicon3.$$.fragment, local);
    			transition_in(undoicon4.$$.fragment, local);
    			transition_in(undoicon5.$$.fragment, local);
    			transition_in(undoicon6.$$.fragment, local);
    			transition_in(undoicon7.$$.fragment, local);
    			transition_in(undoicon8.$$.fragment, local);
    			transition_in(undoicon9.$$.fragment, local);
    			transition_in(undoicon10.$$.fragment, local);
    			transition_in(undoicon11.$$.fragment, local);
    			transition_in(undoicon12.$$.fragment, local);
    			transition_in(star.$$.fragment, local);
    			transition_in(albumart.$$.fragment, local);
    			transition_in(undoicon13.$$.fragment, local);
    			transition_in(updateicon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(undoicon0.$$.fragment, local);
    			transition_out(undoicon1.$$.fragment, local);
    			transition_out(undoicon2.$$.fragment, local);
    			transition_out(undoicon3.$$.fragment, local);
    			transition_out(undoicon4.$$.fragment, local);
    			transition_out(undoicon5.$$.fragment, local);
    			transition_out(undoicon6.$$.fragment, local);
    			transition_out(undoicon7.$$.fragment, local);
    			transition_out(undoicon8.$$.fragment, local);
    			transition_out(undoicon9.$$.fragment, local);
    			transition_out(undoicon10.$$.fragment, local);
    			transition_out(undoicon11.$$.fragment, local);
    			transition_out(undoicon12.$$.fragment, local);
    			transition_out(star.$$.fragment, local);
    			transition_out(albumart.$$.fragment, local);
    			transition_out(undoicon13.$$.fragment, local);
    			transition_out(updateicon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tag_edit_svlt);
    			destroy_component(undoicon0);
    			destroy_component(undoicon1);
    			destroy_component(undoicon2);
    			destroy_component(undoicon3);
    			destroy_component(undoicon4);
    			destroy_component(undoicon5);
    			destroy_component(undoicon6);
    			destroy_component(undoicon7);
    			destroy_component(undoicon8);
    			destroy_component(undoicon9);
    			destroy_component(undoicon10);
    			destroy_component(undoicon11);
    			destroy_component(undoicon12);
    			destroy_component(star);
    			destroy_component(albumart);
    			destroy_component(undoicon13);
    			destroy_component(updateicon);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$K.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function resizeTextArea(evt, type) {
    	let textAreaElement = evt.target;

    	if (textAreaElement) {
    		if (type === 'expand') {
    			textAreaElement.style.minHeight = textAreaElement.scrollHeight + 'px';
    		} else if (type === 'collapse') {
    			textAreaElement.style.minHeight = '0px';
    		}
    	}
    }

    function setUndoIconVisibility(query, { isVisible }) {
    	let undoIconElement = document.querySelector(`svg[data-tag="${query}"]`);

    	if (undoIconElement) {
    		undoIconElement.style.opacity = isVisible ? '1' : '0';
    		undoIconElement.style.pointerEvents = isVisible ? 'all' : 'none';
    	}
    }

    function removeSuggestedTags(textAreaElement) {
    	let eventTargetTagSuggestionElement = textAreaElement.parentElement.querySelector('tag-suggestions');

    	if (eventTargetTagSuggestionElement) {
    		eventTargetTagSuggestionElement.innerHTML = '';
    	}
    }

    function instance$K($$self, $$props, $$invalidate) {
    	let $selectedSongsStore;
    	let $songListStore;
    	let $songSyncQueueProgress;
    	let $elementMap;
    	validate_store(selectedSongsStore, 'selectedSongsStore');
    	component_subscribe($$self, selectedSongsStore, $$value => $$invalidate(7, $selectedSongsStore = $$value));
    	validate_store(songListStore, 'songListStore');
    	component_subscribe($$self, songListStore, $$value => $$invalidate(8, $songListStore = $$value));
    	validate_store(songSyncQueueProgress, 'songSyncQueueProgress');
    	component_subscribe($$self, songSyncQueueProgress, $$value => $$invalidate(23, $songSyncQueueProgress = $$value));
    	validate_store(elementMap, 'elementMap');
    	component_subscribe($$self, elementMap, $$value => $$invalidate(3, $elementMap = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TagEdit', slots, []);
    	let songsToEdit = [];
    	let groupedTags = {};
    	let bindingTags = {};
    	let newTags = {};

    	function setupSongs(from) {
    		if (from === 'songListStoreUpdate' && $songSyncQueueProgress.currentLength > 1) {
    			return;
    		}

    		$$invalidate(1, songsToEdit = filterSongsToEdit($songListStore, $selectedSongsStore));
    		$$invalidate(6, groupedTags = groupSongsByValues(songsToEdit));
    		$$invalidate(0, bindingTags = Object.assign({}, groupedTags));
    	}

    	function setStar(starChangeEvent) {
    		let newRating = starChangeEvent.detail.rating;
    		$$invalidate(0, bindingTags.Rating = newRating, bindingTags);

    		if (newRating === '' && groupedTags['Rating'] === null) {
    			$$invalidate(0, bindingTags['Rating'] = null, bindingTags);
    		}

    		if (bindingTags['Rating'] !== groupedTags['Rating']) {
    			setUndoIconVisibility('Rating', { isVisible: true });
    		} else {
    			setUndoIconVisibility('Rating', { isVisible: false });
    		}
    	}

    	function forceNumberInput(element) {
    		let dataSet = element.dataset;
    		let bindingTagData = bindingTags[dataSet.tag];
    		$$invalidate(0, bindingTags[dataSet.tag] = bindingTagData.replace(/[^0-9]/g, ''), bindingTags);
    	}

    	function checkInput(inputElement, parentElement) {
    		let inputValue = inputElement.value;
    		let data = parentElement.dataset;

    		if (inputValue === '' && groupedTags[data.tag] === null) {
    			$$invalidate(0, bindingTags[data.tag] = null, bindingTags);
    		}

    		if (bindingTags[data.tag] !== groupedTags[data.tag]) {
    			setUndoIconVisibility(data.tag, { isVisible: true });
    		} else {
    			setUndoIconVisibility(data.tag, { isVisible: false });
    		}
    	}

    	function suggestTags(evt, parentElement) {
    		let inputElement = evt.target;
    		let inputValue = inputElement.value;
    		let data = parentElement.dataset;

    		tagEditSuggestionFn(inputElement.parentElement, data.tag, inputValue).then(result => {
    			if (result) {
    				console.log(result);
    				$$invalidate(0, bindingTags[data.tag] = result, bindingTags);
    			}
    		});
    	}

    	function undoTagModification(tag) {
    		$$invalidate(0, bindingTags[tag] = groupedTags[tag], bindingTags);
    		setUndoIconVisibility(tag, { isVisible: false });
    	}

    	function hookUpEventListeners() {
    		let tagContainerElements = document.querySelectorAll('tag-edit-svlt tag-container');

    		tagContainerElements.forEach(tagContainerElement => {
    			let textAreaElement = tagContainerElement.querySelector('textarea');
    			let undoIconElement = tagContainerElement.querySelector('svg');
    			let dataSet = tagContainerElement.dataset;

    			if (dataSet.type === 'number') {
    				textAreaElement.addEventListener('input', evt => forceNumberInput(tagContainerElement));
    			}

    			if (textAreaElement) {
    				textAreaElement.spellcheck = false;
    				textAreaElement.rows = 1;
    				textAreaElement.addEventListener('mouseleave', evt => resizeTextArea(evt, 'collapse'));
    				textAreaElement.addEventListener('mouseover', evt => resizeTextArea(evt, 'expand'));
    				textAreaElement.addEventListener('input', evt => resizeTextArea(evt, 'expand'));
    				textAreaElement.addEventListener('input', evt => checkInput(evt.target, tagContainerElement));
    				textAreaElement.addEventListener('input', evt => suggestTags(evt, tagContainerElement));

    				textAreaElement.addEventListener('focus', evt => {
    					setTimeout(
    						() => {
    							suggestTags(evt, tagContainerElement);
    						},
    						100
    					);
    				});

    				textAreaElement.addEventListener('focusout', evt => {
    					setTimeout(
    						() => {
    							removeSuggestedTags(evt.target);
    						},
    						100
    					);
    				});

    				textAreaElement.addEventListener('keydown', evt => {
    					if (['ArrowDown', 'ArrowUp', 'Escape', 'Enter'].includes(evt.key)) {
    						if (evt.key === 'Enter') evt.preventDefault();
    						selectSuggestion(evt.target, evt.key);
    					}
    				});
    			}

    			if (undoIconElement) {
    				undoIconElement.setAttribute('data-tag', dataSet.tag);
    				undoIconElement.style.position = 'absolute';
    				undoIconElement.style.right = '0';
    				undoIconElement.style.transform = 'translateX(calc(1rem + 2px))';
    				undoIconElement.style.opacity = '0';
    				undoIconElement.addEventListener('click', evt => undoTagModification(dataSet.tag));
    			}
    		});
    	}

    	function selectSuggestion(targetElement, keyPressed) {
    		let suggestionElements = targetElement.parentElement.querySelector('tag-suggestions');

    		if (keyPressed === 'Enter') {
    			let selectedSuggestion = suggestionElements.querySelector('tag-suggestion.selected');

    			let data = selectedSuggestion === null || selectedSuggestion === void 0
    			? void 0
    			: selectedSuggestion.dataset;

    			if (selectedSuggestion && data.tag && data.content) {
    				$$invalidate(0, bindingTags[data.tag] = data.content, bindingTags);
    			}

    			removeSuggestedTags(targetElement);
    			checkInput(targetElement, targetElement.parentElement);
    			return;
    		}

    		if (keyPressed === 'Escape') {
    			targetElement.blur();
    			return;
    		}

    		if (suggestionElements.dataset.index === undefined) {
    			suggestionElements.dataset.index = '-1';
    		}

    		if (keyPressed === 'ArrowDown') {
    			suggestionElements.dataset.index = String(Number(suggestionElements.dataset.index) + 1);
    		} else if (keyPressed === 'ArrowUp') {
    			suggestionElements.dataset.index = String(Number(suggestionElements.dataset.index) - 1);
    		}

    		let suggestionElement = suggestionElements.querySelector(`tag-suggestion[data-index="${suggestionElements.dataset.index}"]`);

    		if (suggestionElement === null) {
    			suggestionElement = suggestionElements.querySelector(`tag-suggestion[data-index="0"]`);
    			suggestionElements.dataset.index = '0';
    			if (suggestionElement === null) return;
    		}

    		suggestionElements.querySelectorAll('tag-suggestion').forEach(suggestion => {
    			suggestion.classList.remove('selected');
    		});

    		suggestionElement.classList.add('selected');
    	}

    	function undoAllTags() {
    		for (let tag in bindingTags) {
    			undoTagModification(tag);
    		}
    	}

    	onMount(() => {
    		hookUpEventListeners();
    	});

    	const writable_props = [];

    	Object_1$1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$1.warn(`<TagEdit> was created with unknown prop '${key}'`);
    	});

    	function textarea0_input_handler() {
    		bindingTags.Title = this.value;
    		$$invalidate(0, bindingTags);
    	}

    	function textarea1_input_handler() {
    		bindingTags.Album = this.value;
    		$$invalidate(0, bindingTags);
    	}

    	function textarea2_input_handler() {
    		bindingTags.Track = this.value;
    		$$invalidate(0, bindingTags);
    	}

    	function textarea3_input_handler() {
    		bindingTags.DiscNumber = this.value;
    		$$invalidate(0, bindingTags);
    	}

    	function textarea4_input_handler() {
    		bindingTags.Artist = this.value;
    		$$invalidate(0, bindingTags);
    	}

    	function textarea5_input_handler() {
    		bindingTags.AlbumArtist = this.value;
    		$$invalidate(0, bindingTags);
    	}

    	function textarea6_input_handler() {
    		bindingTags.Genre = this.value;
    		$$invalidate(0, bindingTags);
    	}

    	function textarea7_input_handler() {
    		bindingTags.Composer = this.value;
    		$$invalidate(0, bindingTags);
    	}

    	function textarea8_input_handler() {
    		bindingTags.Comment = this.value;
    		$$invalidate(0, bindingTags);
    	}

    	function textarea9_input_handler() {
    		bindingTags.Date_Year = this.value;
    		$$invalidate(0, bindingTags);
    	}

    	function textarea10_input_handler() {
    		bindingTags.Date_Month = this.value;
    		$$invalidate(0, bindingTags);
    	}

    	function textarea11_input_handler() {
    		bindingTags.Date_Day = this.value;
    		$$invalidate(0, bindingTags);
    	}

    	const click_handler = () => undoAllTags();

    	const click_handler_1 = () => {
    		window.ipc.updateSongs(songsToEdit, newTags);
    		set_store_value(elementMap, $elementMap = undefined, $elementMap);
    	};

    	$$self.$capture_state = () => ({
    		elementMap,
    		selectedSongsStore,
    		songListStore,
    		songSyncQueueProgress,
    		filterSongsToEdit,
    		getObjectDifference,
    		groupSongsByValues,
    		Star,
    		onMount,
    		UndoIcon,
    		AlbumArt,
    		UpdateIcon,
    		isEmptyObject,
    		tagEditSuggestionFn,
    		songsToEdit,
    		groupedTags,
    		bindingTags,
    		newTags,
    		setupSongs,
    		setStar,
    		resizeTextArea,
    		forceNumberInput,
    		checkInput,
    		suggestTags,
    		undoTagModification,
    		setUndoIconVisibility,
    		removeSuggestedTags,
    		hookUpEventListeners,
    		selectSuggestion,
    		undoAllTags,
    		$selectedSongsStore,
    		$songListStore,
    		$songSyncQueueProgress,
    		$elementMap
    	});

    	$$self.$inject_state = $$props => {
    		if ('songsToEdit' in $$props) $$invalidate(1, songsToEdit = $$props.songsToEdit);
    		if ('groupedTags' in $$props) $$invalidate(6, groupedTags = $$props.groupedTags);
    		if ('bindingTags' in $$props) $$invalidate(0, bindingTags = $$props.bindingTags);
    		if ('newTags' in $$props) $$invalidate(2, newTags = $$props.newTags);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$songListStore*/ 256) {
    			{
    				setupSongs('songListStoreUpdate');
    			}
    		}

    		if ($$self.$$.dirty & /*$selectedSongsStore*/ 128) {
    			{
    				setupSongs('selectedSongsStoreUpdate');
    			}
    		}

    		if ($$self.$$.dirty & /*groupedTags, bindingTags*/ 65) {
    			$$invalidate(2, newTags = getObjectDifference(groupedTags, bindingTags));
    		}
    	};

    	return [
    		bindingTags,
    		songsToEdit,
    		newTags,
    		$elementMap,
    		setStar,
    		undoAllTags,
    		groupedTags,
    		$selectedSongsStore,
    		$songListStore,
    		textarea0_input_handler,
    		textarea1_input_handler,
    		textarea2_input_handler,
    		textarea3_input_handler,
    		textarea4_input_handler,
    		textarea5_input_handler,
    		textarea6_input_handler,
    		textarea7_input_handler,
    		textarea8_input_handler,
    		textarea9_input_handler,
    		textarea10_input_handler,
    		textarea11_input_handler,
    		click_handler,
    		click_handler_1
    	];
    }

    class TagEdit extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$K, create_fragment$K, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TagEdit",
    			options,
    			id: create_fragment$K.name
    		});
    	}
    }

    /* src/layouts/library/TagGroup.svelte generated by Svelte v3.49.0 */

    const file$E = "src/layouts/library/TagGroup.svelte";

    function get_each_context$9(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	child_ctx[12] = i;
    	return child_ctx;
    }

    function get_each_context_1$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[13] = list[i];
    	return child_ctx;
    }

    // (54:3) {#if $selectedGroups[index]}
    function create_if_block$8(ctx) {
    	let group_value;
    	let t0;
    	let t1_value = /*$selectedGroups*/ ctx[1][/*index*/ ctx[12]].length + "";
    	let t1;
    	let t2;
    	let group_value_class_value;
    	let t3;
    	let each_1_anchor;
    	let mounted;
    	let dispose;

    	function click_handler_1() {
    		return /*click_handler_1*/ ctx[7](/*index*/ ctx[12]);
    	}

    	let each_value_1 = /*$selectedGroups*/ ctx[1][/*index*/ ctx[12]];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			group_value = element("group-value");
    			t0 = text("All (");
    			t1 = text(t1_value);
    			t2 = text(")");
    			t3 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();

    			set_custom_element_data(group_value, "class", group_value_class_value = "" + (null_to_empty(/*$config*/ ctx[0].group.groupByValues[/*index*/ ctx[12]] === 'undefined'
    			? 'selected'
    			: null) + " svelte-zpua8o"));

    			add_location(group_value, file$E, 54, 4, 1699);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, group_value, anchor);
    			append_dev(group_value, t0);
    			append_dev(group_value, t1);
    			append_dev(group_value, t2);
    			insert_dev(target, t3, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);

    			if (!mounted) {
    				dispose = listen_dev(group_value, "click", click_handler_1, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*$selectedGroups, $config*/ 3 && t1_value !== (t1_value = /*$selectedGroups*/ ctx[1][/*index*/ ctx[12]].length + "")) set_data_dev(t1, t1_value);

    			if (dirty & /*$config*/ 1 && group_value_class_value !== (group_value_class_value = "" + (null_to_empty(/*$config*/ ctx[0].group.groupByValues[/*index*/ ctx[12]] === 'undefined'
    			? 'selected'
    			: null) + " svelte-zpua8o"))) {
    				set_custom_element_data(group_value, "class", group_value_class_value);
    			}

    			if (dirty & /*$config, $selectedGroups, setNewGroupValue*/ 7) {
    				each_value_1 = /*$selectedGroups*/ ctx[1][/*index*/ ctx[12]];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(group_value);
    			if (detaching) detach_dev(t3);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(54:3) {#if $selectedGroups[index]}",
    		ctx
    	});

    	return block;
    }

    // (61:4) {#each $selectedGroups[index] as groupValue}
    function create_each_block_1$1(ctx) {
    	let group_value;
    	let t0_value = /*groupValue*/ ctx[13] + "";
    	let t0;
    	let t1;
    	let group_value_class_value;
    	let mounted;
    	let dispose;

    	function click_handler_2() {
    		return /*click_handler_2*/ ctx[8](/*index*/ ctx[12], /*groupValue*/ ctx[13]);
    	}

    	const block = {
    		c: function create() {
    			group_value = element("group-value");
    			t0 = text(t0_value);
    			t1 = space();

    			set_custom_element_data(group_value, "class", group_value_class_value = "" + (null_to_empty(/*$config*/ ctx[0].group.groupByValues[/*index*/ ctx[12]] === /*groupValue*/ ctx[13]
    			? 'selected'
    			: null) + " svelte-zpua8o"));

    			add_location(group_value, file$E, 61, 5, 1977);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, group_value, anchor);
    			append_dev(group_value, t0);
    			append_dev(group_value, t1);

    			if (!mounted) {
    				dispose = listen_dev(group_value, "click", click_handler_2, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*$selectedGroups, $config*/ 3 && t0_value !== (t0_value = /*groupValue*/ ctx[13] + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*$config, $selectedGroups*/ 3 && group_value_class_value !== (group_value_class_value = "" + (null_to_empty(/*$config*/ ctx[0].group.groupByValues[/*index*/ ctx[12]] === /*groupValue*/ ctx[13]
    			? 'selected'
    			: null) + " svelte-zpua8o"))) {
    				set_custom_element_data(group_value, "class", group_value_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(group_value);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$1.name,
    		type: "each",
    		source: "(61:4) {#each $selectedGroups[index] as groupValue}",
    		ctx
    	});

    	return block;
    }

    // (50:1) {#each $config.group.groupBy || [] as group, index (index)}
    function create_each_block$9(key_1, ctx) {
    	let group_svlt;
    	let group_name;
    	let t0_value = /*group*/ ctx[10] + "";
    	let t0;
    	let group_name_data_name_value;
    	let group_name_data_index_value;
    	let t1;
    	let t2;
    	let group_svlt_data_index_value;
    	let mounted;
    	let dispose;
    	let if_block = /*$selectedGroups*/ ctx[1][/*index*/ ctx[12]] && create_if_block$8(ctx);

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			group_svlt = element("group-svlt");
    			group_name = element("group-name");
    			t0 = text(t0_value);
    			t1 = space();
    			if (if_block) if_block.c();
    			t2 = space();
    			set_custom_element_data(group_name, "data-name", group_name_data_name_value = /*group*/ ctx[10]);
    			set_custom_element_data(group_name, "data-index", group_name_data_index_value = /*index*/ ctx[12]);
    			set_custom_element_data(group_name, "class", "svelte-zpua8o");
    			add_location(group_name, file$E, 51, 3, 1550);
    			set_custom_element_data(group_svlt, "data-index", group_svlt_data_index_value = /*index*/ ctx[12]);
    			set_custom_element_data(group_svlt, "class", "svelte-zpua8o");
    			add_location(group_svlt, file$E, 50, 2, 1515);
    			this.first = group_svlt;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, group_svlt, anchor);
    			append_dev(group_svlt, group_name);
    			append_dev(group_name, t0);
    			append_dev(group_svlt, t1);
    			if (if_block) if_block.m(group_svlt, null);
    			append_dev(group_svlt, t2);

    			if (!mounted) {
    				dispose = listen_dev(group_name, "click", /*click_handler*/ ctx[6], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*$config*/ 1 && t0_value !== (t0_value = /*group*/ ctx[10] + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*$config*/ 1 && group_name_data_name_value !== (group_name_data_name_value = /*group*/ ctx[10])) {
    				set_custom_element_data(group_name, "data-name", group_name_data_name_value);
    			}

    			if (dirty & /*$config*/ 1 && group_name_data_index_value !== (group_name_data_index_value = /*index*/ ctx[12])) {
    				set_custom_element_data(group_name, "data-index", group_name_data_index_value);
    			}

    			if (/*$selectedGroups*/ ctx[1][/*index*/ ctx[12]]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$8(ctx);
    					if_block.c();
    					if_block.m(group_svlt, t2);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*$config*/ 1 && group_svlt_data_index_value !== (group_svlt_data_index_value = /*index*/ ctx[12])) {
    				set_custom_element_data(group_svlt, "data-index", group_svlt_data_index_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(group_svlt);
    			if (if_block) if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$9.name,
    		type: "each",
    		source: "(50:1) {#each $config.group.groupBy || [] as group, index (index)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$J(ctx) {
    	let tag_group_svlt;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let each_value = /*$config*/ ctx[0].group.groupBy || [];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*index*/ ctx[12];
    	validate_each_keys(ctx, each_value, get_each_context$9, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$9(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$9(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			tag_group_svlt = element("tag-group-svlt");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			set_custom_element_data(tag_group_svlt, "class", "svelte-zpua8o");
    			add_location(tag_group_svlt, file$E, 48, 0, 1435);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tag_group_svlt, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tag_group_svlt, null);
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$config, $selectedGroups, setNewGroupValue, handleContextMenuEvent*/ 7) {
    				each_value = /*$config*/ ctx[0].group.groupBy || [];
    				validate_each_argument(each_value);
    				validate_each_keys(ctx, each_value, get_each_context$9, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, tag_group_svlt, destroy_block, create_each_block$9, null, get_each_context$9);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tag_group_svlt);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$J.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$J($$self, $$props, $$invalidate) {
    	let $config;
    	let $selectedGroups;
    	let $triggerGroupingChangeEvent;
    	let $dbVersionStore;
    	validate_store(config, 'config');
    	component_subscribe($$self, config, $$value => $$invalidate(0, $config = $$value));
    	validate_store(selectedGroups, 'selectedGroups');
    	component_subscribe($$self, selectedGroups, $$value => $$invalidate(1, $selectedGroups = $$value));
    	validate_store(triggerGroupingChangeEvent, 'triggerGroupingChangeEvent');
    	component_subscribe($$self, triggerGroupingChangeEvent, $$value => $$invalidate(4, $triggerGroupingChangeEvent = $$value));
    	validate_store(dbVersionStore, 'dbVersionStore');
    	component_subscribe($$self, dbVersionStore, $$value => $$invalidate(5, $dbVersionStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TagGroup', slots, []);
    	let isFirstGroupSongs = true;

    	// TODO: Add Configuration for the amount of groups.
    	function runSongGroup() {
    		for (let i = 0; i < $config.group.groupBy.length; i++) {
    			if ($selectedGroups[i] === undefined) {
    				set_store_value(selectedGroups, $selectedGroups[i] = [], $selectedGroups);
    			}
    		}

    		groupSongs($config.group.groupBy, $config.group.groupByValues);
    	}

    	function setNewGroupValue(index, groupValue) {
    		for (let i = index; i < $config.group.groupBy.length; i++) {
    			if (i === index) {
    				set_store_value(config, $config.group.groupByValues[i] = groupValue, $config);
    			} else {
    				set_store_value(config, $config.group.groupByValues[i] = 'undefined', $config);
    			}
    		}

    		groupSongs($config.group.groupBy, $config.group.groupByValues);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TagGroup> was created with unknown prop '${key}'`);
    	});

    	const click_handler = e => handleContextMenuEvent(e);
    	const click_handler_1 = index => setNewGroupValue(index, 'undefined');
    	const click_handler_2 = (index, groupValue) => setNewGroupValue(index, groupValue);

    	$$self.$capture_state = () => ({
    		handleContextMenuEvent,
    		groupSongs,
    		config,
    		dbVersionStore,
    		selectedGroups,
    		triggerGroupingChangeEvent,
    		isFirstGroupSongs,
    		runSongGroup,
    		setNewGroupValue,
    		$config,
    		$selectedGroups,
    		$triggerGroupingChangeEvent,
    		$dbVersionStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('isFirstGroupSongs' in $$props) $$invalidate(3, isFirstGroupSongs = $$props.isFirstGroupSongs);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$dbVersionStore*/ 32) {
    			{
    				if ($dbVersionStore) {
    					runSongGroup();
    				}
    			}
    		}

    		if ($$self.$$.dirty & /*$config, isFirstGroupSongs*/ 9) {
    			{
    				$config.group.groupBy;

    				if (isFirstGroupSongs === true) {
    					$$invalidate(3, isFirstGroupSongs = false);
    				} else {
    					runSongGroup();
    				}
    			}
    		}

    		if ($$self.$$.dirty & /*$triggerGroupingChangeEvent*/ 16) {
    			{
    				if ($triggerGroupingChangeEvent.length > 0) {
    					$triggerGroupingChangeEvent.forEach((grouping, index) => {
    						setNewGroupValue(index, grouping);
    					});

    					set_store_value(triggerGroupingChangeEvent, $triggerGroupingChangeEvent = [], $triggerGroupingChangeEvent);
    				}
    			}
    		}
    	};

    	return [
    		$config,
    		$selectedGroups,
    		setNewGroupValue,
    		isFirstGroupSongs,
    		$triggerGroupingChangeEvent,
    		$dbVersionStore,
    		click_handler,
    		click_handler_1,
    		click_handler_2
    	];
    }

    class TagGroup extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$J, create_fragment$J, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TagGroup",
    			options,
    			id: create_fragment$J.name
    		});
    	}
    }

    /* src/layouts/library/!LibraryLayout.svelte generated by Svelte v3.49.0 */
    const file$D = "src/layouts/library/!LibraryLayout.svelte";

    // (22:1) {:else}
    function create_else_block$4(ctx) {
    	let nosong;
    	let current;
    	nosong = new NoSong({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(nosong.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(nosong, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(nosong.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(nosong.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(nosong, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$4.name,
    		type: "else",
    		source: "(22:1) {:else}",
    		ctx
    	});

    	return block;
    }

    // (20:1) {#if $dbSongsStore.length > 0}
    function create_if_block$7(ctx) {
    	let artgrid;
    	let current;
    	artgrid = new ArtGrid({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(artgrid.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(artgrid, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(artgrid.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(artgrid.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(artgrid, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(20:1) {#if $dbSongsStore.length > 0}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$I(ctx) {
    	let library_layout;
    	let current_block_type_index;
    	let if_block;
    	let t0;
    	let taggroup;
    	let t1;
    	let songlist;
    	let t2;
    	let tagedit;
    	let t3;
    	let songlistbackground;
    	let current;
    	const if_block_creators = [create_if_block$7, create_else_block$4];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$dbSongsStore*/ ctx[0].length > 0) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	taggroup = new TagGroup({ $$inline: true });
    	songlist = new SongList({ $$inline: true });
    	tagedit = new TagEdit({ $$inline: true });
    	songlistbackground = new SongListBackground({ $$inline: true });

    	const block = {
    		c: function create() {
    			library_layout = element("library-layout");
    			if_block.c();
    			t0 = space();
    			create_component(taggroup.$$.fragment);
    			t1 = space();
    			create_component(songlist.$$.fragment);
    			t2 = space();
    			create_component(tagedit.$$.fragment);
    			t3 = space();
    			create_component(songlistbackground.$$.fragment);
    			set_custom_element_data(library_layout, "class", "layout svelte-ygcc4y");
    			add_location(library_layout, file$D, 18, 0, 748);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, library_layout, anchor);
    			if_blocks[current_block_type_index].m(library_layout, null);
    			append_dev(library_layout, t0);
    			mount_component(taggroup, library_layout, null);
    			append_dev(library_layout, t1);
    			mount_component(songlist, library_layout, null);
    			append_dev(library_layout, t2);
    			mount_component(tagedit, library_layout, null);
    			append_dev(library_layout, t3);
    			mount_component(songlistbackground, library_layout, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(library_layout, t0);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(taggroup.$$.fragment, local);
    			transition_in(songlist.$$.fragment, local);
    			transition_in(tagedit.$$.fragment, local);
    			transition_in(songlistbackground.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(taggroup.$$.fragment, local);
    			transition_out(songlist.$$.fragment, local);
    			transition_out(tagedit.$$.fragment, local);
    			transition_out(songlistbackground.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(library_layout);
    			if_blocks[current_block_type_index].d();
    			destroy_component(taggroup);
    			destroy_component(songlist);
    			destroy_component(tagedit);
    			destroy_component(songlistbackground);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$I.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$I($$self, $$props, $$invalidate) {
    	let $config;
    	let $dbSongsStore;
    	validate_store(config, 'config');
    	component_subscribe($$self, config, $$value => $$invalidate(1, $config = $$value));
    	validate_store(dbSongsStore, 'dbSongsStore');
    	component_subscribe($$self, dbSongsStore, $$value => $$invalidate(0, $dbSongsStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('LibraryLayout', slots, []);

    	onMount(() => {
    		groupSongs($config.group.groupBy, $config.group.groupByValues);
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<LibraryLayout> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		cssVariablesService,
    		groupSongs,
    		config,
    		dbSongsStore,
    		ArtGrid,
    		NoSong,
    		SongList,
    		SongListBackground,
    		TagEdit,
    		TagGroup,
    		$config,
    		$dbSongsStore
    	});

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$config*/ 2) {
    			if ($config.userOptions.fontSize !== undefined) {
    				cssVariablesService.set('font-size', `${$config.userOptions.fontSize}px`);
    			}
    		}
    	};

    	return [$dbSongsStore, $config];
    }

    class LibraryLayout extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$I, create_fragment$I, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LibraryLayout",
    			options,
    			id: create_fragment$I.name
    		});
    	}
    }

    /* src/components/OptionSection.svelte generated by Svelte v3.49.0 */

    const file$C = "src/components/OptionSection.svelte";

    function create_fragment$H(ctx) {
    	let section;
    	let section_title;
    	let t0;
    	let t1;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[2].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

    	const block = {
    		c: function create() {
    			section = element("section");
    			section_title = element("section-title");
    			t0 = text(/*title*/ ctx[0]);
    			t1 = space();
    			if (default_slot) default_slot.c();
    			set_custom_element_data(section_title, "class", "svelte-kkhm3p");
    			add_location(section_title, file$C, 4, 1, 74);
    			attr_dev(section, "id", /*title*/ ctx[0]);
    			attr_dev(section, "class", "svelte-kkhm3p");
    			add_location(section, file$C, 3, 0, 52);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, section_title);
    			append_dev(section_title, t0);
    			append_dev(section, t1);

    			if (default_slot) {
    				default_slot.m(section, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*title*/ 1) set_data_dev(t0, /*title*/ ctx[0]);

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[1],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[1])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[1], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*title*/ 1) {
    				attr_dev(section, "id", /*title*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$H.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$H($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('OptionSection', slots, ['default']);
    	let { title = '' } = $$props;
    	const writable_props = ['title'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<OptionSection> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('title' in $$props) $$invalidate(0, title = $$props.title);
    		if ('$$scope' in $$props) $$invalidate(1, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ title });

    	$$self.$inject_state = $$props => {
    		if ('title' in $$props) $$invalidate(0, title = $$props.title);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [title, $$scope, slots];
    }

    class OptionSection extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$H, create_fragment$H, safe_not_equal, { title: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "OptionSection",
    			options,
    			id: create_fragment$H.name
    		});
    	}

    	get title() {
    		throw new Error("<OptionSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<OptionSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/OptionSectionCompact.svelte generated by Svelte v3.49.0 */

    const file$B = "src/components/OptionSectionCompact.svelte";

    function create_fragment$G(ctx) {
    	let section;
    	let section_title;
    	let t0;
    	let t1;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[2].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

    	const block = {
    		c: function create() {
    			section = element("section");
    			section_title = element("section-title");
    			t0 = text(/*title*/ ctx[0]);
    			t1 = space();
    			if (default_slot) default_slot.c();
    			set_custom_element_data(section_title, "class", "svelte-180ebqu");
    			add_location(section_title, file$B, 4, 1, 74);
    			attr_dev(section, "id", /*title*/ ctx[0]);
    			attr_dev(section, "class", "svelte-180ebqu");
    			add_location(section, file$B, 3, 0, 52);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, section_title);
    			append_dev(section_title, t0);
    			append_dev(section, t1);

    			if (default_slot) {
    				default_slot.m(section, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*title*/ 1) set_data_dev(t0, /*title*/ ctx[0]);

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[1],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[1])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[1], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*title*/ 1) {
    				attr_dev(section, "id", /*title*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$G.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$G($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('OptionSectionCompact', slots, ['default']);
    	let { title = '' } = $$props;
    	const writable_props = ['title'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<OptionSectionCompact> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('title' in $$props) $$invalidate(0, title = $$props.title);
    		if ('$$scope' in $$props) $$invalidate(1, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ title });

    	$$self.$inject_state = $$props => {
    		if ('title' in $$props) $$invalidate(0, title = $$props.title);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [title, $$scope, slots];
    }

    class OptionSectionCompact extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$G, create_fragment$G, safe_not_equal, { title: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "OptionSectionCompact",
    			options,
    			id: create_fragment$G.name
    		});
    	}

    	get title() {
    		throw new Error("<OptionSectionCompact>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<OptionSectionCompact>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/InputShiftInfo.svelte generated by Svelte v3.49.0 */

    const file$A = "src/components/InputShiftInfo.svelte";

    function create_fragment$F(ctx) {
    	let input_steps_info;
    	let t0;
    	let shift_button;
    	let t2;

    	const block = {
    		c: function create() {
    			input_steps_info = element("input-steps-info");
    			t0 = text("Hold ");
    			shift_button = element("shift-button");
    			shift_button.textContent = "⇧ Shift";
    			t2 = text(" to be more accurate");
    			set_custom_element_data(shift_button, "class", "svelte-1vbbgvl");
    			add_location(shift_button, file$A, 0, 23, 23);
    			set_custom_element_data(input_steps_info, "class", "svelte-1vbbgvl");
    			add_location(input_steps_info, file$A, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input_steps_info, anchor);
    			append_dev(input_steps_info, t0);
    			append_dev(input_steps_info, shift_button);
    			append_dev(input_steps_info, t2);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input_steps_info);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$F.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$F($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('InputShiftInfo', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<InputShiftInfo> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class InputShiftInfo extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$F, create_fragment$F, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "InputShiftInfo",
    			options,
    			id: create_fragment$F.name
    		});
    	}
    }

    /* src/layouts/config/appearance/ColorContrastConfig.svelte generated by Svelte v3.49.0 */

    const file$z = "src/layouts/config/appearance/ColorContrastConfig.svelte";

    function create_fragment$E(ctx) {
    	let color_contrast_config;
    	let current_contrast_value;
    	let t0;
    	let t1;

    	let t2_value = (/*colorContrastRangeValue*/ ctx[0] === 4.5
    	? ' Suggested'
    	: '') + "";

    	let t2;
    	let t3;
    	let input;
    	let input_step_value;
    	let t4;
    	let inputshiftinfo;
    	let t5;
    	let current_contrast_sample;
    	let current;
    	let mounted;
    	let dispose;
    	inputshiftinfo = new InputShiftInfo({ $$inline: true });

    	const block = {
    		c: function create() {
    			color_contrast_config = element("color-contrast-config");
    			current_contrast_value = element("current-contrast-value");
    			t0 = text(/*colorContrastRangeValue*/ ctx[0]);
    			t1 = space();
    			t2 = text(t2_value);
    			t3 = space();
    			input = element("input");
    			t4 = space();
    			create_component(inputshiftinfo.$$.fragment);
    			t5 = space();
    			current_contrast_sample = element("current-contrast-sample");
    			current_contrast_sample.textContent = "Sample";
    			set_custom_element_data(current_contrast_value, "class", "svelte-111um2k");
    			add_location(current_contrast_value, file$z, 30, 1, 1079);
    			attr_dev(input, "type", "range");
    			attr_dev(input, "min", "0");
    			attr_dev(input, "max", "21");
    			attr_dev(input, "step", input_step_value = /*$keyPressed*/ ctx[1] === 'Shift' ? 0.1 : 0.5);
    			attr_dev(input, "class", "svelte-111um2k");
    			add_location(input, file$z, 34, 1, 1216);
    			set_custom_element_data(current_contrast_sample, "class", "svelte-111um2k");
    			add_location(current_contrast_sample, file$z, 45, 1, 1410);
    			add_location(color_contrast_config, file$z, 29, 0, 1054);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, color_contrast_config, anchor);
    			append_dev(color_contrast_config, current_contrast_value);
    			append_dev(current_contrast_value, t0);
    			append_dev(current_contrast_value, t1);
    			append_dev(current_contrast_value, t2);
    			append_dev(color_contrast_config, t3);
    			append_dev(color_contrast_config, input);
    			set_input_value(input, /*colorContrastRangeValue*/ ctx[0]);
    			append_dev(color_contrast_config, t4);
    			mount_component(inputshiftinfo, color_contrast_config, null);
    			append_dev(color_contrast_config, t5);
    			append_dev(color_contrast_config, current_contrast_sample);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "change", /*change_handler*/ ctx[4], false, false, false),
    					listen_dev(input, "change", /*input_change_input_handler*/ ctx[5]),
    					listen_dev(input, "input", /*input_change_input_handler*/ ctx[5])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*colorContrastRangeValue*/ 1) set_data_dev(t0, /*colorContrastRangeValue*/ ctx[0]);

    			if ((!current || dirty & /*colorContrastRangeValue*/ 1) && t2_value !== (t2_value = (/*colorContrastRangeValue*/ ctx[0] === 4.5
    			? ' Suggested'
    			: '') + "")) set_data_dev(t2, t2_value);

    			if (!current || dirty & /*$keyPressed*/ 2 && input_step_value !== (input_step_value = /*$keyPressed*/ ctx[1] === 'Shift' ? 0.1 : 0.5)) {
    				attr_dev(input, "step", input_step_value);
    			}

    			if (dirty & /*colorContrastRangeValue*/ 1) {
    				set_input_value(input, /*colorContrastRangeValue*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(inputshiftinfo.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(inputshiftinfo.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(color_contrast_config);
    			destroy_component(inputshiftinfo);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$E.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$E($$self, $$props, $$invalidate) {
    	let $config;
    	let $albumPlayingDirStore;
    	let $keyPressed;
    	validate_store(config, 'config');
    	component_subscribe($$self, config, $$value => $$invalidate(6, $config = $$value));
    	validate_store(albumPlayingDirStore, 'albumPlayingDirStore');
    	component_subscribe($$self, albumPlayingDirStore, $$value => $$invalidate(3, $albumPlayingDirStore = $$value));
    	validate_store(keyPressed, 'keyPressed');
    	component_subscribe($$self, keyPressed, $$value => $$invalidate(1, $keyPressed = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ColorContrastConfig', slots, []);
    	let colorContrastRangeValue = $config.userOptions.contrastRatio;

    	function updateColor() {
    		getAlbumColors($albumPlayingDirStore, colorContrastRangeValue).then(color => {
    			applyColorSchemeFn(color);
    		});
    	}

    	function saveContrastRatio() {
    		set_store_value(config, $config.userOptions.contrastRatio = colorContrastRangeValue, $config);

    		window.ipc.saveConfig({
    			userOptions: { contrastRatio: colorContrastRangeValue }
    		}).then(() => {
    			notifyService.success('Contrast Ratio saved!');
    		});
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ColorContrastConfig> was created with unknown prop '${key}'`);
    	});

    	const change_handler = () => saveContrastRatio();

    	function input_change_input_handler() {
    		colorContrastRangeValue = to_number(this.value);
    		$$invalidate(0, colorContrastRangeValue);
    	}

    	$$self.$capture_state = () => ({
    		InputShiftInfo,
    		applyColorSchemeFn,
    		getAlbumColors,
    		notifyService,
    		albumPlayingDirStore,
    		config,
    		keyPressed,
    		colorContrastRangeValue,
    		updateColor,
    		saveContrastRatio,
    		$config,
    		$albumPlayingDirStore,
    		$keyPressed
    	});

    	$$self.$inject_state = $$props => {
    		if ('colorContrastRangeValue' in $$props) $$invalidate(0, colorContrastRangeValue = $$props.colorContrastRangeValue);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$albumPlayingDirStore, colorContrastRangeValue*/ 9) {
    			{
    				updateColor();
    			}
    		}
    	};

    	return [
    		colorContrastRangeValue,
    		$keyPressed,
    		saveContrastRatio,
    		$albumPlayingDirStore,
    		change_handler,
    		input_change_input_handler
    	];
    }

    class ColorContrastConfig extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$E, create_fragment$E, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ColorContrastConfig",
    			options,
    			id: create_fragment$E.name
    		});
    	}
    }

    /* src/icons/MoonFillIcon.svelte generated by Svelte v3.49.0 */

    const file$y = "src/icons/MoonFillIcon.svelte";

    function create_fragment$D(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$y, 6, 2, 159);
    			attr_dev(path1, "d", "M11.38 2.019a7.5 7.5 0 1 0 10.6 10.6C21.662 17.854 17.316 22 12.001 22 6.477 22 2 17.523 2 12c0-5.315 4.146-9.661 9.38-9.981z");
    			add_location(path1, file$y, 6, 40, 197);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "style", /*style*/ ctx[0]);
    			add_location(svg, file$y, 5, 0, 89);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*style*/ 1) {
    				attr_dev(svg, "style", /*style*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$D.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$D($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MoonFillIcon', slots, []);
    	let { style = '' } = $$props;
    	const writable_props = ['style'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MoonFillIcon> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	$$self.$capture_state = () => ({ style });

    	$$self.$inject_state = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [style];
    }

    class MoonFillIcon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$D, create_fragment$D, safe_not_equal, { style: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MoonFillIcon",
    			options,
    			id: create_fragment$D.name
    		});
    	}

    	get style() {
    		throw new Error("<MoonFillIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<MoonFillIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/icons/MoonIcon.svelte generated by Svelte v3.49.0 */

    const file$x = "src/icons/MoonIcon.svelte";

    function create_fragment$C(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$x, 6, 2, 159);
    			attr_dev(path1, "d", "M10 7a7 7 0 0 0 12 4.9v.1c0 5.523-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2h.1A6.979 6.979 0 0 0 10 7zm-6 5a8 8 0 0 0 15.062 3.762A9 9 0 0 1 8.238 4.938 7.999 7.999 0 0 0 4 12z");
    			add_location(path1, file$x, 6, 40, 197);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "style", /*style*/ ctx[0]);
    			add_location(svg, file$x, 5, 0, 89);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*style*/ 1) {
    				attr_dev(svg, "style", /*style*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$C.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$C($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MoonIcon', slots, []);
    	let { style = '' } = $$props;
    	const writable_props = ['style'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MoonIcon> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	$$self.$capture_state = () => ({ style });

    	$$self.$inject_state = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [style];
    }

    class MoonIcon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$C, create_fragment$C, safe_not_equal, { style: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MoonIcon",
    			options,
    			id: create_fragment$C.name
    		});
    	}

    	get style() {
    		throw new Error("<MoonIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<MoonIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/icons/SunFillIcon.svelte generated by Svelte v3.49.0 */

    const file$w = "src/icons/SunFillIcon.svelte";

    function create_fragment$B(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$w, 5, 69, 158);
    			attr_dev(path1, "d", "M12 18a6 6 0 1 1 0-12 6 6 0 0 1 0 12zM11 1h2v3h-2V1zm0 19h2v3h-2v-3zM3.515 4.929l1.414-1.414L7.05 5.636 5.636 7.05 3.515 4.93zM16.95 18.364l1.414-1.414 2.121 2.121-1.414 1.414-2.121-2.121zm2.121-14.85l1.414 1.415-2.121 2.121-1.414-1.414 2.121-2.121zM5.636 16.95l1.414 1.414-2.121 2.121-1.414-1.414 2.121-2.121zM23 11v2h-3v-2h3zM4 11v2H1v-2h3z");
    			add_location(path1, file$w, 5, 106, 195);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "style", /*style*/ ctx[0]);
    			add_location(svg, file$w, 5, 0, 89);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*style*/ 1) {
    				attr_dev(svg, "style", /*style*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$B.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$B($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SunFillIcon', slots, []);
    	let { style = '' } = $$props;
    	const writable_props = ['style'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SunFillIcon> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	$$self.$capture_state = () => ({ style });

    	$$self.$inject_state = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [style];
    }

    class SunFillIcon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$B, create_fragment$B, safe_not_equal, { style: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SunFillIcon",
    			options,
    			id: create_fragment$B.name
    		});
    	}

    	get style() {
    		throw new Error("<SunFillIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<SunFillIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/icons/SunIcon.svelte generated by Svelte v3.49.0 */

    const file$v = "src/icons/SunIcon.svelte";

    function create_fragment$A(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$v, 6, 2, 159);
    			attr_dev(path1, "d", "M12 18a6 6 0 1 1 0-12 6 6 0 0 1 0 12zm0-2a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM11 1h2v3h-2V1zm0 19h2v3h-2v-3zM3.515 4.929l1.414-1.414L7.05 5.636 5.636 7.05 3.515 4.93zM16.95 18.364l1.414-1.414 2.121 2.121-1.414 1.414-2.121-2.121zm2.121-14.85l1.414 1.415-2.121 2.121-1.414-1.414 2.121-2.121zM5.636 16.95l1.414 1.414-2.121 2.121-1.414-1.414 2.121-2.121zM23 11v2h-3v-2h3zM4 11v2H1v-2h3z");
    			add_location(path1, file$v, 6, 40, 197);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "style", /*style*/ ctx[0]);
    			add_location(svg, file$v, 5, 0, 89);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*style*/ 1) {
    				attr_dev(svg, "style", /*style*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$A.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$A($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SunIcon', slots, []);
    	let { style = '' } = $$props;
    	const writable_props = ['style'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SunIcon> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	$$self.$capture_state = () => ({ style });

    	$$self.$inject_state = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [style];
    }

    class SunIcon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$A, create_fragment$A, safe_not_equal, { style: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SunIcon",
    			options,
    			id: create_fragment$A.name
    		});
    	}

    	get style() {
    		throw new Error("<SunIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<SunIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/icons/SystemFillIcon.svelte generated by Svelte v3.49.0 */

    const file$u = "src/icons/SystemFillIcon.svelte";

    function create_fragment$z(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$u, 6, 2, 159);
    			attr_dev(path1, "d", "M13 18v2h4v2H7v-2h4v-2H2.992A.998.998 0 0 1 2 16.993V4.007C2 3.451 2.455 3 2.992 3h18.016c.548 0 .992.449.992 1.007v12.986c0 .556-.455 1.007-.992 1.007H13z");
    			add_location(path1, file$u, 6, 40, 197);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "style", /*style*/ ctx[0]);
    			add_location(svg, file$u, 5, 0, 89);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*style*/ 1) {
    				attr_dev(svg, "style", /*style*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$z($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SystemFillIcon', slots, []);
    	let { style = '' } = $$props;
    	const writable_props = ['style'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SystemFillIcon> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	$$self.$capture_state = () => ({ style });

    	$$self.$inject_state = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [style];
    }

    class SystemFillIcon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$z, create_fragment$z, safe_not_equal, { style: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SystemFillIcon",
    			options,
    			id: create_fragment$z.name
    		});
    	}

    	get style() {
    		throw new Error("<SystemFillIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<SystemFillIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/icons/SystemIcon.svelte generated by Svelte v3.49.0 */

    const file$t = "src/icons/SystemIcon.svelte";

    function create_fragment$y(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$t, 6, 2, 159);
    			attr_dev(path1, "d", "M4 16h16V5H4v11zm9 2v2h4v2H7v-2h4v-2H2.992A.998.998 0 0 1 2 16.993V4.007C2 3.451 2.455 3 2.992 3h18.016c.548 0 .992.449.992 1.007v12.986c0 .556-.455 1.007-.992 1.007H13z");
    			add_location(path1, file$t, 6, 40, 197);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "style", /*style*/ ctx[0]);
    			add_location(svg, file$t, 5, 0, 89);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*style*/ 1) {
    				attr_dev(svg, "style", /*style*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$y($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SystemIcon', slots, []);
    	let { style = '' } = $$props;
    	const writable_props = ['style'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SystemIcon> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	$$self.$capture_state = () => ({ style });

    	$$self.$inject_state = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [style];
    }

    class SystemIcon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$y, create_fragment$y, safe_not_equal, { style: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SystemIcon",
    			options,
    			id: create_fragment$y.name
    		});
    	}

    	get style() {
    		throw new Error("<SystemIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<SystemIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function updateConfigFn (newConfig) {
        let mergedConfig;
        config.subscribe(value => (mergedConfig = cjs(value, newConfig)))();
        window.ipc.saveConfig(newConfig);
        config.set(mergedConfig);
    }

    /* src/layouts/config/appearance/DayNightThemeConfig.svelte generated by Svelte v3.49.0 */
    const file$s = "src/layouts/config/appearance/DayNightThemeConfig.svelte";

    function create_fragment$x(ctx) {
    	let day_night_theme_config;
    	let theme_section0;
    	let section_icon0;
    	let systemfillicon;
    	let t0;
    	let systemicon;
    	let t1;
    	let theme_name0;
    	let theme_section0_data_selected_value;
    	let t3;
    	let theme_section1;
    	let section_icon1;
    	let sunfillicon;
    	let t4;
    	let sunicon;
    	let t5;
    	let theme_name1;
    	let theme_section1_data_selected_value;
    	let t7;
    	let theme_section2;
    	let section_icon2;
    	let moonfillicon;
    	let t8;
    	let moonicon;
    	let t9;
    	let theme_name2;
    	let theme_section2_data_selected_value;
    	let current;
    	let mounted;
    	let dispose;

    	systemfillicon = new SystemFillIcon({
    			props: {
    				style: "opacity:" + (/*$config*/ ctx[0].userOptions.theme === 'SystemBased'
    				? '1'
    				: '0') + ";" + /*iconsStyle*/ ctx[1]
    			},
    			$$inline: true
    		});

    	systemicon = new SystemIcon({
    			props: {
    				style: "opacity:" + (/*$config*/ ctx[0].userOptions.theme !== 'SystemBased'
    				? '1'
    				: '0') + ";" + /*iconsStyle*/ ctx[1]
    			},
    			$$inline: true
    		});

    	sunfillicon = new SunFillIcon({
    			props: {
    				style: "opacity:" + (/*$config*/ ctx[0].userOptions.theme === 'Day'
    				? '1'
    				: '0') + ";" + /*iconsStyle*/ ctx[1]
    			},
    			$$inline: true
    		});

    	sunicon = new SunIcon({
    			props: {
    				style: "opacity:" + (/*$config*/ ctx[0].userOptions.theme !== 'Day'
    				? '1'
    				: '0') + ";" + /*iconsStyle*/ ctx[1]
    			},
    			$$inline: true
    		});

    	moonfillicon = new MoonFillIcon({
    			props: {
    				style: "opacity:" + (/*$config*/ ctx[0].userOptions.theme === 'Night'
    				? '1'
    				: '0') + ";" + /*iconsStyle*/ ctx[1]
    			},
    			$$inline: true
    		});

    	moonicon = new MoonIcon({
    			props: {
    				style: "opacity:" + (/*$config*/ ctx[0].userOptions.theme !== 'Night'
    				? '1'
    				: '0') + ";" + /*iconsStyle*/ ctx[1]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			day_night_theme_config = element("day-night-theme-config");
    			theme_section0 = element("theme-section");
    			section_icon0 = element("section-icon");
    			create_component(systemfillicon.$$.fragment);
    			t0 = space();
    			create_component(systemicon.$$.fragment);
    			t1 = space();
    			theme_name0 = element("theme-name");
    			theme_name0.textContent = "System Based";
    			t3 = space();
    			theme_section1 = element("theme-section");
    			section_icon1 = element("section-icon");
    			create_component(sunfillicon.$$.fragment);
    			t4 = space();
    			create_component(sunicon.$$.fragment);
    			t5 = space();
    			theme_name1 = element("theme-name");
    			theme_name1.textContent = "Day";
    			t7 = space();
    			theme_section2 = element("theme-section");
    			section_icon2 = element("section-icon");
    			create_component(moonfillicon.$$.fragment);
    			t8 = space();
    			create_component(moonicon.$$.fragment);
    			t9 = space();
    			theme_name2 = element("theme-name");
    			theme_name2.textContent = "Night";
    			set_custom_element_data(section_icon0, "class", "svelte-bt7drl");
    			add_location(section_icon0, file$s, 25, 2, 973);
    			set_custom_element_data(theme_name0, "class", "svelte-bt7drl");
    			add_location(theme_name0, file$s, 30, 2, 1223);
    			set_custom_element_data(theme_section0, "data-theme", "SystemBased");

    			set_custom_element_data(theme_section0, "data-selected", theme_section0_data_selected_value = /*$config*/ ctx[0].userOptions.theme === 'SystemBased'
    			? 'true'
    			: 'false');

    			set_custom_element_data(theme_section0, "class", "svelte-bt7drl");
    			add_location(theme_section0, file$s, 20, 1, 793);
    			set_custom_element_data(section_icon1, "class", "svelte-bt7drl");
    			add_location(section_icon1, file$s, 37, 2, 1436);
    			set_custom_element_data(theme_name1, "class", "svelte-bt7drl");
    			add_location(theme_name1, file$s, 42, 2, 1664);
    			set_custom_element_data(theme_section1, "data-theme", "Day");

    			set_custom_element_data(theme_section1, "data-selected", theme_section1_data_selected_value = /*$config*/ ctx[0].userOptions.theme === 'Day'
    			? 'true'
    			: 'false');

    			set_custom_element_data(theme_section1, "class", "svelte-bt7drl");
    			add_location(theme_section1, file$s, 32, 1, 1280);
    			set_custom_element_data(section_icon2, "class", "svelte-bt7drl");
    			add_location(section_icon2, file$s, 49, 2, 1874);
    			set_custom_element_data(theme_name2, "class", "svelte-bt7drl");
    			add_location(theme_name2, file$s, 55, 2, 2109);
    			set_custom_element_data(theme_section2, "data-theme", "Night");

    			set_custom_element_data(theme_section2, "data-selected", theme_section2_data_selected_value = /*$config*/ ctx[0].userOptions.theme === 'Night'
    			? 'true'
    			: 'false');

    			set_custom_element_data(theme_section2, "class", "svelte-bt7drl");
    			add_location(theme_section2, file$s, 44, 1, 1712);
    			set_custom_element_data(day_night_theme_config, "class", "svelte-bt7drl");
    			add_location(day_night_theme_config, file$s, 19, 0, 767);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, day_night_theme_config, anchor);
    			append_dev(day_night_theme_config, theme_section0);
    			append_dev(theme_section0, section_icon0);
    			mount_component(systemfillicon, section_icon0, null);
    			append_dev(section_icon0, t0);
    			mount_component(systemicon, section_icon0, null);
    			append_dev(theme_section0, t1);
    			append_dev(theme_section0, theme_name0);
    			append_dev(day_night_theme_config, t3);
    			append_dev(day_night_theme_config, theme_section1);
    			append_dev(theme_section1, section_icon1);
    			mount_component(sunfillicon, section_icon1, null);
    			append_dev(section_icon1, t4);
    			mount_component(sunicon, section_icon1, null);
    			append_dev(theme_section1, t5);
    			append_dev(theme_section1, theme_name1);
    			append_dev(day_night_theme_config, t7);
    			append_dev(day_night_theme_config, theme_section2);
    			append_dev(theme_section2, section_icon2);
    			mount_component(moonfillicon, section_icon2, null);
    			append_dev(section_icon2, t8);
    			mount_component(moonicon, section_icon2, null);
    			append_dev(theme_section2, t9);
    			append_dev(theme_section2, theme_name2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(theme_section0, "click", /*click_handler*/ ctx[3], false, false, false),
    					listen_dev(theme_section1, "click", /*click_handler_1*/ ctx[4], false, false, false),
    					listen_dev(theme_section2, "click", /*click_handler_2*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const systemfillicon_changes = {};

    			if (dirty & /*$config*/ 1) systemfillicon_changes.style = "opacity:" + (/*$config*/ ctx[0].userOptions.theme === 'SystemBased'
    			? '1'
    			: '0') + ";" + /*iconsStyle*/ ctx[1];

    			systemfillicon.$set(systemfillicon_changes);
    			const systemicon_changes = {};

    			if (dirty & /*$config*/ 1) systemicon_changes.style = "opacity:" + (/*$config*/ ctx[0].userOptions.theme !== 'SystemBased'
    			? '1'
    			: '0') + ";" + /*iconsStyle*/ ctx[1];

    			systemicon.$set(systemicon_changes);

    			if (!current || dirty & /*$config*/ 1 && theme_section0_data_selected_value !== (theme_section0_data_selected_value = /*$config*/ ctx[0].userOptions.theme === 'SystemBased'
    			? 'true'
    			: 'false')) {
    				set_custom_element_data(theme_section0, "data-selected", theme_section0_data_selected_value);
    			}

    			const sunfillicon_changes = {};

    			if (dirty & /*$config*/ 1) sunfillicon_changes.style = "opacity:" + (/*$config*/ ctx[0].userOptions.theme === 'Day'
    			? '1'
    			: '0') + ";" + /*iconsStyle*/ ctx[1];

    			sunfillicon.$set(sunfillicon_changes);
    			const sunicon_changes = {};

    			if (dirty & /*$config*/ 1) sunicon_changes.style = "opacity:" + (/*$config*/ ctx[0].userOptions.theme !== 'Day'
    			? '1'
    			: '0') + ";" + /*iconsStyle*/ ctx[1];

    			sunicon.$set(sunicon_changes);

    			if (!current || dirty & /*$config*/ 1 && theme_section1_data_selected_value !== (theme_section1_data_selected_value = /*$config*/ ctx[0].userOptions.theme === 'Day'
    			? 'true'
    			: 'false')) {
    				set_custom_element_data(theme_section1, "data-selected", theme_section1_data_selected_value);
    			}

    			const moonfillicon_changes = {};

    			if (dirty & /*$config*/ 1) moonfillicon_changes.style = "opacity:" + (/*$config*/ ctx[0].userOptions.theme === 'Night'
    			? '1'
    			: '0') + ";" + /*iconsStyle*/ ctx[1];

    			moonfillicon.$set(moonfillicon_changes);
    			const moonicon_changes = {};

    			if (dirty & /*$config*/ 1) moonicon_changes.style = "opacity:" + (/*$config*/ ctx[0].userOptions.theme !== 'Night'
    			? '1'
    			: '0') + ";" + /*iconsStyle*/ ctx[1];

    			moonicon.$set(moonicon_changes);

    			if (!current || dirty & /*$config*/ 1 && theme_section2_data_selected_value !== (theme_section2_data_selected_value = /*$config*/ ctx[0].userOptions.theme === 'Night'
    			? 'true'
    			: 'false')) {
    				set_custom_element_data(theme_section2, "data-selected", theme_section2_data_selected_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(systemfillicon.$$.fragment, local);
    			transition_in(systemicon.$$.fragment, local);
    			transition_in(sunfillicon.$$.fragment, local);
    			transition_in(sunicon.$$.fragment, local);
    			transition_in(moonfillicon.$$.fragment, local);
    			transition_in(moonicon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(systemfillicon.$$.fragment, local);
    			transition_out(systemicon.$$.fragment, local);
    			transition_out(sunfillicon.$$.fragment, local);
    			transition_out(sunicon.$$.fragment, local);
    			transition_out(moonfillicon.$$.fragment, local);
    			transition_out(moonicon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(day_night_theme_config);
    			destroy_component(systemfillicon);
    			destroy_component(systemicon);
    			destroy_component(sunfillicon);
    			destroy_component(sunicon);
    			destroy_component(moonfillicon);
    			destroy_component(moonicon);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$x($$self, $$props, $$invalidate) {
    	let $config;
    	validate_store(config, 'config');
    	component_subscribe($$self, config, $$value => $$invalidate(0, $config = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('DayNightThemeConfig', slots, []);
    	let iconsStyle = 'height: 4rem;margin-bottom: 1rem;fill: var(--color-fg-1);transition: all 300ms ease-in-out;';

    	function saveThemeToConfig(themeName) {
    		updateConfigFn({ userOptions: { theme: themeName } });
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<DayNightThemeConfig> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => saveThemeToConfig('SystemBased');
    	const click_handler_1 = () => saveThemeToConfig('Day');
    	const click_handler_2 = () => saveThemeToConfig('Night');

    	$$self.$capture_state = () => ({
    		MoonFillIcon,
    		MoonIcon,
    		SunFillIcon,
    		SunIcon,
    		SystemFillIcon,
    		SystemIcon,
    		config,
    		updateConfigFn,
    		iconsStyle,
    		saveThemeToConfig,
    		$config
    	});

    	$$self.$inject_state = $$props => {
    		if ('iconsStyle' in $$props) $$invalidate(1, iconsStyle = $$props.iconsStyle);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		$config,
    		iconsStyle,
    		saveThemeToConfig,
    		click_handler,
    		click_handler_1,
    		click_handler_2
    	];
    }

    class DayNightThemeConfig extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$x, create_fragment$x, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DayNightThemeConfig",
    			options,
    			id: create_fragment$x.name
    		});
    	}
    }

    let equalizerService = writable(undefined);
    let confirmService = writable(undefined);
    let promptService = writable(undefined);
    let rangeInputService = writable(undefined);
    let storageService = writable(undefined);

    /* src/layouts/config/appearance/FontSizeConfig.svelte generated by Svelte v3.49.0 */
    const file$r = "src/layouts/config/appearance/FontSizeConfig.svelte";

    function create_fragment$w(ctx) {
    	let font_size_config;
    	let config_edit_button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			font_size_config = element("font-size-config");
    			config_edit_button = element("config-edit-button");
    			config_edit_button.textContent = "···";
    			add_location(config_edit_button, file$r, 37, 50, 1153);
    			add_location(font_size_config, file$r, 37, 0, 1103);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, font_size_config, anchor);
    			append_dev(font_size_config, config_edit_button);

    			if (!mounted) {
    				dispose = listen_dev(font_size_config, "click", /*click_handler*/ ctx[1], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(font_size_config);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$w($$self, $$props, $$invalidate) {
    	let $config;
    	let $layoutToShow;
    	let $rangeInputService;
    	validate_store(config, 'config');
    	component_subscribe($$self, config, $$value => $$invalidate(2, $config = $$value));
    	validate_store(layoutToShow, 'layoutToShow');
    	component_subscribe($$self, layoutToShow, $$value => $$invalidate(3, $layoutToShow = $$value));
    	validate_store(rangeInputService, 'rangeInputService');
    	component_subscribe($$self, rangeInputService, $$value => $$invalidate(4, $rangeInputService = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('FontSizeConfig', slots, []);

    	function setFontSize() {
    		set_store_value(layoutToShow, $layoutToShow = 'Library', $layoutToShow);

    		$rangeInputService.showRangeInput({
    			title: 'Font Size',
    			min: 12,
    			max: 18,
    			step: 1,
    			minStep: 0.25,
    			value: Number($config.userOptions.fontSize),
    			confirmButtonText: 'Confirm',
    			cancelButtonText: 'Close',
    			onChange: value => {
    				set_store_value(config, $config.userOptions.fontSize = value, $config);
    			},
    			onConfirm: newFontSize => {
    				saveFontSize(newFontSize);
    			},
    			onCancel: previousFontSize => {
    				saveFontSize(previousFontSize);
    				set_store_value(layoutToShow, $layoutToShow = 'Config', $layoutToShow);
    			}
    		});
    	}

    	function saveFontSize(newFontSize) {
    		set_store_value(config, $config.userOptions.fontSize = newFontSize, $config);
    		window.ipc.saveConfig({ userOptions: { fontSize: newFontSize } });
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<FontSizeConfig> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => setFontSize();

    	$$self.$capture_state = () => ({
    		config,
    		layoutToShow,
    		rangeInputService,
    		setFontSize,
    		saveFontSize,
    		$config,
    		$layoutToShow,
    		$rangeInputService
    	});

    	return [setFontSize, click_handler];
    }

    class FontSizeConfig extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$w, create_fragment$w, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FontSizeConfig",
    			options,
    			id: create_fragment$w.name
    		});
    	}
    }

    function isElementInViewportFn (el) {
        const rect = el.getBoundingClientRect();
        return (rect.top >= 0 &&
            rect.left >= 0 &&
            rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
            rect.right <= (window.innerWidth || document.documentElement.clientWidth));
    }

    /* src/layouts/config/appearance/GridArtSize.svelte generated by Svelte v3.49.0 */
    const file$q = "src/layouts/config/appearance/GridArtSize.svelte";

    function create_fragment$v(ctx) {
    	let grid_art_size_config;
    	let config_edit_button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			grid_art_size_config = element("grid-art-size-config");
    			config_edit_button = element("config-edit-button");
    			config_edit_button.textContent = "···";
    			add_location(config_edit_button, file$q, 53, 1, 1775);
    			add_location(grid_art_size_config, file$q, 52, 0, 1720);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, grid_art_size_config, anchor);
    			append_dev(grid_art_size_config, config_edit_button);

    			if (!mounted) {
    				dispose = listen_dev(grid_art_size_config, "click", /*click_handler*/ ctx[1], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(grid_art_size_config);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$v($$self, $$props, $$invalidate) {
    	let $config;
    	let $layoutToShow;
    	let $rangeInputService;
    	validate_store(config, 'config');
    	component_subscribe($$self, config, $$value => $$invalidate(2, $config = $$value));
    	validate_store(layoutToShow, 'layoutToShow');
    	component_subscribe($$self, layoutToShow, $$value => $$invalidate(3, $layoutToShow = $$value));
    	validate_store(rangeInputService, 'rangeInputService');
    	component_subscribe($$self, rangeInputService, $$value => $$invalidate(4, $rangeInputService = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('GridArtSize', slots, []);

    	function setGridSize() {
    		set_store_value(layoutToShow, $layoutToShow = 'Library', $layoutToShow);

    		$rangeInputService.showRangeInput({
    			title: 'Art Size',
    			min: 64,
    			max: 256,
    			step: 8,
    			minStep: 1,
    			value: Number($config.userOptions.artSize),
    			confirmButtonText: 'Confirm',
    			cancelButtonText: 'Close',
    			onChange: value => {
    				set_store_value(config, $config.userOptions.artSize = value, $config);
    			},
    			onConfirm: newArtSize => {
    				saveArtSize(newArtSize);
    			},
    			onCancel: previousArtSize => {
    				saveArtSize(previousArtSize);
    				set_store_value(layoutToShow, $layoutToShow = 'Config', $layoutToShow);
    			}
    		});
    	}

    	function saveArtSize(newArtSize) {
    		set_store_value(config, $config.userOptions.artSize = newArtSize, $config);

    		window.ipc.saveConfig({ userOptions: { artSize: newArtSize } }).then(() => {
    			document.querySelectorAll('art-grid-svlt > album > art-svlt').forEach(artElement => {
    				artElement.dataset.artsize = String(newArtSize);

    				if (isElementInViewportFn(artElement)) {
    					window.ipc.compressAlbumArt(artElement.dataset.rootdir, newArtSize, false);
    				} else {
    					setTimeout(
    						() => {
    							window.ipc.compressAlbumArt(artElement.dataset.rootdir, newArtSize, false);
    						},
    						1000
    					);
    				}
    			});
    		});
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<GridArtSize> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => setGridSize();

    	$$self.$capture_state = () => ({
    		isElementInViewportFn,
    		config,
    		layoutToShow,
    		rangeInputService,
    		setGridSize,
    		saveArtSize,
    		$config,
    		$layoutToShow,
    		$rangeInputService
    	});

    	return [setGridSize, click_handler];
    }

    class GridArtSize extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$v, create_fragment$v, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GridArtSize",
    			options,
    			id: create_fragment$v.name
    		});
    	}
    }

    /* src/layouts/config/appearance/RebuildArtCacheConfig.svelte generated by Svelte v3.49.0 */
    const file$p = "src/layouts/config/appearance/RebuildArtCacheConfig.svelte";

    function create_fragment$u(ctx) {
    	let font_size_config;
    	let config_edit_button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			font_size_config = element("font-size-config");
    			config_edit_button = element("config-edit-button");
    			config_edit_button.textContent = "Rebuild";
    			set_custom_element_data(config_edit_button, "class", "svelte-ruxmkx");
    			add_location(config_edit_button, file$p, 10, 1, 308);
    			add_location(font_size_config, file$p, 9, 0, 253);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, font_size_config, anchor);
    			append_dev(font_size_config, config_edit_button);

    			if (!mounted) {
    				dispose = listen_dev(font_size_config, "click", /*click_handler*/ ctx[1], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(font_size_config);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$u($$self, $$props, $$invalidate) {
    	let $layoutToShow;
    	let $reloadArts;
    	validate_store(layoutToShow, 'layoutToShow');
    	component_subscribe($$self, layoutToShow, $$value => $$invalidate(2, $layoutToShow = $$value));
    	validate_store(reloadArts, 'reloadArts');
    	component_subscribe($$self, reloadArts, $$value => $$invalidate(3, $reloadArts = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('RebuildArtCacheConfig', slots, []);

    	function rebuildArtCache() {
    		set_store_value(reloadArts, $reloadArts = Math.random(), $reloadArts);

    		window.ipc.rebuildArtCache().then(() => {
    			set_store_value(layoutToShow, $layoutToShow = 'Library', $layoutToShow);
    		});
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<RebuildArtCacheConfig> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => rebuildArtCache();

    	$$self.$capture_state = () => ({
    		layoutToShow,
    		reloadArts,
    		rebuildArtCache,
    		$layoutToShow,
    		$reloadArts
    	});

    	return [rebuildArtCache, click_handler];
    }

    class RebuildArtCacheConfig extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$u, create_fragment$u, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "RebuildArtCacheConfig",
    			options,
    			id: create_fragment$u.name
    		});
    	}
    }

    /* src/layouts/config/appearance/!AppearanceConfig.svelte generated by Svelte v3.49.0 */
    const file$o = "src/layouts/config/appearance/!AppearanceConfig.svelte";

    // (12:1) <OptionSection title="Day|Night Mode">
    function create_default_slot_4(ctx) {
    	let daynightthemeconfig;
    	let current;
    	daynightthemeconfig = new DayNightThemeConfig({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(daynightthemeconfig.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(daynightthemeconfig, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(daynightthemeconfig.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(daynightthemeconfig.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(daynightthemeconfig, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4.name,
    		type: "slot",
    		source: "(12:1) <OptionSection title=\\\"Day|Night Mode\\\">",
    		ctx
    	});

    	return block;
    }

    // (16:1) <OptionSection title="Color Contrast Ratio">
    function create_default_slot_3(ctx) {
    	let colorcontrastconfig;
    	let current;
    	colorcontrastconfig = new ColorContrastConfig({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(colorcontrastconfig.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(colorcontrastconfig, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(colorcontrastconfig.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(colorcontrastconfig.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(colorcontrastconfig, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3.name,
    		type: "slot",
    		source: "(16:1) <OptionSection title=\\\"Color Contrast Ratio\\\">",
    		ctx
    	});

    	return block;
    }

    // (22:1) <OptionSectionCompact title="Font Size: {$config.userOptions.fontSize}">
    function create_default_slot_2(ctx) {
    	let fontsizeconfig;
    	let current;
    	fontsizeconfig = new FontSizeConfig({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(fontsizeconfig.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fontsizeconfig, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fontsizeconfig.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fontsizeconfig.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fontsizeconfig, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2.name,
    		type: "slot",
    		source: "(22:1) <OptionSectionCompact title=\\\"Font Size: {$config.userOptions.fontSize}\\\">",
    		ctx
    	});

    	return block;
    }

    // (26:1) <OptionSectionCompact title="Grid Art Size: {$config.userOptions.artSize}">
    function create_default_slot_1$1(ctx) {
    	let gridartsize;
    	let current;
    	gridartsize = new GridArtSize({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(gridartsize.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(gridartsize, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(gridartsize.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(gridartsize.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(gridartsize, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$1.name,
    		type: "slot",
    		source: "(26:1) <OptionSectionCompact title=\\\"Grid Art Size: {$config.userOptions.artSize}\\\">",
    		ctx
    	});

    	return block;
    }

    // (30:1) <OptionSectionCompact title="Rebuild Art Cache">
    function create_default_slot$2(ctx) {
    	let rebuildartcacheconfig;
    	let current;
    	rebuildartcacheconfig = new RebuildArtCacheConfig({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(rebuildartcacheconfig.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(rebuildartcacheconfig, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(rebuildartcacheconfig.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(rebuildartcacheconfig.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(rebuildartcacheconfig, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$2.name,
    		type: "slot",
    		source: "(30:1) <OptionSectionCompact title=\\\"Rebuild Art Cache\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$t(ctx) {
    	let config_section;
    	let optionsection0;
    	let t0;
    	let optionsection1;
    	let t1;
    	let optionsection2;
    	let t2;
    	let optionsectioncompact0;
    	let t3;
    	let optionsectioncompact1;
    	let t4;
    	let optionsectioncompact2;
    	let current;

    	optionsection0 = new OptionSection({
    			props: {
    				title: "Day|Night Mode",
    				$$slots: { default: [create_default_slot_4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	optionsection1 = new OptionSection({
    			props: {
    				title: "Color Contrast Ratio",
    				$$slots: { default: [create_default_slot_3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	optionsection2 = new OptionSection({
    			props: { title: "Other Options" },
    			$$inline: true
    		});

    	optionsectioncompact0 = new OptionSectionCompact({
    			props: {
    				title: "Font Size: " + /*$config*/ ctx[0].userOptions.fontSize,
    				$$slots: { default: [create_default_slot_2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	optionsectioncompact1 = new OptionSectionCompact({
    			props: {
    				title: "Grid Art Size: " + /*$config*/ ctx[0].userOptions.artSize,
    				$$slots: { default: [create_default_slot_1$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	optionsectioncompact2 = new OptionSectionCompact({
    			props: {
    				title: "Rebuild Art Cache",
    				$$slots: { default: [create_default_slot$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			config_section = element("config-section");
    			create_component(optionsection0.$$.fragment);
    			t0 = space();
    			create_component(optionsection1.$$.fragment);
    			t1 = space();
    			create_component(optionsection2.$$.fragment);
    			t2 = space();
    			create_component(optionsectioncompact0.$$.fragment);
    			t3 = space();
    			create_component(optionsectioncompact1.$$.fragment);
    			t4 = space();
    			create_component(optionsectioncompact2.$$.fragment);
    			add_location(config_section, file$o, 10, 0, 534);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, config_section, anchor);
    			mount_component(optionsection0, config_section, null);
    			append_dev(config_section, t0);
    			mount_component(optionsection1, config_section, null);
    			append_dev(config_section, t1);
    			mount_component(optionsection2, config_section, null);
    			append_dev(config_section, t2);
    			mount_component(optionsectioncompact0, config_section, null);
    			append_dev(config_section, t3);
    			mount_component(optionsectioncompact1, config_section, null);
    			append_dev(config_section, t4);
    			mount_component(optionsectioncompact2, config_section, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const optionsection0_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				optionsection0_changes.$$scope = { dirty, ctx };
    			}

    			optionsection0.$set(optionsection0_changes);
    			const optionsection1_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				optionsection1_changes.$$scope = { dirty, ctx };
    			}

    			optionsection1.$set(optionsection1_changes);
    			const optionsectioncompact0_changes = {};
    			if (dirty & /*$config*/ 1) optionsectioncompact0_changes.title = "Font Size: " + /*$config*/ ctx[0].userOptions.fontSize;

    			if (dirty & /*$$scope*/ 2) {
    				optionsectioncompact0_changes.$$scope = { dirty, ctx };
    			}

    			optionsectioncompact0.$set(optionsectioncompact0_changes);
    			const optionsectioncompact1_changes = {};
    			if (dirty & /*$config*/ 1) optionsectioncompact1_changes.title = "Grid Art Size: " + /*$config*/ ctx[0].userOptions.artSize;

    			if (dirty & /*$$scope*/ 2) {
    				optionsectioncompact1_changes.$$scope = { dirty, ctx };
    			}

    			optionsectioncompact1.$set(optionsectioncompact1_changes);
    			const optionsectioncompact2_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				optionsectioncompact2_changes.$$scope = { dirty, ctx };
    			}

    			optionsectioncompact2.$set(optionsectioncompact2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(optionsection0.$$.fragment, local);
    			transition_in(optionsection1.$$.fragment, local);
    			transition_in(optionsection2.$$.fragment, local);
    			transition_in(optionsectioncompact0.$$.fragment, local);
    			transition_in(optionsectioncompact1.$$.fragment, local);
    			transition_in(optionsectioncompact2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(optionsection0.$$.fragment, local);
    			transition_out(optionsection1.$$.fragment, local);
    			transition_out(optionsection2.$$.fragment, local);
    			transition_out(optionsectioncompact0.$$.fragment, local);
    			transition_out(optionsectioncompact1.$$.fragment, local);
    			transition_out(optionsectioncompact2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(config_section);
    			destroy_component(optionsection0);
    			destroy_component(optionsection1);
    			destroy_component(optionsection2);
    			destroy_component(optionsectioncompact0);
    			destroy_component(optionsectioncompact1);
    			destroy_component(optionsectioncompact2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$t($$self, $$props, $$invalidate) {
    	let $config;
    	validate_store(config, 'config');
    	component_subscribe($$self, config, $$value => $$invalidate(0, $config = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('AppearanceConfig', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AppearanceConfig> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		OptionSection,
    		OptionSectionCompact,
    		config,
    		ColorContrastConfig,
    		DayNightThemeConfig,
    		FontSizeConfig,
    		GridArtSize,
    		RebuildArtCacheConfig,
    		$config
    	});

    	return [$config];
    }

    class AppearanceConfig extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$t, create_fragment$t, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AppearanceConfig",
    			options,
    			id: create_fragment$t.name
    		});
    	}
    }

    function isHighSurrogate$1(codePoint) {
      return codePoint >= 0xd800 && codePoint <= 0xdbff;
    }

    function isLowSurrogate$1(codePoint) {
      return codePoint >= 0xdc00 && codePoint <= 0xdfff;
    }

    // Truncate string by size in bytes
    var truncate = function truncate(getLength, string, byteLength) {
      if (typeof string !== "string") {
        throw new Error("Input must be string");
      }

      var charLength = string.length;
      var curByteLength = 0;
      var codePoint;
      var segment;

      for (var i = 0; i < charLength; i += 1) {
        codePoint = string.charCodeAt(i);
        segment = string[i];

        if (isHighSurrogate$1(codePoint) && isLowSurrogate$1(string.charCodeAt(i + 1))) {
          i += 1;
          segment += string[i];
        }

        curByteLength += getLength(segment);

        if (curByteLength === byteLength) {
          return string.slice(0, i + 1);
        }
        else if (curByteLength > byteLength) {
          return string.slice(0, i - segment.length + 1);
        }
      }

      return string;
    };

    function isHighSurrogate(codePoint) {
      return codePoint >= 0xd800 && codePoint <= 0xdbff;
    }

    function isLowSurrogate(codePoint) {
      return codePoint >= 0xdc00 && codePoint <= 0xdfff;
    }

    // Truncate string by size in bytes
    var browser$1 = function getByteLength(string) {
      if (typeof string !== "string") {
        throw new Error("Input must be string");
      }

      var charLength = string.length;
      var byteLength = 0;
      var codePoint = null;
      var prevCodePoint = null;
      for (var i = 0; i < charLength; i++) {
        codePoint = string.charCodeAt(i);
        // handle 4-byte non-BMP chars
        // low surrogate
        if (isLowSurrogate(codePoint)) {
          // when parsing previous hi-surrogate, 3 is added to byteLength
          if (prevCodePoint != null && isHighSurrogate(prevCodePoint)) {
            byteLength += 1;
          }
          else {
            byteLength += 3;
          }
        }
        else if (codePoint <= 0x7f ) {
          byteLength += 1;
        }
        else if (codePoint >= 0x80 && codePoint <= 0x7ff) {
          byteLength += 2;
        }
        else if (codePoint >= 0x800 && codePoint <= 0xffff) {
          byteLength += 3;
        }
        prevCodePoint = codePoint;
      }

      return byteLength;
    };

    var browser = truncate.bind(null, browser$1);

    /*jshint node:true*/

    /**
     * Replaces characters in strings that are illegal/unsafe for filenames.
     * Unsafe characters are either removed or replaced by a substitute set
     * in the optional `options` object.
     *
     * Illegal Characters on Various Operating Systems
     * / ? < > \ : * | "
     * https://kb.acronis.com/content/39790
     *
     * Unicode Control codes
     * C0 0x00-0x1f & C1 (0x80-0x9f)
     * http://en.wikipedia.org/wiki/C0_and_C1_control_codes
     *
     * Reserved filenames on Unix-based systems (".", "..")
     * Reserved filenames in Windows ("CON", "PRN", "AUX", "NUL", "COM1",
     * "COM2", "COM3", "COM4", "COM5", "COM6", "COM7", "COM8", "COM9",
     * "LPT1", "LPT2", "LPT3", "LPT4", "LPT5", "LPT6", "LPT7", "LPT8", and
     * "LPT9") case-insesitively and with or without filename extensions.
     *
     * Capped at 255 characters in length.
     * http://unix.stackexchange.com/questions/32795/what-is-the-maximum-allowed-filename-and-folder-size-with-ecryptfs
     *
     * @param  {String} input   Original filename
     * @param  {Object} options {replacement: String | Function }
     * @return {String}         Sanitized filename
     */



    var illegalRe = /[\/\?<>\\:\*\|"]/g;
    var controlRe = /[\x00-\x1f\x80-\x9f]/g;
    var reservedRe = /^\.+$/;
    var windowsReservedRe = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i;
    var windowsTrailingRe = /[\. ]+$/;

    function sanitize(input, replacement) {
      if (typeof input !== 'string') {
        throw new Error('Input must be string');
      }
      var sanitized = input
        .replace(illegalRe, replacement)
        .replace(controlRe, replacement)
        .replace(reservedRe, replacement)
        .replace(windowsReservedRe, replacement)
        .replace(windowsTrailingRe, replacement);
      return browser(sanitized, 255);
    }

    var sanitizeFilename = function (input, options) {
      var replacement = (options && options.replacement) || '';
      var output = sanitize(input, replacement);
      if (replacement === '') {
        return output;
      }
      return sanitize(output, '');
    };

    function validateFileNameFn (input) {
        if (input === 'Default') {
            return { isValid: false, errorMessage: 'Default profile name is reserved.' };
        }
        if (input === '') {
            return { isValid: false, errorMessage: "Profile name can't be empty." };
        }
        if (sanitizeFilename(input) !== input) {
            return { isValid: false, errorMessage: 'Avoid weird characters pretty please.' };
        }
        return { isValid: true };
    }

    /* src/icons/SaveIcon.svelte generated by Svelte v3.49.0 */

    const file$n = "src/icons/SaveIcon.svelte";

    function create_fragment$s(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$n, 6, 2, 159);
    			attr_dev(path1, "d", "M7 19v-6h10v6h2V7.828L16.172 5H5v14h2zM4 3h13l4 4v13a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1zm5 12v4h6v-4H9z");
    			add_location(path1, file$n, 6, 40, 197);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "style", /*style*/ ctx[0]);
    			add_location(svg, file$n, 5, 0, 89);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*style*/ 1) {
    				attr_dev(svg, "style", /*style*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$s($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SaveIcon', slots, []);
    	let { style = '' } = $$props;
    	const writable_props = ['style'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SaveIcon> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	$$self.$capture_state = () => ({ style });

    	$$self.$inject_state = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [style];
    }

    class SaveIcon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$s, create_fragment$s, safe_not_equal, { style: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SaveIcon",
    			options,
    			id: create_fragment$s.name
    		});
    	}

    	get style() {
    		throw new Error("<SaveIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<SaveIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/icons/ToggleOffIcon.svelte generated by Svelte v3.49.0 */

    const file$m = "src/icons/ToggleOffIcon.svelte";

    function create_fragment$r(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$m, 6, 2, 159);
    			attr_dev(path1, "d", "M8 7a5 5 0 1 0 0 10h8a5 5 0 0 0 0-10H8zm0-2h8a7 7 0 0 1 0 14H8A7 7 0 0 1 8 5zm0 10a3 3 0 1 1 0-6 3 3 0 0 1 0 6z");
    			add_location(path1, file$m, 6, 40, 197);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "style", /*style*/ ctx[0]);
    			add_location(svg, file$m, 5, 0, 89);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*style*/ 1) {
    				attr_dev(svg, "style", /*style*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$r($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ToggleOffIcon', slots, []);
    	let { style = '' } = $$props;
    	const writable_props = ['style'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ToggleOffIcon> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	$$self.$capture_state = () => ({ style });

    	$$self.$inject_state = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [style];
    }

    class ToggleOffIcon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$r, create_fragment$r, safe_not_equal, { style: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ToggleOffIcon",
    			options,
    			id: create_fragment$r.name
    		});
    	}

    	get style() {
    		throw new Error("<ToggleOffIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<ToggleOffIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/icons/ToggleOnIcon.svelte generated by Svelte v3.49.0 */

    const file$l = "src/icons/ToggleOnIcon.svelte";

    function create_fragment$q(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$l, 6, 2, 159);
    			attr_dev(path1, "d", "M8 5h8a7 7 0 0 1 0 14H8A7 7 0 0 1 8 5zm8 10a3 3 0 1 0 0-6 3 3 0 0 0 0 6z");
    			add_location(path1, file$l, 6, 40, 197);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "style", /*style*/ ctx[0]);
    			add_location(svg, file$l, 5, 0, 89);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*style*/ 1) {
    				attr_dev(svg, "style", /*style*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$q($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ToggleOnIcon', slots, []);
    	let { style = '' } = $$props;
    	const writable_props = ['style'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ToggleOnIcon> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	$$self.$capture_state = () => ({ style });

    	$$self.$inject_state = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [style];
    }

    class ToggleOnIcon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$q, create_fragment$q, safe_not_equal, { style: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ToggleOnIcon",
    			options,
    			id: create_fragment$q.name
    		});
    	}

    	get style() {
    		throw new Error("<ToggleOnIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<ToggleOnIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/layouts/config/equalizer/EqualizerButtons.svelte generated by Svelte v3.49.0 */
    const file$k = "src/layouts/config/equalizer/EqualizerButtons.svelte";

    // (49:2) {:else}
    function create_else_block$3(ctx) {
    	let toggleofficon;
    	let current;

    	toggleofficon = new ToggleOffIcon({
    			props: {
    				style: "height:1.25rem;width:auto;fill:#fff;margin-right:0.25rem;"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(toggleofficon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(toggleofficon, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(toggleofficon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(toggleofficon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(toggleofficon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$3.name,
    		type: "else",
    		source: "(49:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (47:2) {#if $isEqualizerOn === true}
    function create_if_block$6(ctx) {
    	let toggleonicon;
    	let current;

    	toggleonicon = new ToggleOnIcon({
    			props: {
    				style: "height:1.25rem;width:auto;fill:#fff;margin-right:0.25rem;"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(toggleonicon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(toggleonicon, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(toggleonicon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(toggleonicon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(toggleonicon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(47:2) {#if $isEqualizerOn === true}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$p(ctx) {
    	let equalizer_buttons_config;
    	let button0;
    	let current_block_type_index;
    	let if_block;
    	let t0;
    	let button0_class_value;
    	let t1;
    	let button1;
    	let refreshicon;
    	let t2;
    	let button1_disabled_value;
    	let t3;
    	let button2;
    	let saveicon;
    	let t4;
    	let button2_disabled_value;
    	let t5;
    	let button3;
    	let updateicon;
    	let t6;
    	let button3_disabled_value;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block$6, create_else_block$3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$isEqualizerOn*/ ctx[0] === true) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	refreshicon = new RefreshIcon({
    			props: {
    				style: "height:1.25rem;width:auto;fill:#fff;margin-right:0.25rem;"
    			},
    			$$inline: true
    		});

    	saveicon = new SaveIcon({
    			props: {
    				style: "height:1.25rem;width:auto;fill:#fff;margin-right:0.25rem;"
    			},
    			$$inline: true
    		});

    	updateicon = new UpdateIcon({
    			props: {
    				style: "height:1.25rem;width:auto;fill:#fff;margin-right:0.25rem;"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			equalizer_buttons_config = element("equalizer-buttons-config");
    			button0 = element("button");
    			if_block.c();
    			t0 = text("\n\n\t\tToggle EQ");
    			t1 = space();
    			button1 = element("button");
    			create_component(refreshicon.$$.fragment);
    			t2 = text("\n\t\tReset");
    			t3 = space();
    			button2 = element("button");
    			create_component(saveicon.$$.fragment);
    			t4 = text("\n\t\tSave as...");
    			t5 = space();
    			button3 = element("button");
    			create_component(updateicon.$$.fragment);
    			t6 = text("\n\t\tUpdate");
    			attr_dev(button0, "class", button0_class_value = "toggleEqButton " + (/*$isEqualizerOn*/ ctx[0] ? 'active' : 'not-active') + " svelte-nhauwk");
    			add_location(button0, file$k, 45, 1, 2106);
    			attr_dev(button1, "class", "resetEqButton svelte-nhauwk");
    			button1.disabled = button1_disabled_value = /*$isEqualizerDirty*/ ctx[2] === false || /*$isEqualizerOn*/ ctx[0] === false;
    			add_location(button1, file$k, 54, 1, 2475);
    			button2.disabled = button2_disabled_value = /*$isEqualizerOn*/ ctx[0] === false;
    			attr_dev(button2, "class", "svelte-nhauwk");
    			add_location(button2, file$k, 62, 1, 2737);
    			button3.disabled = button3_disabled_value = !/*$isEqualizerDirty*/ ctx[2];
    			attr_dev(button3, "class", "svelte-nhauwk");
    			add_location(button3, file$k, 66, 1, 2923);
    			set_custom_element_data(equalizer_buttons_config, "class", "svelte-nhauwk");
    			add_location(equalizer_buttons_config, file$k, 44, 0, 2078);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, equalizer_buttons_config, anchor);
    			append_dev(equalizer_buttons_config, button0);
    			if_blocks[current_block_type_index].m(button0, null);
    			append_dev(button0, t0);
    			append_dev(equalizer_buttons_config, t1);
    			append_dev(equalizer_buttons_config, button1);
    			mount_component(refreshicon, button1, null);
    			append_dev(button1, t2);
    			append_dev(equalizer_buttons_config, t3);
    			append_dev(equalizer_buttons_config, button2);
    			mount_component(saveicon, button2, null);
    			append_dev(button2, t4);
    			append_dev(equalizer_buttons_config, t5);
    			append_dev(equalizer_buttons_config, button3);
    			mount_component(updateicon, button3, null);
    			append_dev(button3, t6);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[5], false, false, false),
    					listen_dev(button2, "click", /*click_handler_2*/ ctx[6], false, false, false),
    					listen_dev(button3, "click", /*click_handler_3*/ ctx[7], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(button0, t0);
    			}

    			if (!current || dirty & /*$isEqualizerOn*/ 1 && button0_class_value !== (button0_class_value = "toggleEqButton " + (/*$isEqualizerOn*/ ctx[0] ? 'active' : 'not-active') + " svelte-nhauwk")) {
    				attr_dev(button0, "class", button0_class_value);
    			}

    			if (!current || dirty & /*$isEqualizerDirty, $isEqualizerOn*/ 5 && button1_disabled_value !== (button1_disabled_value = /*$isEqualizerDirty*/ ctx[2] === false || /*$isEqualizerOn*/ ctx[0] === false)) {
    				prop_dev(button1, "disabled", button1_disabled_value);
    			}

    			if (!current || dirty & /*$isEqualizerOn*/ 1 && button2_disabled_value !== (button2_disabled_value = /*$isEqualizerOn*/ ctx[0] === false)) {
    				prop_dev(button2, "disabled", button2_disabled_value);
    			}

    			if (!current || dirty & /*$isEqualizerDirty*/ 4 && button3_disabled_value !== (button3_disabled_value = !/*$isEqualizerDirty*/ ctx[2])) {
    				prop_dev(button3, "disabled", button3_disabled_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(refreshicon.$$.fragment, local);
    			transition_in(saveicon.$$.fragment, local);
    			transition_in(updateicon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(refreshicon.$$.fragment, local);
    			transition_out(saveicon.$$.fragment, local);
    			transition_out(updateicon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(equalizer_buttons_config);
    			if_blocks[current_block_type_index].d();
    			destroy_component(refreshicon);
    			destroy_component(saveicon);
    			destroy_component(updateicon);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$p($$self, $$props, $$invalidate) {
    	let $selectedEqName;
    	let $equalizerProfiles;
    	let $equalizer;
    	let $promptService;
    	let $isEqualizerOn;
    	let $equalizerService;
    	let $isEqualizerDirty;
    	validate_store(selectedEqName, 'selectedEqName');
    	component_subscribe($$self, selectedEqName, $$value => $$invalidate(8, $selectedEqName = $$value));
    	validate_store(equalizerProfiles, 'equalizerProfiles');
    	component_subscribe($$self, equalizerProfiles, $$value => $$invalidate(9, $equalizerProfiles = $$value));
    	validate_store(equalizer, 'equalizer');
    	component_subscribe($$self, equalizer, $$value => $$invalidate(10, $equalizer = $$value));
    	validate_store(promptService, 'promptService');
    	component_subscribe($$self, promptService, $$value => $$invalidate(11, $promptService = $$value));
    	validate_store(isEqualizerOn, 'isEqualizerOn');
    	component_subscribe($$self, isEqualizerOn, $$value => $$invalidate(0, $isEqualizerOn = $$value));
    	validate_store(equalizerService, 'equalizerService');
    	component_subscribe($$self, equalizerService, $$value => $$invalidate(1, $equalizerService = $$value));
    	validate_store(isEqualizerDirty, 'isEqualizerDirty');
    	component_subscribe($$self, isEqualizerDirty, $$value => $$invalidate(2, $isEqualizerDirty = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('EqualizerButtons', slots, []);

    	function saveEqualizerAs(newName = '') {
    		let promptState = {
    			title: 'Enter Equalizer Name',
    			placeholder: 'Equalizer name',
    			confirmButtonText: 'Save As',
    			cancelButtonText: 'Cancel',
    			validateFn: validateFileNameFn,
    			data: { id: generateId(), inputValue: newName }
    		};

    		$promptService.showPrompt(promptState).then(promptResult => {
    			$promptService.closePrompt();

    			let newEqualizerProfile = {
    				name: promptResult.data.result,
    				values: {}
    			};

    			for (let i in $equalizer) {
    				newEqualizerProfile.values[$equalizer[i].frequency.value] = $equalizer[i].gain.value;
    			} // newEqualizerProfile.values.push({ frequency: $equalizer[i].frequency.value, gain: $equalizer[i].gain.value })

    			window.ipc.addNewEqualizerProfile(newEqualizerProfile).then(result => {
    				if (result.code === 'EXISTS') {
    					notifyService.error(`Name ${newEqualizerProfile.name} already exists.`);
    					saveEqualizerAs(newEqualizerProfile.name);
    				} else if (result.code === 'OK') {
    					$equalizerProfiles.unshift(newEqualizerProfile);
    					equalizerProfiles.set($equalizerProfiles);
    					set_store_value(selectedEqName, $selectedEqName = newEqualizerProfile.name, $selectedEqName);
    				}
    			});
    		});
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<EqualizerButtons> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => $equalizerService.toggleEq();
    	const click_handler_1 = () => $equalizerService.resetEqualizer();
    	const click_handler_2 = () => saveEqualizerAs();
    	const click_handler_3 = () => $equalizerService.updateEqualizer();

    	$$self.$capture_state = () => ({
    		generateId,
    		validateFileNameFn,
    		RefreshIcon,
    		SaveIcon,
    		ToggleOffIcon,
    		ToggleOnIcon,
    		UpdateIcon,
    		notify: notifyService,
    		equalizer,
    		equalizerProfiles,
    		isEqualizerDirty,
    		isEqualizerOn,
    		selectedEqName,
    		equalizerService,
    		promptService,
    		saveEqualizerAs,
    		$selectedEqName,
    		$equalizerProfiles,
    		$equalizer,
    		$promptService,
    		$isEqualizerOn,
    		$equalizerService,
    		$isEqualizerDirty
    	});

    	return [
    		$isEqualizerOn,
    		$equalizerService,
    		$isEqualizerDirty,
    		saveEqualizerAs,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3
    	];
    }

    class EqualizerButtons extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$p, create_fragment$p, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EqualizerButtons",
    			options,
    			id: create_fragment$p.name
    		});
    	}
    }

    function objectToArrayFn (inObject) {
        let tempArray = [];
        for (const key in inObject) {
            tempArray.push(inObject[key]);
        }
        return tempArray;
    }

    /* src/layouts/config/equalizer/EqualizerControls.svelte generated by Svelte v3.49.0 */
    const file$j = "src/layouts/config/equalizer/EqualizerControls.svelte";

    function get_each_context$8(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	child_ctx[9] = i;
    	return child_ctx;
    }

    // (16:1) {#each objectToArrayFn($equalizer) as equalizerProfile, index (index)}
    function create_each_block$8(key_1, ctx) {
    	let audio_filter_range;
    	let filter_frequency;
    	let t0_value = /*equalizerProfile*/ ctx[7].frequency.value + "";
    	let t0;
    	let t1;
    	let t2;
    	let eq_input_container;
    	let input;
    	let input_value_value;
    	let input_disabled_value;
    	let t3;
    	let filter_gain;
    	let t4_value = /*equalizerProfile*/ ctx[7].gain.value + "";
    	let t4;
    	let t5;
    	let t6;
    	let mounted;
    	let dispose;

    	function input_handler(...args) {
    		return /*input_handler*/ ctx[4](/*equalizerProfile*/ ctx[7], ...args);
    	}

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			audio_filter_range = element("audio-filter-range");
    			filter_frequency = element("filter-frequency");
    			t0 = text(t0_value);
    			t1 = text(" Hz");
    			t2 = space();
    			eq_input_container = element("eq-input-container");
    			input = element("input");
    			t3 = space();
    			filter_gain = element("filter-gain");
    			t4 = text(t4_value);
    			t5 = text(" dB");
    			t6 = space();
    			set_custom_element_data(filter_frequency, "class", "svelte-3ev1gh");
    			add_location(filter_frequency, file$j, 17, 3, 646);
    			attr_dev(input, "type", "range");
    			attr_dev(input, "min", "-8");
    			attr_dev(input, "max", "8");
    			attr_dev(input, "step", "1");
    			input.value = input_value_value = /*equalizerProfile*/ ctx[7].gain.value;
    			input.disabled = input_disabled_value = !/*$isEqualizerOn*/ ctx[2];
    			attr_dev(input, "class", "svelte-3ev1gh");
    			add_location(input, file$j, 19, 4, 749);
    			set_custom_element_data(eq_input_container, "class", "svelte-3ev1gh");
    			add_location(eq_input_container, file$j, 18, 3, 724);
    			set_custom_element_data(filter_gain, "class", "svelte-3ev1gh");
    			add_location(filter_gain, file$j, 29, 3, 1014);
    			set_custom_element_data(audio_filter_range, "class", "svelte-3ev1gh");
    			add_location(audio_filter_range, file$j, 16, 2, 622);
    			this.first = audio_filter_range;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, audio_filter_range, anchor);
    			append_dev(audio_filter_range, filter_frequency);
    			append_dev(filter_frequency, t0);
    			append_dev(filter_frequency, t1);
    			append_dev(audio_filter_range, t2);
    			append_dev(audio_filter_range, eq_input_container);
    			append_dev(eq_input_container, input);
    			append_dev(audio_filter_range, t3);
    			append_dev(audio_filter_range, filter_gain);
    			append_dev(filter_gain, t4);
    			append_dev(filter_gain, t5);
    			append_dev(audio_filter_range, t6);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", input_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*$equalizer*/ 2 && t0_value !== (t0_value = /*equalizerProfile*/ ctx[7].frequency.value + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*$equalizer*/ 2 && input_value_value !== (input_value_value = /*equalizerProfile*/ ctx[7].gain.value)) {
    				prop_dev(input, "value", input_value_value);
    			}

    			if (dirty & /*$isEqualizerOn*/ 4 && input_disabled_value !== (input_disabled_value = !/*$isEqualizerOn*/ ctx[2])) {
    				prop_dev(input, "disabled", input_disabled_value);
    			}

    			if (dirty & /*$equalizer*/ 2 && t4_value !== (t4_value = /*equalizerProfile*/ ctx[7].gain.value + "")) set_data_dev(t4, t4_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(audio_filter_range);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$8.name,
    		type: "each",
    		source: "(16:1) {#each objectToArrayFn($equalizer) as equalizerProfile, index (index)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$o(ctx) {
    	let equalizer_controls_config;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let each_value = objectToArrayFn(/*$equalizer*/ ctx[1]);
    	validate_each_argument(each_value);
    	const get_key = ctx => /*index*/ ctx[9];
    	validate_each_keys(ctx, each_value, get_each_context$8, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$8(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$8(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			equalizer_controls_config = element("equalizer-controls-config");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			set_custom_element_data(equalizer_controls_config, "class", "svelte-3ev1gh");
    			add_location(equalizer_controls_config, file$j, 14, 0, 520);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, equalizer_controls_config, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(equalizer_controls_config, null);
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*objectToArrayFn, $equalizer, $isEqualizerOn, $equalizerService*/ 7) {
    				each_value = objectToArrayFn(/*$equalizer*/ ctx[1]);
    				validate_each_argument(each_value);
    				validate_each_keys(ctx, each_value, get_each_context$8, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, equalizer_controls_config, destroy_block, create_each_block$8, null, get_each_context$8);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(equalizer_controls_config);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$o($$self, $$props, $$invalidate) {
    	let $equalizerService;
    	let $selectedEqName;
    	let $equalizerNameStore;
    	let $equalizer;
    	let $isEqualizerOn;
    	validate_store(equalizerService, 'equalizerService');
    	component_subscribe($$self, equalizerService, $$value => $$invalidate(0, $equalizerService = $$value));
    	validate_store(selectedEqName, 'selectedEqName');
    	component_subscribe($$self, selectedEqName, $$value => $$invalidate(3, $selectedEqName = $$value));
    	validate_store(equalizerNameStore, 'equalizerNameStore');
    	component_subscribe($$self, equalizerNameStore, $$value => $$invalidate(5, $equalizerNameStore = $$value));
    	validate_store(equalizer, 'equalizer');
    	component_subscribe($$self, equalizer, $$value => $$invalidate(1, $equalizer = $$value));
    	validate_store(isEqualizerOn, 'isEqualizerOn');
    	component_subscribe($$self, isEqualizerOn, $$value => $$invalidate(2, $isEqualizerOn = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('EqualizerControls', slots, []);

    	function getProfileNameFromId(eqId) {
    		if ($equalizerService !== undefined) {
    			return $equalizerService.getEqualizerName(eqId);
    		} else {
    			return '';
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<EqualizerControls> was created with unknown prop '${key}'`);
    	});

    	const input_handler = (equalizerProfile, evt) => $equalizerService.gainChange(evt, equalizerProfile.frequency.value);

    	$$self.$capture_state = () => ({
    		equalizer,
    		equalizerNameStore,
    		isEqualizerOn,
    		selectedEqName,
    		equalizerService,
    		objectToArrayFn,
    		getProfileNameFromId,
    		$equalizerService,
    		$selectedEqName,
    		$equalizerNameStore,
    		$equalizer,
    		$isEqualizerOn
    	});

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$selectedEqName*/ 8) {
    			set_store_value(equalizerNameStore, $equalizerNameStore = getProfileNameFromId($selectedEqName), $equalizerNameStore);
    		}
    	};

    	return [$equalizerService, $equalizer, $isEqualizerOn, $selectedEqName, input_handler];
    }

    class EqualizerControls extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$o, create_fragment$o, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EqualizerControls",
    			options,
    			id: create_fragment$o.name
    		});
    	}
    }

    /* src/icons/AddIcon.svelte generated by Svelte v3.49.0 */

    const file$i = "src/icons/AddIcon.svelte";

    function create_fragment$n(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$i, 6, 2, 159);
    			attr_dev(path1, "d", "M11 11V7h2v4h4v2h-4v4h-2v-4H7v-2h4zm1 11C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10-4.477 10-10 10zm0-2a8 8 0 1 0 0-16 8 8 0 0 0 0 16z");
    			add_location(path1, file$i, 6, 40, 197);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "style", /*style*/ ctx[0]);
    			add_location(svg, file$i, 5, 0, 89);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*style*/ 1) {
    				attr_dev(svg, "style", /*style*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$n($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('AddIcon', slots, []);
    	let { style = '' } = $$props;
    	const writable_props = ['style'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AddIcon> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	$$self.$capture_state = () => ({ style });

    	$$self.$inject_state = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [style];
    }

    class AddIcon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$n, create_fragment$n, safe_not_equal, { style: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AddIcon",
    			options,
    			id: create_fragment$n.name
    		});
    	}

    	get style() {
    		throw new Error("<AddIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<AddIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/icons/DeleteIcon.svelte generated by Svelte v3.49.0 */

    const file$h = "src/icons/DeleteIcon.svelte";

    function create_fragment$m(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$h, 6, 2, 159);
    			attr_dev(path1, "d", "M12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10-4.477 10-10 10zm0-11.414L9.172 7.757 7.757 9.172 10.586 12l-2.829 2.828 1.415 1.415L12 13.414l2.828 2.829 1.415-1.415L13.414 12l2.829-2.828-1.415-1.415L12 10.586z");
    			add_location(path1, file$h, 6, 40, 197);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "style", /*style*/ ctx[0]);
    			add_location(svg, file$h, 5, 0, 89);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*style*/ 1) {
    				attr_dev(svg, "style", /*style*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$m($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('DeleteIcon', slots, []);
    	let { style = '' } = $$props;
    	const writable_props = ['style'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<DeleteIcon> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	$$self.$capture_state = () => ({ style });

    	$$self.$inject_state = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [style];
    }

    class DeleteIcon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$m, create_fragment$m, safe_not_equal, { style: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DeleteIcon",
    			options,
    			id: create_fragment$m.name
    		});
    	}

    	get style() {
    		throw new Error("<DeleteIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<DeleteIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/icons/EditIcon.svelte generated by Svelte v3.49.0 */

    const file$g = "src/icons/EditIcon.svelte";

    function create_fragment$l(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$g, 5, 68, 157);
    			attr_dev(path1, "d", "M21 15.243v5.765a.993.993 0 0 1-.993.992H3.993A1 1 0 0 1 3 20.993V9h6a1 1 0 0 0 1-1V2h10.002c.551 0 .998.455.998.992v3.765l-8.999 9-.006 4.238 4.246.006L21 15.243zm.778-6.435l1.414 1.414L15.414 18l-1.416-.002.002-1.412 7.778-7.778zM3 7l5-4.997V7H3z");
    			add_location(path1, file$g, 5, 105, 194);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "style", /*style*/ ctx[0]);
    			add_location(svg, file$g, 5, 0, 89);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*style*/ 1) {
    				attr_dev(svg, "style", /*style*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$l($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('EditIcon', slots, []);
    	let { style = '' } = $$props;
    	const writable_props = ['style'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<EditIcon> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	$$self.$capture_state = () => ({ style });

    	$$self.$inject_state = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [style];
    }

    class EditIcon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$l, create_fragment$l, safe_not_equal, { style: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EditIcon",
    			options,
    			id: create_fragment$l.name
    		});
    	}

    	get style() {
    		throw new Error("<EditIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<EditIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/layouts/config/equalizer/EqualizerProfiles.svelte generated by Svelte v3.49.0 */

    const file$f = "src/layouts/config/equalizer/EqualizerProfiles.svelte";

    function get_each_context$7(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[13] = list[i];
    	return child_ctx;
    }

    // (105:2) {#each $equalizerProfiles as eq (eq.name)}
    function create_each_block$7(key_1, ctx) {
    	let equalizer_field;
    	let equalizer_name;

    	let t0_value = (/*$selectedEqName*/ ctx[0] === /*eq*/ ctx[13].name
    	? '‣ '
    	: '') + "";

    	let t0;
    	let t1;
    	let t2_value = /*eq*/ ctx[13].name + "";
    	let t2;
    	let t3;
    	let equalizer_rename;
    	let editicon;
    	let t4;
    	let t5;
    	let equalizer_delete;
    	let deleteicon;
    	let t6;
    	let t7;
    	let equalizer_field_id_value;
    	let current;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[6](/*eq*/ ctx[13]);
    	}

    	editicon = new EditIcon({
    			props: {
    				style: "height:1rem;width:auto;fill:#fff;margin-right:0.25rem;"
    			},
    			$$inline: true
    		});

    	function click_handler_1() {
    		return /*click_handler_1*/ ctx[7](/*eq*/ ctx[13]);
    	}

    	deleteicon = new DeleteIcon({
    			props: {
    				style: "height:1rem;width:auto;fill:#fff;margin-right:0.25rem;"
    			},
    			$$inline: true
    		});

    	function click_handler_2() {
    		return /*click_handler_2*/ ctx[8](/*eq*/ ctx[13]);
    	}

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			equalizer_field = element("equalizer-field");
    			equalizer_name = element("equalizer-name");
    			t0 = text(t0_value);
    			t1 = space();
    			t2 = text(t2_value);
    			t3 = space();
    			equalizer_rename = element("equalizer-rename");
    			create_component(editicon.$$.fragment);
    			t4 = text("\n\t\t\t\t\tRename");
    			t5 = space();
    			equalizer_delete = element("equalizer-delete");
    			create_component(deleteicon.$$.fragment);
    			t6 = text("\n\t\t\t\t\tDelete");
    			t7 = space();
    			set_custom_element_data(equalizer_name, "class", "svelte-1gsrgud");
    			add_location(equalizer_name, file$f, 106, 4, 4248);
    			set_custom_element_data(equalizer_rename, "class", "eqProfileButton svelte-1gsrgud");
    			add_location(equalizer_rename, file$f, 109, 4, 4406);
    			set_custom_element_data(equalizer_delete, "class", "eqProfileButton svelte-1gsrgud");
    			add_location(equalizer_delete, file$f, 113, 4, 4605);
    			set_custom_element_data(equalizer_field, "id", equalizer_field_id_value = "eq-" + /*eq*/ ctx[13].name);
    			set_custom_element_data(equalizer_field, "class", "svelte-1gsrgud");
    			add_location(equalizer_field, file$f, 105, 3, 4208);
    			this.first = equalizer_field;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, equalizer_field, anchor);
    			append_dev(equalizer_field, equalizer_name);
    			append_dev(equalizer_name, t0);
    			append_dev(equalizer_name, t1);
    			append_dev(equalizer_name, t2);
    			append_dev(equalizer_field, t3);
    			append_dev(equalizer_field, equalizer_rename);
    			mount_component(editicon, equalizer_rename, null);
    			append_dev(equalizer_rename, t4);
    			append_dev(equalizer_field, t5);
    			append_dev(equalizer_field, equalizer_delete);
    			mount_component(deleteicon, equalizer_delete, null);
    			append_dev(equalizer_delete, t6);
    			append_dev(equalizer_field, t7);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(equalizer_name, "click", click_handler, false, false, false),
    					listen_dev(equalizer_rename, "click", click_handler_1, false, false, false),
    					listen_dev(equalizer_delete, "click", click_handler_2, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if ((!current || dirty & /*$selectedEqName, $equalizerProfiles*/ 3) && t0_value !== (t0_value = (/*$selectedEqName*/ ctx[0] === /*eq*/ ctx[13].name
    			? '‣ '
    			: '') + "")) set_data_dev(t0, t0_value);

    			if ((!current || dirty & /*$equalizerProfiles*/ 2) && t2_value !== (t2_value = /*eq*/ ctx[13].name + "")) set_data_dev(t2, t2_value);

    			if (!current || dirty & /*$equalizerProfiles*/ 2 && equalizer_field_id_value !== (equalizer_field_id_value = "eq-" + /*eq*/ ctx[13].name)) {
    				set_custom_element_data(equalizer_field, "id", equalizer_field_id_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(editicon.$$.fragment, local);
    			transition_in(deleteicon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(editicon.$$.fragment, local);
    			transition_out(deleteicon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(equalizer_field);
    			destroy_component(editicon);
    			destroy_component(deleteicon);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$7.name,
    		type: "each",
    		source: "(105:2) {#each $equalizerProfiles as eq (eq.name)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$k(ctx) {
    	let equalizer_profiles_config;
    	let equalizer_profiles;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let t0;
    	let button;
    	let addicon;
    	let t1;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*$equalizerProfiles*/ ctx[1];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*eq*/ ctx[13].name;
    	validate_each_keys(ctx, each_value, get_each_context$7, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$7(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$7(key, child_ctx));
    	}

    	addicon = new AddIcon({
    			props: {
    				style: "height:1.25rem;width:auto;fill:#fff;margin-right:0.25rem;"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			equalizer_profiles_config = element("equalizer-profiles-config");
    			equalizer_profiles = element("equalizer-profiles");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t0 = space();
    			button = element("button");
    			create_component(addicon.$$.fragment);
    			t1 = text(" Add new profile");
    			set_custom_element_data(equalizer_profiles, "class", "svelte-1gsrgud");
    			add_location(equalizer_profiles, file$f, 103, 1, 4139);
    			attr_dev(button, "class", "addProfile svelte-1gsrgud");
    			add_location(button, file$f, 120, 1, 4858);
    			add_location(equalizer_profiles_config, file$f, 102, 0, 4110);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, equalizer_profiles_config, anchor);
    			append_dev(equalizer_profiles_config, equalizer_profiles);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(equalizer_profiles, null);
    			}

    			append_dev(equalizer_profiles_config, t0);
    			append_dev(equalizer_profiles_config, button);
    			mount_component(addicon, button, null);
    			append_dev(button, t1);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler_3*/ ctx[9], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$equalizerProfiles, deleteEq, renameEq, $equalizerService, $selectedEqName*/ 31) {
    				each_value = /*$equalizerProfiles*/ ctx[1];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$7, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, equalizer_profiles, outro_and_destroy_block, create_each_block$7, null, get_each_context$7);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(addicon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(addicon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(equalizer_profiles_config);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			destroy_component(addicon);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let $selectedEqName;
    	let $equalizerProfiles;
    	let $equalizer;
    	let $promptService;
    	let $confirmService;
    	let $equalizerService;
    	validate_store(selectedEqName, 'selectedEqName');
    	component_subscribe($$self, selectedEqName, $$value => $$invalidate(0, $selectedEqName = $$value));
    	validate_store(equalizerProfiles, 'equalizerProfiles');
    	component_subscribe($$self, equalizerProfiles, $$value => $$invalidate(1, $equalizerProfiles = $$value));
    	validate_store(equalizer, 'equalizer');
    	component_subscribe($$self, equalizer, $$value => $$invalidate(10, $equalizer = $$value));
    	validate_store(promptService, 'promptService');
    	component_subscribe($$self, promptService, $$value => $$invalidate(11, $promptService = $$value));
    	validate_store(confirmService, 'confirmService');
    	component_subscribe($$self, confirmService, $$value => $$invalidate(12, $confirmService = $$value));
    	validate_store(equalizerService, 'equalizerService');
    	component_subscribe($$self, equalizerService, $$value => $$invalidate(2, $equalizerService = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('EqualizerProfiles', slots, []);

    	function renameEq(eqName) {
    		if (eqName === 'Default') {
    			return notifyService.error("Default profile can't be renamed.");
    		}

    		let promptState = {
    			title: 'Rename Equalizer Preset',
    			placeholder: 'Equalizer new name',
    			confirmButtonText: 'Rename',
    			cancelButtonText: 'Cancel',
    			validateFn: validateFileNameFn,
    			data: { eqName, inputValue: eqName }
    		};

    		$promptService.showPrompt(promptState).then(promptResult => {
    			let newName = promptResult.data.result;

    			window.ipc.renameEqualizer(eqName, newName).then(result => {
    				$promptService.closePrompt();

    				if (result.code === 'OK') {
    					let equalizerFound = $equalizerProfiles.find(x => x.name === eqName);

    					if (equalizerFound) {
    						equalizerFound.name = newName;
    						equalizerProfiles.set($equalizerProfiles);
    					}

    					notifyService.success(`Equalizer renamed to "${newName}"`);
    				} else if (result.code === 'EXISTS') {
    					notifyService.error(`Name ${newName} already exists.`);

    					// Reruns the fn to reopen the prompt.
    					renameEq(eqName);
    				}
    			});
    		});
    	}

    	function deleteEq(eqName) {
    		if (eqName === 'Default') {
    			return notifyService.error("Default profile can't be deleted");
    		}

    		let confirmState = {
    			textToConfirm: `Delete equalizer "${eqName}"?`,
    			title: 'Delete Equalizer',
    			data: { name: eqName }
    		};

    		$confirmService.showConfirm(confirmState).then(result => {
    			$confirmService.closeConfirm();
    			let equalizerName = result.data.name;

    			if (equalizerName) {
    				window.ipc.deleteEqualizer(equalizerName).then(result => {
    					if (result.code === 'OK') {
    						let indexToDelete = $equalizerProfiles.findIndex(x => x.name === equalizerName);
    						$equalizerProfiles.splice(indexToDelete, 1);
    						equalizerProfiles.set($equalizerProfiles);

    						if ($selectedEqName === equalizerName) {
    							set_store_value(selectedEqName, $selectedEqName = 'Default', $selectedEqName);
    						}

    						notifyService.success('Equalizer successfully deleted.');
    					}
    				});
    			}
    		});
    	}

    	function addNewProfile(newName = '') {
    		let promptState = {
    			title: 'New Profile Name',
    			placeholder: 'Enter new profile name',
    			confirmButtonText: 'Confirm',
    			cancelButtonText: 'Cancel',
    			validateFn: validateFileNameFn,
    			data: { id: generateId(), inputValue: newName }
    		};

    		$promptService.showPrompt(promptState).then(promptResult => {
    			$promptService.closePrompt();

    			let newEqualizerProfile = {
    				name: promptResult.data.result,
    				values: {}
    			};

    			for (let i in $equalizer) {
    				newEqualizerProfile.values[$equalizer[i].frequency.value] = 0;
    			}

    			window.ipc.addNewEqualizerProfile(newEqualizerProfile).then(result => {
    				if (result.code === 'EXISTS') {
    					notifyService.error(`Name ${newEqualizerProfile.name} already exists.`);
    					addNewProfile(newEqualizerProfile.name);
    				} else if (result.code === 'OK') {
    					$equalizerProfiles.unshift(newEqualizerProfile);
    					equalizerProfiles.set($equalizerProfiles);
    					set_store_value(selectedEqName, $selectedEqName = newEqualizerProfile.name, $selectedEqName);
    				}
    			});
    		});
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<EqualizerProfiles> was created with unknown prop '${key}'`);
    	});

    	const click_handler = eq => $equalizerService.changeProfile(eq.name);
    	const click_handler_1 = eq => renameEq(eq.name);
    	const click_handler_2 = eq => deleteEq(eq.name);
    	const click_handler_3 = () => addNewProfile();

    	$$self.$capture_state = () => ({
    		generateId,
    		validateFileNameFn,
    		AddIcon,
    		DeleteIcon,
    		EditIcon,
    		notify: notifyService,
    		equalizer,
    		equalizerProfiles,
    		selectedEqName,
    		confirmService,
    		equalizerService,
    		promptService,
    		renameEq,
    		deleteEq,
    		addNewProfile,
    		$selectedEqName,
    		$equalizerProfiles,
    		$equalizer,
    		$promptService,
    		$confirmService,
    		$equalizerService
    	});

    	return [
    		$selectedEqName,
    		$equalizerProfiles,
    		$equalizerService,
    		renameEq,
    		deleteEq,
    		addNewProfile,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3
    	];
    }

    class EqualizerProfiles extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$k, create_fragment$k, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EqualizerProfiles",
    			options,
    			id: create_fragment$k.name
    		});
    	}
    }

    /* src/layouts/config/equalizer/!EqualizerConfig.svelte generated by Svelte v3.49.0 */

    // (8:0) <OptionSection title="Equalizer Profiles">
    function create_default_slot_1(ctx) {
    	let equalizerprofiles;
    	let current;
    	equalizerprofiles = new EqualizerProfiles({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(equalizerprofiles.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(equalizerprofiles, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(equalizerprofiles.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(equalizerprofiles.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(equalizerprofiles, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1.name,
    		type: "slot",
    		source: "(8:0) <OptionSection title=\\\"Equalizer Profiles\\\">",
    		ctx
    	});

    	return block;
    }

    // (12:0) <OptionSection title="Equalizer - {$equalizerNameStore} {$isEqualizerDirty && $isEqualizerOn ? '•' : ''}">
    function create_default_slot$1(ctx) {
    	let equalizercontrols;
    	let t;
    	let equalizerbuttons;
    	let current;
    	equalizercontrols = new EqualizerControls({ $$inline: true });
    	equalizerbuttons = new EqualizerButtons({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(equalizercontrols.$$.fragment);
    			t = space();
    			create_component(equalizerbuttons.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(equalizercontrols, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(equalizerbuttons, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(equalizercontrols.$$.fragment, local);
    			transition_in(equalizerbuttons.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(equalizercontrols.$$.fragment, local);
    			transition_out(equalizerbuttons.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(equalizercontrols, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(equalizerbuttons, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$1.name,
    		type: "slot",
    		source: "(12:0) <OptionSection title=\\\"Equalizer - {$equalizerNameStore} {$isEqualizerDirty && $isEqualizerOn ? '•' : ''}\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$j(ctx) {
    	let optionsection0;
    	let t;
    	let optionsection1;
    	let current;

    	optionsection0 = new OptionSection({
    			props: {
    				title: "Equalizer Profiles",
    				$$slots: { default: [create_default_slot_1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	optionsection1 = new OptionSection({
    			props: {
    				title: "Equalizer - " + /*$equalizerNameStore*/ ctx[0] + " " + (/*$isEqualizerDirty*/ ctx[1] && /*$isEqualizerOn*/ ctx[2]
    				? '•'
    				: ''),
    				$$slots: { default: [create_default_slot$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(optionsection0.$$.fragment);
    			t = space();
    			create_component(optionsection1.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(optionsection0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(optionsection1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const optionsection0_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				optionsection0_changes.$$scope = { dirty, ctx };
    			}

    			optionsection0.$set(optionsection0_changes);
    			const optionsection1_changes = {};

    			if (dirty & /*$equalizerNameStore, $isEqualizerDirty, $isEqualizerOn*/ 7) optionsection1_changes.title = "Equalizer - " + /*$equalizerNameStore*/ ctx[0] + " " + (/*$isEqualizerDirty*/ ctx[1] && /*$isEqualizerOn*/ ctx[2]
    			? '•'
    			: '');

    			if (dirty & /*$$scope*/ 8) {
    				optionsection1_changes.$$scope = { dirty, ctx };
    			}

    			optionsection1.$set(optionsection1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(optionsection0.$$.fragment, local);
    			transition_in(optionsection1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(optionsection0.$$.fragment, local);
    			transition_out(optionsection1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(optionsection0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(optionsection1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$j($$self, $$props, $$invalidate) {
    	let $equalizerNameStore;
    	let $isEqualizerDirty;
    	let $isEqualizerOn;
    	validate_store(equalizerNameStore, 'equalizerNameStore');
    	component_subscribe($$self, equalizerNameStore, $$value => $$invalidate(0, $equalizerNameStore = $$value));
    	validate_store(isEqualizerDirty, 'isEqualizerDirty');
    	component_subscribe($$self, isEqualizerDirty, $$value => $$invalidate(1, $isEqualizerDirty = $$value));
    	validate_store(isEqualizerOn, 'isEqualizerOn');
    	component_subscribe($$self, isEqualizerOn, $$value => $$invalidate(2, $isEqualizerOn = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('EqualizerConfig', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<EqualizerConfig> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		EqualizerButtons,
    		EqualizerControls,
    		EqualizerProfiles,
    		equalizerNameStore,
    		isEqualizerDirty,
    		isEqualizerOn,
    		OptionSection,
    		$equalizerNameStore,
    		$isEqualizerDirty,
    		$isEqualizerOn
    	});

    	return [$equalizerNameStore, $isEqualizerDirty, $isEqualizerOn];
    }

    class EqualizerConfig extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$j, create_fragment$j, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EqualizerConfig",
    			options,
    			id: create_fragment$j.name
    		});
    	}
    }

    /* src/layouts/config/library/LibraryFoldersConfig.svelte generated by Svelte v3.49.0 */
    const file$e = "src/layouts/config/library/LibraryFoldersConfig.svelte";

    function get_each_context$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[5] = list[i];
    	child_ctx[7] = i;
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[5] = list[i];
    	child_ctx[7] = i;
    	return child_ctx;
    }

    // (10:2) {#if $config.directories}
    function create_if_block_1$3(ctx) {
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let each_1_anchor;
    	let current;
    	let each_value_1 = /*$config*/ ctx[0].directories.add || [];
    	validate_each_argument(each_value_1);
    	const get_key = ctx => /*index*/ ctx[7];
    	validate_each_keys(ctx, each_value_1, get_each_context_1, get_key);

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		let child_ctx = get_each_context_1(ctx, each_value_1, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block_1(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*window, $config, getAllSongsFn*/ 1) {
    				each_value_1 = /*$config*/ ctx[0].directories.add || [];
    				validate_each_argument(each_value_1);
    				group_outros();
    				validate_each_keys(ctx, each_value_1, get_each_context_1, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_1, each_1_anchor, get_each_context_1);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d(detaching);
    			}

    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(10:2) {#if $config.directories}",
    		ctx
    	});

    	return block;
    }

    // (11:3) {#each $config.directories.add || [] as directory, index (index)}
    function create_each_block_1(key_1, ctx) {
    	let section_directory;
    	let directory_path;
    	let t0_value = /*directory*/ ctx[5] + "";
    	let t0;
    	let t1;
    	let button;
    	let deleteicon;
    	let t2;
    	let t3;
    	let current;
    	let mounted;
    	let dispose;

    	deleteicon = new DeleteIcon({
    			props: {
    				style: "height:1rem;width:auto;fill:#fff;margin-right:0.25rem;"
    			},
    			$$inline: true
    		});

    	function click_handler() {
    		return /*click_handler*/ ctx[1](/*directory*/ ctx[5]);
    	}

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			section_directory = element("section-directory");
    			directory_path = element("directory-path");
    			t0 = text(t0_value);
    			t1 = space();
    			button = element("button");
    			create_component(deleteicon.$$.fragment);
    			t2 = text("\n\t\t\t\t\t\tRemove");
    			t3 = space();
    			set_custom_element_data(directory_path, "class", "svelte-tvyj17");
    			add_location(directory_path, file$e, 12, 5, 489);
    			attr_dev(button, "class", "danger");
    			add_location(button, file$e, 13, 5, 539);
    			set_custom_element_data(section_directory, "class", "svelte-tvyj17");
    			add_location(section_directory, file$e, 11, 4, 464);
    			this.first = section_directory;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section_directory, anchor);
    			append_dev(section_directory, directory_path);
    			append_dev(directory_path, t0);
    			append_dev(section_directory, t1);
    			append_dev(section_directory, button);
    			mount_component(deleteicon, button, null);
    			append_dev(button, t2);
    			append_dev(section_directory, t3);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if ((!current || dirty & /*$config*/ 1) && t0_value !== (t0_value = /*directory*/ ctx[5] + "")) set_data_dev(t0, t0_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(deleteicon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(deleteicon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section_directory);
    			destroy_component(deleteicon);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(11:3) {#each $config.directories.add || [] as directory, index (index)}",
    		ctx
    	});

    	return block;
    }

    // (39:2) {#if $config.directories}
    function create_if_block$5(ctx) {
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let each_1_anchor;
    	let current;
    	let each_value = /*$config*/ ctx[0].directories.exclude || [];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*index*/ ctx[7];
    	validate_each_keys(ctx, each_value, get_each_context$6, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$6(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$6(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*window, $config, getAllSongsFn*/ 1) {
    				each_value = /*$config*/ ctx[0].directories.exclude || [];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$6, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$6, each_1_anchor, get_each_context$6);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d(detaching);
    			}

    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(39:2) {#if $config.directories}",
    		ctx
    	});

    	return block;
    }

    // (40:3) {#each $config.directories.exclude || [] as directory, index (index)}
    function create_each_block$6(key_1, ctx) {
    	let section_directory;
    	let directory_path;
    	let t0_value = /*directory*/ ctx[5] + "";
    	let t0;
    	let t1;
    	let button;
    	let deleteicon;
    	let t2;
    	let t3;
    	let current;
    	let mounted;
    	let dispose;

    	deleteicon = new DeleteIcon({
    			props: {
    				style: "height:1rem;width:auto;fill:#fff;margin-right:0.25rem;"
    			},
    			$$inline: true
    		});

    	function click_handler_2() {
    		return /*click_handler_2*/ ctx[3](/*directory*/ ctx[5]);
    	}

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			section_directory = element("section-directory");
    			directory_path = element("directory-path");
    			t0 = text(t0_value);
    			t1 = space();
    			button = element("button");
    			create_component(deleteicon.$$.fragment);
    			t2 = text("\n\t\t\t\t\t\tRemove");
    			t3 = space();
    			set_custom_element_data(directory_path, "class", "svelte-tvyj17");
    			add_location(directory_path, file$e, 41, 5, 1351);
    			attr_dev(button, "class", "danger");
    			add_location(button, file$e, 42, 5, 1401);
    			set_custom_element_data(section_directory, "class", "svelte-tvyj17");
    			add_location(section_directory, file$e, 40, 4, 1326);
    			this.first = section_directory;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section_directory, anchor);
    			append_dev(section_directory, directory_path);
    			append_dev(directory_path, t0);
    			append_dev(section_directory, t1);
    			append_dev(section_directory, button);
    			mount_component(deleteicon, button, null);
    			append_dev(button, t2);
    			append_dev(section_directory, t3);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler_2, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if ((!current || dirty & /*$config*/ 1) && t0_value !== (t0_value = /*directory*/ ctx[5] + "")) set_data_dev(t0, t0_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(deleteicon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(deleteicon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section_directory);
    			destroy_component(deleteicon);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$6.name,
    		type: "each",
    		source: "(40:3) {#each $config.directories.exclude || [] as directory, index (index)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$i(ctx) {
    	let add_folder_config;
    	let section_title0;
    	let t1;
    	let section_body0;
    	let t2;
    	let button0;
    	let addicon0;
    	let t3;
    	let t4;
    	let exclude_folder_config;
    	let section_title1;
    	let t6;
    	let section_body1;
    	let t7;
    	let button1;
    	let addicon1;
    	let t8;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*$config*/ ctx[0].directories && create_if_block_1$3(ctx);

    	addicon0 = new AddIcon({
    			props: {
    				style: "height:1rem;width:auto;fill:#fff;margin-right:0.25rem;"
    			},
    			$$inline: true
    		});

    	let if_block1 = /*$config*/ ctx[0].directories && create_if_block$5(ctx);

    	addicon1 = new AddIcon({
    			props: {
    				style: "height:1rem;width:auto;fill:#fff;margin-right:0.25rem;"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			add_folder_config = element("add-folder-config");
    			section_title0 = element("section-title");
    			section_title0.textContent = "Add Folder to Library";
    			t1 = space();
    			section_body0 = element("section-body");
    			if (if_block0) if_block0.c();
    			t2 = space();
    			button0 = element("button");
    			create_component(addicon0.$$.fragment);
    			t3 = text("\n\t\tAdd Directories");
    			t4 = space();
    			exclude_folder_config = element("exclude-folder-config");
    			section_title1 = element("section-title");
    			section_title1.textContent = "Exclude Folder from Library";
    			t6 = space();
    			section_body1 = element("section-body");
    			if (if_block1) if_block1.c();
    			t7 = space();
    			button1 = element("button");
    			create_component(addicon1.$$.fragment);
    			t8 = text("\n\t\tExclude Directories");
    			set_custom_element_data(section_title0, "class", "svelte-tvyj17");
    			add_location(section_title0, file$e, 7, 1, 292);
    			set_custom_element_data(section_body0, "class", "svelte-tvyj17");
    			add_location(section_body0, file$e, 8, 1, 348);
    			attr_dev(button0, "class", "info");
    			add_location(button0, file$e, 24, 1, 853);
    			set_custom_element_data(add_folder_config, "class", "section-main svelte-tvyj17");
    			add_location(add_folder_config, file$e, 6, 0, 250);
    			set_custom_element_data(section_title1, "class", "svelte-tvyj17");
    			add_location(section_title1, file$e, 36, 1, 1146);
    			set_custom_element_data(section_body1, "class", "svelte-tvyj17");
    			add_location(section_body1, file$e, 37, 1, 1206);
    			attr_dev(button1, "class", "info");
    			add_location(button1, file$e, 53, 1, 1719);
    			set_custom_element_data(exclude_folder_config, "class", "section-main svelte-tvyj17");
    			add_location(exclude_folder_config, file$e, 35, 0, 1100);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, add_folder_config, anchor);
    			append_dev(add_folder_config, section_title0);
    			append_dev(add_folder_config, t1);
    			append_dev(add_folder_config, section_body0);
    			if (if_block0) if_block0.m(section_body0, null);
    			append_dev(add_folder_config, t2);
    			append_dev(add_folder_config, button0);
    			mount_component(addicon0, button0, null);
    			append_dev(button0, t3);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, exclude_folder_config, anchor);
    			append_dev(exclude_folder_config, section_title1);
    			append_dev(exclude_folder_config, t6);
    			append_dev(exclude_folder_config, section_body1);
    			if (if_block1) if_block1.m(section_body1, null);
    			append_dev(exclude_folder_config, t7);
    			append_dev(exclude_folder_config, button1);
    			mount_component(addicon1, button1, null);
    			append_dev(button1, t8);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler_1*/ ctx[2], false, false, false),
    					listen_dev(button1, "click", /*click_handler_3*/ ctx[4], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$config*/ ctx[0].directories) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*$config*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$3(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(section_body0, null);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*$config*/ ctx[0].directories) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*$config*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$5(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(section_body1, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(addicon0.$$.fragment, local);
    			transition_in(if_block1);
    			transition_in(addicon1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(addicon0.$$.fragment, local);
    			transition_out(if_block1);
    			transition_out(addicon1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(add_folder_config);
    			if (if_block0) if_block0.d();
    			destroy_component(addicon0);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(exclude_folder_config);
    			if (if_block1) if_block1.d();
    			destroy_component(addicon1);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let $config;
    	validate_store(config, 'config');
    	component_subscribe($$self, config, $$value => $$invalidate(0, $config = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('LibraryFoldersConfig', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<LibraryFoldersConfig> was created with unknown prop '${key}'`);
    	});

    	const click_handler = async directory => window.ipc.removeDirectory(directory, 'remove-add', await getAllSongsFn());

    	const click_handler_1 = async () => {
    		window.ipc.selectDirectories('add', await getAllSongsFn());
    	};

    	const click_handler_2 = async directory => window.ipc.removeDirectory(directory, 'remove-exclude', await getAllSongsFn());

    	const click_handler_3 = async () => {
    		window.ipc.selectDirectories('exclude', await getAllSongsFn());
    	};

    	$$self.$capture_state = () => ({
    		getAllSongsFn,
    		AddIcon,
    		DeleteIcon,
    		config,
    		$config
    	});

    	return [$config, click_handler, click_handler_1, click_handler_2, click_handler_3];
    }

    class LibraryFoldersConfig extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$i, create_fragment$i, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LibraryFoldersConfig",
    			options,
    			id: create_fragment$i.name
    		});
    	}
    }

    /* src/layouts/config/library/!LibraryConfig.svelte generated by Svelte v3.49.0 */

    // (5:0) <OptionSection title="Library Folders">
    function create_default_slot(ctx) {
    	let libraryfoldersconfig;
    	let current;
    	libraryfoldersconfig = new LibraryFoldersConfig({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(libraryfoldersconfig.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(libraryfoldersconfig, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(libraryfoldersconfig.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(libraryfoldersconfig.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(libraryfoldersconfig, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot.name,
    		type: "slot",
    		source: "(5:0) <OptionSection title=\\\"Library Folders\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$h(ctx) {
    	let optionsection;
    	let current;

    	optionsection = new OptionSection({
    			props: {
    				title: "Library Folders",
    				$$slots: { default: [create_default_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(optionsection.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(optionsection, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const optionsection_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				optionsection_changes.$$scope = { dirty, ctx };
    			}

    			optionsection.$set(optionsection_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(optionsection.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(optionsection.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(optionsection, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('LibraryConfig', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<LibraryConfig> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ OptionSection, LibraryFoldersConfig });
    	return [];
    }

    class LibraryConfig extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$h, create_fragment$h, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LibraryConfig",
    			options,
    			id: create_fragment$h.name
    		});
    	}
    }

    var songListTagsVar = [
        { value: 'Album', name: 'Album' },
        { value: 'AlbumArtist', name: 'Album Artist' },
        { value: 'Artist', name: 'Artist' },
        { value: 'BitRate', name: 'Bit Rate' },
        { value: 'Comment', name: 'Comment' },
        { value: 'Composer', name: 'Composer' },
        { value: 'Date_Day', name: 'Date Day' },
        { value: 'Date_Month', name: 'Date Month' },
        { value: 'Date_Year', name: 'Date Year' },
        { value: 'DiscNumber', name: 'Disc Number' },
        { value: 'Duration', name: 'Duration' },
        { value: 'Extension', name: 'Extension' },
        { value: 'Genre', name: 'Genre' },
        { value: 'ID', name: 'ID' },
        { value: 'Rating', name: 'Rating' },
        { value: 'SampleRate', name: 'Sample Rate' },
        { value: 'Size', name: 'Size' },
        { value: 'Title', name: 'Title' },
        { value: 'Track', name: 'Track' },
        { value: 'PlayCount', name: 'Play Count' }
    ].sort((a, b) => a.name.localeCompare(b.name));

    /* src/layouts/config/song_list_tags/AddSongListTag.svelte generated by Svelte v3.49.0 */
    const file$d = "src/layouts/config/song_list_tags/AddSongListTag.svelte";

    function get_each_context$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	child_ctx[9] = i;
    	return child_ctx;
    }

    // (25:4) {#if !$songListTagsValuesStore.includes(tag.value)}
    function create_if_block$4(ctx) {
    	let option;
    	let t_value = /*tag*/ ctx[7].name + "";
    	let t;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = /*tag*/ ctx[7].value;
    			option.value = option.__value;
    			add_location(option, file$d, 25, 5, 990);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(25:4) {#if !$songListTagsValuesStore.includes(tag.value)}",
    		ctx
    	});

    	return block;
    }

    // (24:3) {#each songListTagsVar as tag, index (index)}
    function create_each_block$5(key_1, ctx) {
    	let first;
    	let show_if = !/*$songListTagsValuesStore*/ ctx[1].includes(/*tag*/ ctx[7].value);
    	let if_block_anchor;
    	let if_block = show_if && create_if_block$4(ctx);

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*$songListTagsValuesStore*/ 2) show_if = !/*$songListTagsValuesStore*/ ctx[1].includes(/*tag*/ ctx[7].value);

    			if (show_if) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$4(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$5.name,
    		type: "each",
    		source: "(24:3) {#each songListTagsVar as tag, index (index)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$g(ctx) {
    	let add_song_list_tag;
    	let tag_to_add;
    	let selected_tag;
    	let t0_value = /*getOptionNameFromValue*/ ctx[3](/*optionBind*/ ctx[0]) + "";
    	let t0;
    	let t1;
    	let select;
    	let option;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let mounted;
    	let dispose;
    	let each_value = songListTagsVar;
    	validate_each_argument(each_value);
    	const get_key = ctx => /*index*/ ctx[9];
    	validate_each_keys(ctx, each_value, get_each_context$5, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$5(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$5(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			add_song_list_tag = element("add-song-list-tag");
    			tag_to_add = element("tag-to-add");
    			selected_tag = element("selected-tag");
    			t0 = text(t0_value);
    			t1 = space();
    			select = element("select");
    			option = element("option");
    			option.textContent = "Choose tag to add";

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			set_custom_element_data(selected_tag, "class", "svelte-988n1k");
    			add_location(selected_tag, file$d, 19, 2, 686);
    			option.__value = "ChooseTag";
    			option.value = option.__value;
    			option.disabled = true;
    			add_location(option, file$d, 22, 3, 818);
    			attr_dev(select, "class", "svelte-988n1k");
    			if (/*optionBind*/ ctx[0] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[4].call(select));
    			add_location(select, file$d, 21, 2, 755);
    			set_custom_element_data(tag_to_add, "class", "svelte-988n1k");
    			add_location(tag_to_add, file$d, 18, 1, 671);
    			set_custom_element_data(add_song_list_tag, "class", "svelte-988n1k");
    			add_location(add_song_list_tag, file$d, 17, 0, 650);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, add_song_list_tag, anchor);
    			append_dev(add_song_list_tag, tag_to_add);
    			append_dev(tag_to_add, selected_tag);
    			append_dev(selected_tag, t0);
    			append_dev(tag_to_add, t1);
    			append_dev(tag_to_add, select);
    			append_dev(select, option);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select, null);
    			}

    			select_option(select, /*optionBind*/ ctx[0]);

    			if (!mounted) {
    				dispose = [
    					listen_dev(select, "change", /*select_change_handler*/ ctx[4]),
    					listen_dev(select, "change", /*change_handler*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*optionBind*/ 1 && t0_value !== (t0_value = /*getOptionNameFromValue*/ ctx[3](/*optionBind*/ ctx[0]) + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*songListTagsVar, $songListTagsValuesStore*/ 2) {
    				each_value = songListTagsVar;
    				validate_each_argument(each_value);
    				validate_each_keys(ctx, each_value, get_each_context$5, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, select, destroy_block, create_each_block$5, null, get_each_context$5);
    			}

    			if (dirty & /*optionBind, songListTagsVar*/ 1) {
    				select_option(select, /*optionBind*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(add_song_list_tag);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let $config;
    	let $songListTagsValuesStore;
    	validate_store(config, 'config');
    	component_subscribe($$self, config, $$value => $$invalidate(6, $config = $$value));
    	validate_store(songListTagsValuesStore, 'songListTagsValuesStore');
    	component_subscribe($$self, songListTagsValuesStore, $$value => $$invalidate(1, $songListTagsValuesStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('AddSongListTag', slots, []);
    	let optionBind = 'ChooseTag';

    	function addTag() {
    		if ($config.songListTags.find(tag => tag.value === optionBind) === undefined) {
    			$config.songListTags.push({
    				value: optionBind,
    				isExpanded: false,
    				align: 'center'
    			});

    			config.set($config);
    		}
    	}

    	function getOptionNameFromValue(value) {
    		if (value === 'ChooseTag') {
    			return 'Choose tag to add';
    		}

    		return songListTagsVar.find(option => option.value === value).name;
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AddSongListTag> was created with unknown prop '${key}'`);
    	});

    	function select_change_handler() {
    		optionBind = select_value(this);
    		$$invalidate(0, optionBind);
    	}

    	const change_handler = () => addTag();

    	$$self.$capture_state = () => ({
    		songListTagsVar,
    		config,
    		songListTagsValuesStore,
    		optionBind,
    		addTag,
    		getOptionNameFromValue,
    		$config,
    		$songListTagsValuesStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('optionBind' in $$props) $$invalidate(0, optionBind = $$props.optionBind);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		optionBind,
    		$songListTagsValuesStore,
    		addTag,
    		getOptionNameFromValue,
    		select_change_handler,
    		change_handler
    	];
    }

    class AddSongListTag extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$g, create_fragment$g, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AddSongListTag",
    			options,
    			id: create_fragment$g.name
    		});
    	}
    }

    /* src/icons/MoveIcon.svelte generated by Svelte v3.49.0 */

    const file$c = "src/icons/MoveIcon.svelte";

    function create_fragment$f(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$c, 6, 2, 159);
    			attr_dev(path1, "d", "M3 4h18v2H3V4zm0 7h18v2H3v-2zm0 7h18v2H3v-2z");
    			add_location(path1, file$c, 6, 40, 197);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "style", /*style*/ ctx[0]);
    			add_location(svg, file$c, 5, 0, 89);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*style*/ 1) {
    				attr_dev(svg, "style", /*style*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MoveIcon', slots, []);
    	let { style = '' } = $$props;
    	const writable_props = ['style'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MoveIcon> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	$$self.$capture_state = () => ({ style });

    	$$self.$inject_state = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [style];
    }

    class MoveIcon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$f, create_fragment$f, safe_not_equal, { style: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MoveIcon",
    			options,
    			id: create_fragment$f.name
    		});
    	}

    	get style() {
    		throw new Error("<MoveIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<MoveIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/layouts/config/song_list_tags/SelectedTag.svelte generated by Svelte v3.49.0 */

    const file$b = "src/layouts/config/song_list_tags/SelectedTag.svelte";

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[0] = list[i];
    	child_ctx[1] = i;
    	return child_ctx;
    }

    // (78:0) {:else}
    function create_else_block$2(ctx) {
    	let li;
    	let li_data_align_value;
    	let li_data_is_expanded_value;
    	let li_data_value_value;

    	const block = {
    		c: function create() {
    			li = element("li");
    			attr_dev(li, "class", "not-display svelte-19te95b");
    			attr_dev(li, "data-index", /*index*/ ctx[1]);
    			attr_dev(li, "data-align", li_data_align_value = /*tag*/ ctx[0].align);
    			attr_dev(li, "data-is-expanded", li_data_is_expanded_value = /*tag*/ ctx[0].isExpanded);
    			attr_dev(li, "data-value", li_data_value_value = /*tag*/ ctx[0].value);
    			add_location(li, file$b, 78, 1, 3168);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*index, songListTagsVar*/ 2) {
    				attr_dev(li, "data-index", /*index*/ ctx[1]);
    			}

    			if (dirty & /*tag*/ 1 && li_data_align_value !== (li_data_align_value = /*tag*/ ctx[0].align)) {
    				attr_dev(li, "data-align", li_data_align_value);
    			}

    			if (dirty & /*tag*/ 1 && li_data_is_expanded_value !== (li_data_is_expanded_value = /*tag*/ ctx[0].isExpanded)) {
    				attr_dev(li, "data-is-expanded", li_data_is_expanded_value);
    			}

    			if (dirty & /*tag*/ 1 && li_data_value_value !== (li_data_value_value = /*tag*/ ctx[0].value)) {
    				attr_dev(li, "data-value", li_data_value_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(78:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (33:0) {#if tag.value !== 'DynamicArtists'}
    function create_if_block$3(ctx) {
    	let li;
    	let tag_name;
    	let t0_value = /*getTagNameFromValue*/ ctx[4](/*tag*/ ctx[0].value) + "";
    	let t0;
    	let t1;
    	let select;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let t2;
    	let tag_empty_space;
    	let t3;
    	let tag_expand;
    	let input0;
    	let input0_id_value;
    	let t4;
    	let label0;
    	let t5;
    	let label0_for_value;
    	let tag_expand_data_is_expanded_value;
    	let t6;
    	let tag_aligns;
    	let tag_align_left;
    	let input1;
    	let input1_id_value;
    	let t7;
    	let label1;
    	let t8;
    	let label1_for_value;
    	let t9;
    	let tag_align_center;
    	let input2;
    	let input2_id_value;
    	let t10;
    	let label2;
    	let t11;
    	let label2_for_value;
    	let t12;
    	let tag_align_right;
    	let input3;
    	let input3_id_value;
    	let t13;
    	let label3;
    	let t14;
    	let label3_for_value;
    	let tag_aligns_data_is_active_value;
    	let t15;
    	let move_icon;
    	let moveicon;
    	let t16;
    	let delete_icon;
    	let deleteicon;
    	let li_data_align_value;
    	let li_data_is_expanded_value;
    	let li_data_value_value;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = songListTagsVar;
    	validate_each_argument(each_value);
    	const get_key = ctx => /*index*/ ctx[1];
    	validate_each_keys(ctx, each_value, get_each_context$4, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$4(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$4(key, child_ctx));
    	}

    	moveicon = new MoveIcon({
    			props: {
    				style: "height: 1.25rem;fill:var(--color-fg-1);margin:0 1rem;"
    			},
    			$$inline: true
    		});

    	deleteicon = new DeleteIcon({
    			props: {
    				style: "height: 1.25rem;fill:var(--color-fg-1);"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			li = element("li");
    			tag_name = element("tag-name");
    			t0 = text(t0_value);
    			t1 = space();
    			select = element("select");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t2 = space();
    			tag_empty_space = element("tag-empty-space");
    			t3 = space();
    			tag_expand = element("tag-expand");
    			input0 = element("input");
    			t4 = space();
    			label0 = element("label");
    			t5 = text("Expanded");
    			t6 = space();
    			tag_aligns = element("tag-aligns");
    			tag_align_left = element("tag-align-left");
    			input1 = element("input");
    			t7 = space();
    			label1 = element("label");
    			t8 = text("L");
    			t9 = space();
    			tag_align_center = element("tag-align-center");
    			input2 = element("input");
    			t10 = space();
    			label2 = element("label");
    			t11 = text("C");
    			t12 = space();
    			tag_align_right = element("tag-align-right");
    			input3 = element("input");
    			t13 = space();
    			label3 = element("label");
    			t14 = text("R");
    			t15 = space();
    			move_icon = element("move-icon");
    			create_component(moveicon.$$.fragment);
    			t16 = space();
    			delete_icon = element("delete-icon");
    			create_component(deleteicon.$$.fragment);
    			set_custom_element_data(tag_name, "class", "svelte-19te95b");
    			add_location(tag_name, file$b, 34, 2, 1514);
    			attr_dev(select, "class", "svelte-19te95b");
    			if (/*$config*/ ctx[2].songListTags[/*index*/ ctx[1]].value === void 0) add_render_callback(() => /*select_change_handler*/ ctx[6].call(select));
    			add_location(select, file$b, 35, 2, 1570);
    			set_custom_element_data(tag_empty_space, "class", "svelte-19te95b");
    			add_location(tag_empty_space, file$b, 42, 2, 1833);
    			attr_dev(input0, "id", input0_id_value = "" + (/*index*/ ctx[1] + "-" + /*tag*/ ctx[0].value + "-expand"));
    			attr_dev(input0, "type", "checkbox");
    			attr_dev(input0, "class", "svelte-19te95b");
    			add_location(input0, file$b, 44, 3, 1929);
    			attr_dev(label0, "for", label0_for_value = "" + (/*index*/ ctx[1] + "-" + /*tag*/ ctx[0].value + "-expand"));
    			attr_dev(label0, "class", "svelte-19te95b");
    			add_location(label0, file$b, 45, 3, 2044);
    			set_custom_element_data(tag_expand, "data-is-expanded", tag_expand_data_is_expanded_value = /*$config*/ ctx[2].songListTags[/*index*/ ctx[1]].isExpanded);
    			set_custom_element_data(tag_expand, "class", "svelte-19te95b");
    			add_location(tag_expand, file$b, 43, 2, 1855);
    			attr_dev(input1, "id", input1_id_value = "" + (/*index*/ ctx[1] + "-" + /*tag*/ ctx[0].value + "-l"));
    			attr_dev(input1, "type", "radio");
    			input1.__value = "left";
    			input1.value = input1.__value;
    			attr_dev(input1, "class", "svelte-19te95b");
    			/*$$binding_groups*/ ctx[9][0].push(input1);
    			add_location(input1, file$b, 50, 4, 2231);
    			attr_dev(label1, "for", label1_for_value = "" + (/*index*/ ctx[1] + "-" + /*tag*/ ctx[0].value + "-l"));
    			attr_dev(label1, "class", "svelte-19te95b");
    			add_location(label1, file$b, 51, 4, 2345);
    			set_custom_element_data(tag_align_left, "class", "tag-align svelte-19te95b");
    			add_location(tag_align_left, file$b, 49, 3, 2192);
    			attr_dev(input2, "id", input2_id_value = "" + (/*index*/ ctx[1] + "-" + /*tag*/ ctx[0].value + "-c"));
    			attr_dev(input2, "type", "radio");
    			input2.__value = "center";
    			input2.value = input2.__value;
    			attr_dev(input2, "class", "svelte-19te95b");
    			/*$$binding_groups*/ ctx[9][0].push(input2);
    			add_location(input2, file$b, 55, 4, 2456);
    			attr_dev(label2, "for", label2_for_value = "" + (/*index*/ ctx[1] + "-" + /*tag*/ ctx[0].value + "-c"));
    			attr_dev(label2, "class", "svelte-19te95b");
    			add_location(label2, file$b, 56, 4, 2572);
    			set_custom_element_data(tag_align_center, "class", "tag-align svelte-19te95b");
    			add_location(tag_align_center, file$b, 54, 3, 2415);
    			attr_dev(input3, "id", input3_id_value = "" + (/*index*/ ctx[1] + "-" + /*tag*/ ctx[0].value + "-r"));
    			attr_dev(input3, "type", "radio");
    			input3.__value = "right";
    			input3.value = input3.__value;
    			attr_dev(input3, "class", "svelte-19te95b");
    			/*$$binding_groups*/ ctx[9][0].push(input3);
    			add_location(input3, file$b, 60, 4, 2684);
    			attr_dev(label3, "for", label3_for_value = "" + (/*index*/ ctx[1] + "-" + /*tag*/ ctx[0].value + "-r"));
    			attr_dev(label3, "class", "svelte-19te95b");
    			add_location(label3, file$b, 61, 4, 2799);
    			set_custom_element_data(tag_align_right, "class", "tag-align svelte-19te95b");
    			add_location(tag_align_right, file$b, 59, 3, 2644);
    			set_custom_element_data(tag_aligns, "data-is-active", tag_aligns_data_is_active_value = /*$config*/ ctx[2].songListTags[/*index*/ ctx[1]].isExpanded);
    			set_custom_element_data(tag_aligns, "class", "svelte-19te95b");
    			add_location(tag_aligns, file$b, 48, 2, 2120);
    			set_custom_element_data(move_icon, "class", "svelte-19te95b");
    			add_location(move_icon, file$b, 65, 2, 2885);
    			set_custom_element_data(delete_icon, "class", "svelte-19te95b");
    			add_location(delete_icon, file$b, 69, 2, 2993);
    			attr_dev(li, "data-index", /*index*/ ctx[1]);
    			attr_dev(li, "data-align", li_data_align_value = /*tag*/ ctx[0].align);
    			attr_dev(li, "data-is-expanded", li_data_is_expanded_value = /*tag*/ ctx[0].isExpanded);
    			attr_dev(li, "data-value", li_data_value_value = /*tag*/ ctx[0].value);
    			attr_dev(li, "class", "svelte-19te95b");
    			add_location(li, file$b, 33, 1, 1408);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, tag_name);
    			append_dev(tag_name, t0);
    			append_dev(li, t1);
    			append_dev(li, select);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select, null);
    			}

    			select_option(select, /*$config*/ ctx[2].songListTags[/*index*/ ctx[1]].value);
    			append_dev(li, t2);
    			append_dev(li, tag_empty_space);
    			append_dev(li, t3);
    			append_dev(li, tag_expand);
    			append_dev(tag_expand, input0);
    			input0.checked = /*$config*/ ctx[2].songListTags[/*index*/ ctx[1]].isExpanded;
    			append_dev(tag_expand, t4);
    			append_dev(tag_expand, label0);
    			append_dev(label0, t5);
    			append_dev(li, t6);
    			append_dev(li, tag_aligns);
    			append_dev(tag_aligns, tag_align_left);
    			append_dev(tag_align_left, input1);
    			input1.checked = input1.__value === /*$config*/ ctx[2].songListTags[/*index*/ ctx[1]].align;
    			append_dev(tag_align_left, t7);
    			append_dev(tag_align_left, label1);
    			append_dev(label1, t8);
    			append_dev(tag_aligns, t9);
    			append_dev(tag_aligns, tag_align_center);
    			append_dev(tag_align_center, input2);
    			input2.checked = input2.__value === /*$config*/ ctx[2].songListTags[/*index*/ ctx[1]].align;
    			append_dev(tag_align_center, t10);
    			append_dev(tag_align_center, label2);
    			append_dev(label2, t11);
    			append_dev(tag_aligns, t12);
    			append_dev(tag_aligns, tag_align_right);
    			append_dev(tag_align_right, input3);
    			input3.checked = input3.__value === /*$config*/ ctx[2].songListTags[/*index*/ ctx[1]].align;
    			append_dev(tag_align_right, t13);
    			append_dev(tag_align_right, label3);
    			append_dev(label3, t14);
    			append_dev(li, t15);
    			append_dev(li, move_icon);
    			mount_component(moveicon, move_icon, null);
    			append_dev(li, t16);
    			append_dev(li, delete_icon);
    			mount_component(deleteicon, delete_icon, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(select, "change", /*select_change_handler*/ ctx[6]),
    					listen_dev(input0, "change", /*input0_change_handler*/ ctx[7]),
    					listen_dev(input1, "change", /*input1_change_handler*/ ctx[8]),
    					listen_dev(input2, "change", /*input2_change_handler*/ ctx[10]),
    					listen_dev(input3, "change", /*input3_change_handler*/ ctx[11]),
    					listen_dev(delete_icon, "click", /*click_handler*/ ctx[12], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*tag*/ 1) && t0_value !== (t0_value = /*getTagNameFromValue*/ ctx[4](/*tag*/ ctx[0].value) + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*songListTagsVar, $songListTagsValuesStore*/ 8) {
    				each_value = songListTagsVar;
    				validate_each_argument(each_value);
    				validate_each_keys(ctx, each_value, get_each_context$4, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, select, destroy_block, create_each_block$4, null, get_each_context$4);
    			}

    			if (dirty & /*$config, index, songListTagsVar*/ 6) {
    				select_option(select, /*$config*/ ctx[2].songListTags[/*index*/ ctx[1]].value);
    			}

    			if (!current || dirty & /*index, tag, songListTagsVar*/ 3 && input0_id_value !== (input0_id_value = "" + (/*index*/ ctx[1] + "-" + /*tag*/ ctx[0].value + "-expand"))) {
    				attr_dev(input0, "id", input0_id_value);
    			}

    			if (dirty & /*$config, index, songListTagsVar*/ 6) {
    				input0.checked = /*$config*/ ctx[2].songListTags[/*index*/ ctx[1]].isExpanded;
    			}

    			if (!current || dirty & /*index, tag, songListTagsVar*/ 3 && label0_for_value !== (label0_for_value = "" + (/*index*/ ctx[1] + "-" + /*tag*/ ctx[0].value + "-expand"))) {
    				attr_dev(label0, "for", label0_for_value);
    			}

    			if (!current || dirty & /*$config, index, songListTagsVar*/ 6 && tag_expand_data_is_expanded_value !== (tag_expand_data_is_expanded_value = /*$config*/ ctx[2].songListTags[/*index*/ ctx[1]].isExpanded)) {
    				set_custom_element_data(tag_expand, "data-is-expanded", tag_expand_data_is_expanded_value);
    			}

    			if (!current || dirty & /*index, tag, songListTagsVar*/ 3 && input1_id_value !== (input1_id_value = "" + (/*index*/ ctx[1] + "-" + /*tag*/ ctx[0].value + "-l"))) {
    				attr_dev(input1, "id", input1_id_value);
    			}

    			if (dirty & /*$config, index, songListTagsVar*/ 6) {
    				input1.checked = input1.__value === /*$config*/ ctx[2].songListTags[/*index*/ ctx[1]].align;
    			}

    			if (!current || dirty & /*index, tag, songListTagsVar*/ 3 && label1_for_value !== (label1_for_value = "" + (/*index*/ ctx[1] + "-" + /*tag*/ ctx[0].value + "-l"))) {
    				attr_dev(label1, "for", label1_for_value);
    			}

    			if (!current || dirty & /*index, tag, songListTagsVar*/ 3 && input2_id_value !== (input2_id_value = "" + (/*index*/ ctx[1] + "-" + /*tag*/ ctx[0].value + "-c"))) {
    				attr_dev(input2, "id", input2_id_value);
    			}

    			if (dirty & /*$config, index, songListTagsVar*/ 6) {
    				input2.checked = input2.__value === /*$config*/ ctx[2].songListTags[/*index*/ ctx[1]].align;
    			}

    			if (!current || dirty & /*index, tag, songListTagsVar*/ 3 && label2_for_value !== (label2_for_value = "" + (/*index*/ ctx[1] + "-" + /*tag*/ ctx[0].value + "-c"))) {
    				attr_dev(label2, "for", label2_for_value);
    			}

    			if (!current || dirty & /*index, tag, songListTagsVar*/ 3 && input3_id_value !== (input3_id_value = "" + (/*index*/ ctx[1] + "-" + /*tag*/ ctx[0].value + "-r"))) {
    				attr_dev(input3, "id", input3_id_value);
    			}

    			if (dirty & /*$config, index, songListTagsVar*/ 6) {
    				input3.checked = input3.__value === /*$config*/ ctx[2].songListTags[/*index*/ ctx[1]].align;
    			}

    			if (!current || dirty & /*index, tag, songListTagsVar*/ 3 && label3_for_value !== (label3_for_value = "" + (/*index*/ ctx[1] + "-" + /*tag*/ ctx[0].value + "-r"))) {
    				attr_dev(label3, "for", label3_for_value);
    			}

    			if (!current || dirty & /*$config, index, songListTagsVar*/ 6 && tag_aligns_data_is_active_value !== (tag_aligns_data_is_active_value = /*$config*/ ctx[2].songListTags[/*index*/ ctx[1]].isExpanded)) {
    				set_custom_element_data(tag_aligns, "data-is-active", tag_aligns_data_is_active_value);
    			}

    			if (!current || dirty & /*index, songListTagsVar*/ 2) {
    				attr_dev(li, "data-index", /*index*/ ctx[1]);
    			}

    			if (!current || dirty & /*tag*/ 1 && li_data_align_value !== (li_data_align_value = /*tag*/ ctx[0].align)) {
    				attr_dev(li, "data-align", li_data_align_value);
    			}

    			if (!current || dirty & /*tag*/ 1 && li_data_is_expanded_value !== (li_data_is_expanded_value = /*tag*/ ctx[0].isExpanded)) {
    				attr_dev(li, "data-is-expanded", li_data_is_expanded_value);
    			}

    			if (!current || dirty & /*tag*/ 1 && li_data_value_value !== (li_data_value_value = /*tag*/ ctx[0].value)) {
    				attr_dev(li, "data-value", li_data_value_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(moveicon.$$.fragment, local);
    			transition_in(deleteicon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(moveicon.$$.fragment, local);
    			transition_out(deleteicon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			/*$$binding_groups*/ ctx[9][0].splice(/*$$binding_groups*/ ctx[9][0].indexOf(input1), 1);
    			/*$$binding_groups*/ ctx[9][0].splice(/*$$binding_groups*/ ctx[9][0].indexOf(input2), 1);
    			/*$$binding_groups*/ ctx[9][0].splice(/*$$binding_groups*/ ctx[9][0].indexOf(input3), 1);
    			destroy_component(moveicon);
    			destroy_component(deleteicon);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(33:0) {#if tag.value !== 'DynamicArtists'}",
    		ctx
    	});

    	return block;
    }

    // (38:4) {#if !$songListTagsValuesStore.includes(tag.value)}
    function create_if_block_1$2(ctx) {
    	let option;
    	let t_value = /*tag*/ ctx[0].name + "";
    	let t;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = /*tag*/ ctx[0].value;
    			option.value = option.__value;
    			attr_dev(option, "checked", false);
    			attr_dev(option, "class", "svelte-19te95b");
    			add_location(option, file$b, 38, 5, 1736);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(38:4) {#if !$songListTagsValuesStore.includes(tag.value)}",
    		ctx
    	});

    	return block;
    }

    // (37:3) {#each songListTagsVar as tag, index (index)}
    function create_each_block$4(key_1, ctx) {
    	let first;
    	let show_if = !/*$songListTagsValuesStore*/ ctx[3].includes(/*tag*/ ctx[0].value);
    	let if_block_anchor;
    	let if_block = show_if && create_if_block_1$2(ctx);

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*$songListTagsValuesStore*/ 8) show_if = !/*$songListTagsValuesStore*/ ctx[3].includes(/*tag*/ ctx[0].value);

    			if (show_if) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1$2(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$4.name,
    		type: "each",
    		source: "(37:3) {#each songListTagsVar as tag, index (index)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$e(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$3, create_else_block$2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*tag*/ ctx[0].value !== 'DynamicArtists') return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let $config;
    	let $songListTagsValuesStore;
    	validate_store(config, 'config');
    	component_subscribe($$self, config, $$value => $$invalidate(2, $config = $$value));
    	validate_store(songListTagsValuesStore, 'songListTagsValuesStore');
    	component_subscribe($$self, songListTagsValuesStore, $$value => $$invalidate(3, $songListTagsValuesStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SelectedTag', slots, []);
    	let { tag } = $$props;
    	let { index } = $$props;

    	function getTagNameFromValue(value) {
    		var _a;

    		return (_a = songListTagsVar.find(tag => tag.value === value)) === null || _a === void 0
    		? void 0
    		: _a.name;
    	}

    	function removeTagFromTagList(tagIndex) {
    		// Remove tag from config
    		$config.songListTags.splice(tagIndex, 1);

    		// Find Dynamic Artists and Title tag index
    		let dynamicArtistsTagIndex = $config.songListTags.findIndex(tag => tag.value === 'DynamicArtists');

    		let titleTagIndex = $config.songListTags.findIndex(tag => tag.value === 'Title');

    		// If Dynamic Artists tag is found but Title is NOT found, remove Dynamic Artists tag
    		if (dynamicArtistsTagIndex !== -1 && titleTagIndex === -1) {
    			$config.songListTags.splice(dynamicArtistsTagIndex, 1);
    		}

    		if ($config.songListTags.length === 0) {
    			$config.songListTags.push({
    				value: 'Album',
    				isExpanded: false,
    				align: 'center'
    			});
    		}

    		config.set($config);
    	}

    	const writable_props = ['tag', 'index'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SelectedTag> was created with unknown prop '${key}'`);
    	});

    	const $$binding_groups = [[]];

    	function select_change_handler() {
    		$config.songListTags[index].value = select_value(this);
    		config.set($config);
    	}

    	function input0_change_handler() {
    		$config.songListTags[index].isExpanded = this.checked;
    		config.set($config);
    	}

    	function input1_change_handler() {
    		$config.songListTags[index].align = this.__value;
    		config.set($config);
    	}

    	function input2_change_handler() {
    		$config.songListTags[index].align = this.__value;
    		config.set($config);
    	}

    	function input3_change_handler() {
    		$config.songListTags[index].align = this.__value;
    		config.set($config);
    	}

    	const click_handler = () => {
    		removeTagFromTagList(index);
    	};

    	$$self.$$set = $$props => {
    		if ('tag' in $$props) $$invalidate(0, tag = $$props.tag);
    		if ('index' in $$props) $$invalidate(1, index = $$props.index);
    	};

    	$$self.$capture_state = () => ({
    		songListTagsVar,
    		DeleteIcon,
    		MoveIcon,
    		config,
    		songListTagsValuesStore,
    		tag,
    		index,
    		getTagNameFromValue,
    		removeTagFromTagList,
    		$config,
    		$songListTagsValuesStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('tag' in $$props) $$invalidate(0, tag = $$props.tag);
    		if ('index' in $$props) $$invalidate(1, index = $$props.index);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		tag,
    		index,
    		$config,
    		$songListTagsValuesStore,
    		getTagNameFromValue,
    		removeTagFromTagList,
    		select_change_handler,
    		input0_change_handler,
    		input1_change_handler,
    		$$binding_groups,
    		input2_change_handler,
    		input3_change_handler,
    		click_handler
    	];
    }

    class SelectedTag extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$e, create_fragment$e, safe_not_equal, { tag: 0, index: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SelectedTag",
    			options,
    			id: create_fragment$e.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*tag*/ ctx[0] === undefined && !('tag' in props)) {
    			console.warn("<SelectedTag> was created without expected prop 'tag'");
    		}

    		if (/*index*/ ctx[1] === undefined && !('index' in props)) {
    			console.warn("<SelectedTag> was created without expected prop 'index'");
    		}
    	}

    	get tag() {
    		throw new Error("<SelectedTag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tag(value) {
    		throw new Error("<SelectedTag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get index() {
    		throw new Error("<SelectedTag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set index(value) {
    		throw new Error("<SelectedTag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /**!
     * Sortable 1.15.0
     * @author	RubaXa   <trash@rubaxa.org>
     * @author	owenm    <owen23355@gmail.com>
     * @license MIT
     */
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);

      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);

        if (enumerableOnly) {
          symbols = symbols.filter(function (sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        }

        keys.push.apply(keys, symbols);
      }

      return keys;
    }

    function _objectSpread2(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};

        if (i % 2) {
          ownKeys(Object(source), true).forEach(function (key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function (key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }

      return target;
    }

    function _typeof(obj) {
      "@babel/helpers - typeof";

      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function (obj) {
          return typeof obj;
        };
      } else {
        _typeof = function (obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
      }

      return _typeof(obj);
    }

    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    function _extends() {
      _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];

          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }

        return target;
      };

      return _extends.apply(this, arguments);
    }

    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null) return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;

      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
      }

      return target;
    }

    function _objectWithoutProperties(source, excluded) {
      if (source == null) return {};

      var target = _objectWithoutPropertiesLoose(source, excluded);

      var key, i;

      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

        for (i = 0; i < sourceSymbolKeys.length; i++) {
          key = sourceSymbolKeys[i];
          if (excluded.indexOf(key) >= 0) continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
          target[key] = source[key];
        }
      }

      return target;
    }

    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }

    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) return _arrayLikeToArray(arr);
    }

    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
    }

    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }

    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;

      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

      return arr2;
    }

    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var version = "1.15.0";

    function userAgent(pattern) {
      if (typeof window !== 'undefined' && window.navigator) {
        return !! /*@__PURE__*/navigator.userAgent.match(pattern);
      }
    }

    var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
    var Edge = userAgent(/Edge/i);
    var FireFox = userAgent(/firefox/i);
    var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
    var IOS = userAgent(/iP(ad|od|hone)/i);
    var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);

    var captureMode = {
      capture: false,
      passive: false
    };

    function on(el, event, fn) {
      el.addEventListener(event, fn, !IE11OrLess && captureMode);
    }

    function off(el, event, fn) {
      el.removeEventListener(event, fn, !IE11OrLess && captureMode);
    }

    function matches(
    /**HTMLElement*/
    el,
    /**String*/
    selector) {
      if (!selector) return;
      selector[0] === '>' && (selector = selector.substring(1));

      if (el) {
        try {
          if (el.matches) {
            return el.matches(selector);
          } else if (el.msMatchesSelector) {
            return el.msMatchesSelector(selector);
          } else if (el.webkitMatchesSelector) {
            return el.webkitMatchesSelector(selector);
          }
        } catch (_) {
          return false;
        }
      }

      return false;
    }

    function getParentOrHost(el) {
      return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
    }

    function closest(
    /**HTMLElement*/
    el,
    /**String*/
    selector,
    /**HTMLElement*/
    ctx, includeCTX) {
      if (el) {
        ctx = ctx || document;

        do {
          if (selector != null && (selector[0] === '>' ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
            return el;
          }

          if (el === ctx) break;
          /* jshint boss:true */
        } while (el = getParentOrHost(el));
      }

      return null;
    }

    var R_SPACE = /\s+/g;

    function toggleClass(el, name, state) {
      if (el && name) {
        if (el.classList) {
          el.classList[state ? 'add' : 'remove'](name);
        } else {
          var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');
          el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');
        }
      }
    }

    function css(el, prop, val) {
      var style = el && el.style;

      if (style) {
        if (val === void 0) {
          if (document.defaultView && document.defaultView.getComputedStyle) {
            val = document.defaultView.getComputedStyle(el, '');
          } else if (el.currentStyle) {
            val = el.currentStyle;
          }

          return prop === void 0 ? val : val[prop];
        } else {
          if (!(prop in style) && prop.indexOf('webkit') === -1) {
            prop = '-webkit-' + prop;
          }

          style[prop] = val + (typeof val === 'string' ? '' : 'px');
        }
      }
    }

    function matrix(el, selfOnly) {
      var appliedTransforms = '';

      if (typeof el === 'string') {
        appliedTransforms = el;
      } else {
        do {
          var transform = css(el, 'transform');

          if (transform && transform !== 'none') {
            appliedTransforms = transform + ' ' + appliedTransforms;
          }
          /* jshint boss:true */

        } while (!selfOnly && (el = el.parentNode));
      }

      var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
      /*jshint -W056 */

      return matrixFn && new matrixFn(appliedTransforms);
    }

    function find(ctx, tagName, iterator) {
      if (ctx) {
        var list = ctx.getElementsByTagName(tagName),
            i = 0,
            n = list.length;

        if (iterator) {
          for (; i < n; i++) {
            iterator(list[i], i);
          }
        }

        return list;
      }

      return [];
    }

    function getWindowScrollingElement() {
      var scrollingElement = document.scrollingElement;

      if (scrollingElement) {
        return scrollingElement;
      } else {
        return document.documentElement;
      }
    }
    /**
     * Returns the "bounding client rect" of given element
     * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted
     * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container
     * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr
     * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone
     * @param  {[HTMLElement]} container              The parent the element will be placed in
     * @return {Object}                               The boundingClientRect of el, with specified adjustments
     */


    function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
      if (!el.getBoundingClientRect && el !== window) return;
      var elRect, top, left, bottom, right, height, width;

      if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
        elRect = el.getBoundingClientRect();
        top = elRect.top;
        left = elRect.left;
        bottom = elRect.bottom;
        right = elRect.right;
        height = elRect.height;
        width = elRect.width;
      } else {
        top = 0;
        left = 0;
        bottom = window.innerHeight;
        right = window.innerWidth;
        height = window.innerHeight;
        width = window.innerWidth;
      }

      if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
        // Adjust for translate()
        container = container || el.parentNode; // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)
        // Not needed on <= IE11

        if (!IE11OrLess) {
          do {
            if (container && container.getBoundingClientRect && (css(container, 'transform') !== 'none' || relativeToNonStaticParent && css(container, 'position') !== 'static')) {
              var containerRect = container.getBoundingClientRect(); // Set relative to edges of padding box of container

              top -= containerRect.top + parseInt(css(container, 'border-top-width'));
              left -= containerRect.left + parseInt(css(container, 'border-left-width'));
              bottom = top + elRect.height;
              right = left + elRect.width;
              break;
            }
            /* jshint boss:true */

          } while (container = container.parentNode);
        }
      }

      if (undoScale && el !== window) {
        // Adjust for scale()
        var elMatrix = matrix(container || el),
            scaleX = elMatrix && elMatrix.a,
            scaleY = elMatrix && elMatrix.d;

        if (elMatrix) {
          top /= scaleY;
          left /= scaleX;
          width /= scaleX;
          height /= scaleY;
          bottom = top + height;
          right = left + width;
        }
      }

      return {
        top: top,
        left: left,
        bottom: bottom,
        right: right,
        width: width,
        height: height
      };
    }
    /**
     * Checks if a side of an element is scrolled past a side of its parents
     * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question
     * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')
     * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')
     * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element
     */


    function isScrolledPast(el, elSide, parentSide) {
      var parent = getParentAutoScrollElement(el, true),
          elSideVal = getRect(el)[elSide];
      /* jshint boss:true */

      while (parent) {
        var parentSideVal = getRect(parent)[parentSide],
            visible = void 0;

        if (parentSide === 'top' || parentSide === 'left') {
          visible = elSideVal >= parentSideVal;
        } else {
          visible = elSideVal <= parentSideVal;
        }

        if (!visible) return parent;
        if (parent === getWindowScrollingElement()) break;
        parent = getParentAutoScrollElement(parent, false);
      }

      return false;
    }
    /**
     * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)
     * and non-draggable elements
     * @param  {HTMLElement} el       The parent element
     * @param  {Number} childNum      The index of the child
     * @param  {Object} options       Parent Sortable's options
     * @return {HTMLElement}          The child at index childNum, or null if not found
     */


    function getChild(el, childNum, options, includeDragEl) {
      var currentChild = 0,
          i = 0,
          children = el.children;

      while (i < children.length) {
        if (children[i].style.display !== 'none' && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el, false)) {
          if (currentChild === childNum) {
            return children[i];
          }

          currentChild++;
        }

        i++;
      }

      return null;
    }
    /**
     * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)
     * @param  {HTMLElement} el       Parent element
     * @param  {selector} selector    Any other elements that should be ignored
     * @return {HTMLElement}          The last child, ignoring ghostEl
     */


    function lastChild(el, selector) {
      var last = el.lastElementChild;

      while (last && (last === Sortable.ghost || css(last, 'display') === 'none' || selector && !matches(last, selector))) {
        last = last.previousElementSibling;
      }

      return last || null;
    }
    /**
     * Returns the index of an element within its parent for a selected set of
     * elements
     * @param  {HTMLElement} el
     * @param  {selector} selector
     * @return {number}
     */


    function index(el, selector) {
      var index = 0;

      if (!el || !el.parentNode) {
        return -1;
      }
      /* jshint boss:true */


      while (el = el.previousElementSibling) {
        if (el.nodeName.toUpperCase() !== 'TEMPLATE' && el !== Sortable.clone && (!selector || matches(el, selector))) {
          index++;
        }
      }

      return index;
    }
    /**
     * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.
     * The value is returned in real pixels.
     * @param  {HTMLElement} el
     * @return {Array}             Offsets in the format of [left, top]
     */


    function getRelativeScrollOffset(el) {
      var offsetLeft = 0,
          offsetTop = 0,
          winScroller = getWindowScrollingElement();

      if (el) {
        do {
          var elMatrix = matrix(el),
              scaleX = elMatrix.a,
              scaleY = elMatrix.d;
          offsetLeft += el.scrollLeft * scaleX;
          offsetTop += el.scrollTop * scaleY;
        } while (el !== winScroller && (el = el.parentNode));
      }

      return [offsetLeft, offsetTop];
    }
    /**
     * Returns the index of the object within the given array
     * @param  {Array} arr   Array that may or may not hold the object
     * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find
     * @return {Number}      The index of the object in the array, or -1
     */


    function indexOfObject(arr, obj) {
      for (var i in arr) {
        if (!arr.hasOwnProperty(i)) continue;

        for (var key in obj) {
          if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);
        }
      }

      return -1;
    }

    function getParentAutoScrollElement(el, includeSelf) {
      // skip to window
      if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();
      var elem = el;
      var gotSelf = false;

      do {
        // we don't need to get elem css if it isn't even overflowing in the first place (performance)
        if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
          var elemCSS = css(elem);

          if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')) {
            if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();
            if (gotSelf || includeSelf) return elem;
            gotSelf = true;
          }
        }
        /* jshint boss:true */

      } while (elem = elem.parentNode);

      return getWindowScrollingElement();
    }

    function extend(dst, src) {
      if (dst && src) {
        for (var key in src) {
          if (src.hasOwnProperty(key)) {
            dst[key] = src[key];
          }
        }
      }

      return dst;
    }

    function isRectEqual(rect1, rect2) {
      return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
    }

    var _throttleTimeout;

    function throttle(callback, ms) {
      return function () {
        if (!_throttleTimeout) {
          var args = arguments,
              _this = this;

          if (args.length === 1) {
            callback.call(_this, args[0]);
          } else {
            callback.apply(_this, args);
          }

          _throttleTimeout = setTimeout(function () {
            _throttleTimeout = void 0;
          }, ms);
        }
      };
    }

    function cancelThrottle() {
      clearTimeout(_throttleTimeout);
      _throttleTimeout = void 0;
    }

    function scrollBy(el, x, y) {
      el.scrollLeft += x;
      el.scrollTop += y;
    }

    function clone(el) {
      var Polymer = window.Polymer;
      var $ = window.jQuery || window.Zepto;

      if (Polymer && Polymer.dom) {
        return Polymer.dom(el).cloneNode(true);
      } else if ($) {
        return $(el).clone(true)[0];
      } else {
        return el.cloneNode(true);
      }
    }

    function setRect(el, rect) {
      css(el, 'position', 'absolute');
      css(el, 'top', rect.top);
      css(el, 'left', rect.left);
      css(el, 'width', rect.width);
      css(el, 'height', rect.height);
    }

    function unsetRect(el) {
      css(el, 'position', '');
      css(el, 'top', '');
      css(el, 'left', '');
      css(el, 'width', '');
      css(el, 'height', '');
    }

    var expando = 'Sortable' + new Date().getTime();

    function AnimationStateManager() {
      var animationStates = [],
          animationCallbackId;
      return {
        captureAnimationState: function captureAnimationState() {
          animationStates = [];
          if (!this.options.animation) return;
          var children = [].slice.call(this.el.children);
          children.forEach(function (child) {
            if (css(child, 'display') === 'none' || child === Sortable.ghost) return;
            animationStates.push({
              target: child,
              rect: getRect(child)
            });

            var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect); // If animating: compensate for current animation


            if (child.thisAnimationDuration) {
              var childMatrix = matrix(child, true);

              if (childMatrix) {
                fromRect.top -= childMatrix.f;
                fromRect.left -= childMatrix.e;
              }
            }

            child.fromRect = fromRect;
          });
        },
        addAnimationState: function addAnimationState(state) {
          animationStates.push(state);
        },
        removeAnimationState: function removeAnimationState(target) {
          animationStates.splice(indexOfObject(animationStates, {
            target: target
          }), 1);
        },
        animateAll: function animateAll(callback) {
          var _this = this;

          if (!this.options.animation) {
            clearTimeout(animationCallbackId);
            if (typeof callback === 'function') callback();
            return;
          }

          var animating = false,
              animationTime = 0;
          animationStates.forEach(function (state) {
            var time = 0,
                target = state.target,
                fromRect = target.fromRect,
                toRect = getRect(target),
                prevFromRect = target.prevFromRect,
                prevToRect = target.prevToRect,
                animatingRect = state.rect,
                targetMatrix = matrix(target, true);

            if (targetMatrix) {
              // Compensate for current animation
              toRect.top -= targetMatrix.f;
              toRect.left -= targetMatrix.e;
            }

            target.toRect = toRect;

            if (target.thisAnimationDuration) {
              // Could also check if animatingRect is between fromRect and toRect
              if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect
              (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
                // If returning to same place as started from animation and on same axis
                time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
              }
            } // if fromRect != toRect: animate


            if (!isRectEqual(toRect, fromRect)) {
              target.prevFromRect = fromRect;
              target.prevToRect = toRect;

              if (!time) {
                time = _this.options.animation;
              }

              _this.animate(target, animatingRect, toRect, time);
            }

            if (time) {
              animating = true;
              animationTime = Math.max(animationTime, time);
              clearTimeout(target.animationResetTimer);
              target.animationResetTimer = setTimeout(function () {
                target.animationTime = 0;
                target.prevFromRect = null;
                target.fromRect = null;
                target.prevToRect = null;
                target.thisAnimationDuration = null;
              }, time);
              target.thisAnimationDuration = time;
            }
          });
          clearTimeout(animationCallbackId);

          if (!animating) {
            if (typeof callback === 'function') callback();
          } else {
            animationCallbackId = setTimeout(function () {
              if (typeof callback === 'function') callback();
            }, animationTime);
          }

          animationStates = [];
        },
        animate: function animate(target, currentRect, toRect, duration) {
          if (duration) {
            css(target, 'transition', '');
            css(target, 'transform', '');
            var elMatrix = matrix(this.el),
                scaleX = elMatrix && elMatrix.a,
                scaleY = elMatrix && elMatrix.d,
                translateX = (currentRect.left - toRect.left) / (scaleX || 1),
                translateY = (currentRect.top - toRect.top) / (scaleY || 1);
            target.animatingX = !!translateX;
            target.animatingY = !!translateY;
            css(target, 'transform', 'translate3d(' + translateX + 'px,' + translateY + 'px,0)');
            this.forRepaintDummy = repaint(target); // repaint

            css(target, 'transition', 'transform ' + duration + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));
            css(target, 'transform', 'translate3d(0,0,0)');
            typeof target.animated === 'number' && clearTimeout(target.animated);
            target.animated = setTimeout(function () {
              css(target, 'transition', '');
              css(target, 'transform', '');
              target.animated = false;
              target.animatingX = false;
              target.animatingY = false;
            }, duration);
          }
        }
      };
    }

    function repaint(target) {
      return target.offsetWidth;
    }

    function calculateRealTime(animatingRect, fromRect, toRect, options) {
      return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
    }

    var plugins = [];
    var defaults = {
      initializeByDefault: true
    };
    var PluginManager = {
      mount: function mount(plugin) {
        // Set default static properties
        for (var option in defaults) {
          if (defaults.hasOwnProperty(option) && !(option in plugin)) {
            plugin[option] = defaults[option];
          }
        }

        plugins.forEach(function (p) {
          if (p.pluginName === plugin.pluginName) {
            throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
          }
        });
        plugins.push(plugin);
      },
      pluginEvent: function pluginEvent(eventName, sortable, evt) {
        var _this = this;

        this.eventCanceled = false;

        evt.cancel = function () {
          _this.eventCanceled = true;
        };

        var eventNameGlobal = eventName + 'Global';
        plugins.forEach(function (plugin) {
          if (!sortable[plugin.pluginName]) return; // Fire global events if it exists in this sortable

          if (sortable[plugin.pluginName][eventNameGlobal]) {
            sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
              sortable: sortable
            }, evt));
          } // Only fire plugin event if plugin is enabled in this sortable,
          // and plugin has event defined


          if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
            sortable[plugin.pluginName][eventName](_objectSpread2({
              sortable: sortable
            }, evt));
          }
        });
      },
      initializePlugins: function initializePlugins(sortable, el, defaults, options) {
        plugins.forEach(function (plugin) {
          var pluginName = plugin.pluginName;
          if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;
          var initialized = new plugin(sortable, el, sortable.options);
          initialized.sortable = sortable;
          initialized.options = sortable.options;
          sortable[pluginName] = initialized; // Add default options from plugin

          _extends(defaults, initialized.defaults);
        });

        for (var option in sortable.options) {
          if (!sortable.options.hasOwnProperty(option)) continue;
          var modified = this.modifyOption(sortable, option, sortable.options[option]);

          if (typeof modified !== 'undefined') {
            sortable.options[option] = modified;
          }
        }
      },
      getEventProperties: function getEventProperties(name, sortable) {
        var eventProperties = {};
        plugins.forEach(function (plugin) {
          if (typeof plugin.eventProperties !== 'function') return;

          _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
        });
        return eventProperties;
      },
      modifyOption: function modifyOption(sortable, name, value) {
        var modifiedValue;
        plugins.forEach(function (plugin) {
          // Plugin must exist on the Sortable
          if (!sortable[plugin.pluginName]) return; // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin

          if (plugin.optionListeners && typeof plugin.optionListeners[name] === 'function') {
            modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
          }
        });
        return modifiedValue;
      }
    };

    function dispatchEvent$1(_ref) {
      var sortable = _ref.sortable,
          rootEl = _ref.rootEl,
          name = _ref.name,
          targetEl = _ref.targetEl,
          cloneEl = _ref.cloneEl,
          toEl = _ref.toEl,
          fromEl = _ref.fromEl,
          oldIndex = _ref.oldIndex,
          newIndex = _ref.newIndex,
          oldDraggableIndex = _ref.oldDraggableIndex,
          newDraggableIndex = _ref.newDraggableIndex,
          originalEvent = _ref.originalEvent,
          putSortable = _ref.putSortable,
          extraEventProperties = _ref.extraEventProperties;
      sortable = sortable || rootEl && rootEl[expando];
      if (!sortable) return;
      var evt,
          options = sortable.options,
          onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1); // Support for new CustomEvent feature

      if (window.CustomEvent && !IE11OrLess && !Edge) {
        evt = new CustomEvent(name, {
          bubbles: true,
          cancelable: true
        });
      } else {
        evt = document.createEvent('Event');
        evt.initEvent(name, true, true);
      }

      evt.to = toEl || rootEl;
      evt.from = fromEl || rootEl;
      evt.item = targetEl || rootEl;
      evt.clone = cloneEl;
      evt.oldIndex = oldIndex;
      evt.newIndex = newIndex;
      evt.oldDraggableIndex = oldDraggableIndex;
      evt.newDraggableIndex = newDraggableIndex;
      evt.originalEvent = originalEvent;
      evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;

      var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));

      for (var option in allEventProperties) {
        evt[option] = allEventProperties[option];
      }

      if (rootEl) {
        rootEl.dispatchEvent(evt);
      }

      if (options[onName]) {
        options[onName].call(sortable, evt);
      }
    }

    var _excluded = ["evt"];

    var pluginEvent = function pluginEvent(eventName, sortable) {
      var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
          originalEvent = _ref.evt,
          data = _objectWithoutProperties(_ref, _excluded);

      PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
        dragEl: dragEl,
        parentEl: parentEl,
        ghostEl: ghostEl,
        rootEl: rootEl,
        nextEl: nextEl,
        lastDownEl: lastDownEl,
        cloneEl: cloneEl,
        cloneHidden: cloneHidden,
        dragStarted: moved,
        putSortable: putSortable,
        activeSortable: Sortable.active,
        originalEvent: originalEvent,
        oldIndex: oldIndex,
        oldDraggableIndex: oldDraggableIndex,
        newIndex: newIndex,
        newDraggableIndex: newDraggableIndex,
        hideGhostForTarget: _hideGhostForTarget,
        unhideGhostForTarget: _unhideGhostForTarget,
        cloneNowHidden: function cloneNowHidden() {
          cloneHidden = true;
        },
        cloneNowShown: function cloneNowShown() {
          cloneHidden = false;
        },
        dispatchSortableEvent: function dispatchSortableEvent(name) {
          _dispatchEvent({
            sortable: sortable,
            name: name,
            originalEvent: originalEvent
          });
        }
      }, data));
    };

    function _dispatchEvent(info) {
      dispatchEvent$1(_objectSpread2({
        putSortable: putSortable,
        cloneEl: cloneEl,
        targetEl: dragEl,
        rootEl: rootEl,
        oldIndex: oldIndex,
        oldDraggableIndex: oldDraggableIndex,
        newIndex: newIndex,
        newDraggableIndex: newDraggableIndex
      }, info));
    }

    var dragEl,
        parentEl,
        ghostEl,
        rootEl,
        nextEl,
        lastDownEl,
        cloneEl,
        cloneHidden,
        oldIndex,
        newIndex,
        oldDraggableIndex,
        newDraggableIndex,
        activeGroup,
        putSortable,
        awaitingDragStarted = false,
        ignoreNextClick = false,
        sortables = [],
        tapEvt,
        touchEvt,
        lastDx,
        lastDy,
        tapDistanceLeft,
        tapDistanceTop,
        moved,
        lastTarget,
        lastDirection,
        pastFirstInvertThresh = false,
        isCircumstantialInvert = false,
        targetMoveDistance,
        // For positioning ghost absolutely
    ghostRelativeParent,
        ghostRelativeParentInitialScroll = [],
        // (left, top)
    _silent = false,
        savedInputChecked = [];
    /** @const */

    var documentExists = typeof document !== 'undefined',
        PositionGhostAbsolutely = IOS,
        CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',
        // This will not pass for IE9, because IE9 DnD only works on anchors
    supportDraggable = documentExists && !ChromeForAndroid && !IOS && 'draggable' in document.createElement('div'),
        supportCssPointerEvents = function () {
      if (!documentExists) return; // false when <= IE11

      if (IE11OrLess) {
        return false;
      }

      var el = document.createElement('x');
      el.style.cssText = 'pointer-events:auto';
      return el.style.pointerEvents === 'auto';
    }(),
        _detectDirection = function _detectDirection(el, options) {
      var elCSS = css(el),
          elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth),
          child1 = getChild(el, 0, options),
          child2 = getChild(el, 1, options),
          firstChildCSS = child1 && css(child1),
          secondChildCSS = child2 && css(child2),
          firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width,
          secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;

      if (elCSS.display === 'flex') {
        return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse' ? 'vertical' : 'horizontal';
      }

      if (elCSS.display === 'grid') {
        return elCSS.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal';
      }

      if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== 'none') {
        var touchingSideChild2 = firstChildCSS["float"] === 'left' ? 'left' : 'right';
        return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ? 'vertical' : 'horizontal';
      }

      return child1 && (firstChildCSS.display === 'block' || firstChildCSS.display === 'flex' || firstChildCSS.display === 'table' || firstChildCSS.display === 'grid' || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === 'none' || child2 && elCSS[CSSFloatProperty] === 'none' && firstChildWidth + secondChildWidth > elWidth) ? 'vertical' : 'horizontal';
    },
        _dragElInRowColumn = function _dragElInRowColumn(dragRect, targetRect, vertical) {
      var dragElS1Opp = vertical ? dragRect.left : dragRect.top,
          dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,
          dragElOppLength = vertical ? dragRect.width : dragRect.height,
          targetS1Opp = vertical ? targetRect.left : targetRect.top,
          targetS2Opp = vertical ? targetRect.right : targetRect.bottom,
          targetOppLength = vertical ? targetRect.width : targetRect.height;
      return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
    },

    /**
     * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.
     * @param  {Number} x      X position
     * @param  {Number} y      Y position
     * @return {HTMLElement}   Element of the first found nearest Sortable
     */
    _detectNearestEmptySortable = function _detectNearestEmptySortable(x, y) {
      var ret;
      sortables.some(function (sortable) {
        var threshold = sortable[expando].options.emptyInsertThreshold;
        if (!threshold || lastChild(sortable)) return;
        var rect = getRect(sortable),
            insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold,
            insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;

        if (insideHorizontally && insideVertically) {
          return ret = sortable;
        }
      });
      return ret;
    },
        _prepareGroup = function _prepareGroup(options) {
      function toFn(value, pull) {
        return function (to, from, dragEl, evt) {
          var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;

          if (value == null && (pull || sameGroup)) {
            // Default pull value
            // Default pull and put value if same group
            return true;
          } else if (value == null || value === false) {
            return false;
          } else if (pull && value === 'clone') {
            return value;
          } else if (typeof value === 'function') {
            return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);
          } else {
            var otherGroup = (pull ? to : from).options.group.name;
            return value === true || typeof value === 'string' && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
          }
        };
      }

      var group = {};
      var originalGroup = options.group;

      if (!originalGroup || _typeof(originalGroup) != 'object') {
        originalGroup = {
          name: originalGroup
        };
      }

      group.name = originalGroup.name;
      group.checkPull = toFn(originalGroup.pull, true);
      group.checkPut = toFn(originalGroup.put);
      group.revertClone = originalGroup.revertClone;
      options.group = group;
    },
        _hideGhostForTarget = function _hideGhostForTarget() {
      if (!supportCssPointerEvents && ghostEl) {
        css(ghostEl, 'display', 'none');
      }
    },
        _unhideGhostForTarget = function _unhideGhostForTarget() {
      if (!supportCssPointerEvents && ghostEl) {
        css(ghostEl, 'display', '');
      }
    }; // #1184 fix - Prevent click event on fallback if dragged but item not changed position


    if (documentExists && !ChromeForAndroid) {
      document.addEventListener('click', function (evt) {
        if (ignoreNextClick) {
          evt.preventDefault();
          evt.stopPropagation && evt.stopPropagation();
          evt.stopImmediatePropagation && evt.stopImmediatePropagation();
          ignoreNextClick = false;
          return false;
        }
      }, true);
    }

    var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(evt) {
      if (dragEl) {
        evt = evt.touches ? evt.touches[0] : evt;

        var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);

        if (nearest) {
          // Create imitation event
          var event = {};

          for (var i in evt) {
            if (evt.hasOwnProperty(i)) {
              event[i] = evt[i];
            }
          }

          event.target = event.rootEl = nearest;
          event.preventDefault = void 0;
          event.stopPropagation = void 0;

          nearest[expando]._onDragOver(event);
        }
      }
    };

    var _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {
      if (dragEl) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
      }
    };
    /**
     * @class  Sortable
     * @param  {HTMLElement}  el
     * @param  {Object}       [options]
     */


    function Sortable(el, options) {
      if (!(el && el.nodeType && el.nodeType === 1)) {
        throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
      }

      this.el = el; // root element

      this.options = options = _extends({}, options); // Export instance

      el[expando] = this;
      var defaults = {
        group: null,
        sort: true,
        disabled: false,
        store: null,
        handle: null,
        draggable: /^[uo]l$/i.test(el.nodeName) ? '>li' : '>*',
        swapThreshold: 1,
        // percentage; 0 <= x <= 1
        invertSwap: false,
        // invert always
        invertedSwapThreshold: null,
        // will be set to same as swapThreshold if default
        removeCloneOnHide: true,
        direction: function direction() {
          return _detectDirection(el, this.options);
        },
        ghostClass: 'sortable-ghost',
        chosenClass: 'sortable-chosen',
        dragClass: 'sortable-drag',
        ignore: 'a, img',
        filter: null,
        preventOnFilter: true,
        animation: 0,
        easing: null,
        setData: function setData(dataTransfer, dragEl) {
          dataTransfer.setData('Text', dragEl.textContent);
        },
        dropBubble: false,
        dragoverBubble: false,
        dataIdAttr: 'data-id',
        delay: 0,
        delayOnTouchOnly: false,
        touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
        forceFallback: false,
        fallbackClass: 'sortable-fallback',
        fallbackOnBody: false,
        fallbackTolerance: 0,
        fallbackOffset: {
          x: 0,
          y: 0
        },
        supportPointer: Sortable.supportPointer !== false && 'PointerEvent' in window && !Safari,
        emptyInsertThreshold: 5
      };
      PluginManager.initializePlugins(this, el, defaults); // Set default options

      for (var name in defaults) {
        !(name in options) && (options[name] = defaults[name]);
      }

      _prepareGroup(options); // Bind all private methods


      for (var fn in this) {
        if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
          this[fn] = this[fn].bind(this);
        }
      } // Setup drag mode


      this.nativeDraggable = options.forceFallback ? false : supportDraggable;

      if (this.nativeDraggable) {
        // Touch start threshold cannot be greater than the native dragstart threshold
        this.options.touchStartThreshold = 1;
      } // Bind events


      if (options.supportPointer) {
        on(el, 'pointerdown', this._onTapStart);
      } else {
        on(el, 'mousedown', this._onTapStart);
        on(el, 'touchstart', this._onTapStart);
      }

      if (this.nativeDraggable) {
        on(el, 'dragover', this);
        on(el, 'dragenter', this);
      }

      sortables.push(this.el); // Restore sorting

      options.store && options.store.get && this.sort(options.store.get(this) || []); // Add animation state manager

      _extends(this, AnimationStateManager());
    }

    Sortable.prototype =
    /** @lends Sortable.prototype */
    {
      constructor: Sortable,
      _isOutsideThisEl: function _isOutsideThisEl(target) {
        if (!this.el.contains(target) && target !== this.el) {
          lastTarget = null;
        }
      },
      _getDirection: function _getDirection(evt, target) {
        return typeof this.options.direction === 'function' ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
      },
      _onTapStart: function _onTapStart(
      /** Event|TouchEvent */
      evt) {
        if (!evt.cancelable) return;

        var _this = this,
            el = this.el,
            options = this.options,
            preventOnFilter = options.preventOnFilter,
            type = evt.type,
            touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === 'touch' && evt,
            target = (touch || evt).target,
            originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target,
            filter = options.filter;

        _saveInputCheckedState(el); // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.


        if (dragEl) {
          return;
        }

        if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
          return; // only left button and enabled
        } // cancel dnd if original target is content editable


        if (originalTarget.isContentEditable) {
          return;
        } // Safari ignores further event handling after mousedown


        if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === 'SELECT') {
          return;
        }

        target = closest(target, options.draggable, el, false);

        if (target && target.animated) {
          return;
        }

        if (lastDownEl === target) {
          // Ignoring duplicate `down`
          return;
        } // Get the index of the dragged element within its parent


        oldIndex = index(target);
        oldDraggableIndex = index(target, options.draggable); // Check filter

        if (typeof filter === 'function') {
          if (filter.call(this, evt, target, this)) {
            _dispatchEvent({
              sortable: _this,
              rootEl: originalTarget,
              name: 'filter',
              targetEl: target,
              toEl: el,
              fromEl: el
            });

            pluginEvent('filter', _this, {
              evt: evt
            });
            preventOnFilter && evt.cancelable && evt.preventDefault();
            return; // cancel dnd
          }
        } else if (filter) {
          filter = filter.split(',').some(function (criteria) {
            criteria = closest(originalTarget, criteria.trim(), el, false);

            if (criteria) {
              _dispatchEvent({
                sortable: _this,
                rootEl: criteria,
                name: 'filter',
                targetEl: target,
                fromEl: el,
                toEl: el
              });

              pluginEvent('filter', _this, {
                evt: evt
              });
              return true;
            }
          });

          if (filter) {
            preventOnFilter && evt.cancelable && evt.preventDefault();
            return; // cancel dnd
          }
        }

        if (options.handle && !closest(originalTarget, options.handle, el, false)) {
          return;
        } // Prepare `dragstart`


        this._prepareDragStart(evt, touch, target);
      },
      _prepareDragStart: function _prepareDragStart(
      /** Event */
      evt,
      /** Touch */
      touch,
      /** HTMLElement */
      target) {
        var _this = this,
            el = _this.el,
            options = _this.options,
            ownerDocument = el.ownerDocument,
            dragStartFn;

        if (target && !dragEl && target.parentNode === el) {
          var dragRect = getRect(target);
          rootEl = el;
          dragEl = target;
          parentEl = dragEl.parentNode;
          nextEl = dragEl.nextSibling;
          lastDownEl = target;
          activeGroup = options.group;
          Sortable.dragged = dragEl;
          tapEvt = {
            target: dragEl,
            clientX: (touch || evt).clientX,
            clientY: (touch || evt).clientY
          };
          tapDistanceLeft = tapEvt.clientX - dragRect.left;
          tapDistanceTop = tapEvt.clientY - dragRect.top;
          this._lastX = (touch || evt).clientX;
          this._lastY = (touch || evt).clientY;
          dragEl.style['will-change'] = 'all';

          dragStartFn = function dragStartFn() {
            pluginEvent('delayEnded', _this, {
              evt: evt
            });

            if (Sortable.eventCanceled) {
              _this._onDrop();

              return;
            } // Delayed drag has been triggered
            // we can re-enable the events: touchmove/mousemove


            _this._disableDelayedDragEvents();

            if (!FireFox && _this.nativeDraggable) {
              dragEl.draggable = true;
            } // Bind the events: dragstart/dragend


            _this._triggerDragStart(evt, touch); // Drag start event


            _dispatchEvent({
              sortable: _this,
              name: 'choose',
              originalEvent: evt
            }); // Chosen item


            toggleClass(dragEl, options.chosenClass, true);
          }; // Disable "draggable"


          options.ignore.split(',').forEach(function (criteria) {
            find(dragEl, criteria.trim(), _disableDraggable);
          });
          on(ownerDocument, 'dragover', nearestEmptyInsertDetectEvent);
          on(ownerDocument, 'mousemove', nearestEmptyInsertDetectEvent);
          on(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);
          on(ownerDocument, 'mouseup', _this._onDrop);
          on(ownerDocument, 'touchend', _this._onDrop);
          on(ownerDocument, 'touchcancel', _this._onDrop); // Make dragEl draggable (must be before delay for FireFox)

          if (FireFox && this.nativeDraggable) {
            this.options.touchStartThreshold = 4;
            dragEl.draggable = true;
          }

          pluginEvent('delayStart', this, {
            evt: evt
          }); // Delay is impossible for native DnD in Edge or IE

          if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
            if (Sortable.eventCanceled) {
              this._onDrop();

              return;
            } // If the user moves the pointer or let go the click or touch
            // before the delay has been reached:
            // disable the delayed drag


            on(ownerDocument, 'mouseup', _this._disableDelayedDrag);
            on(ownerDocument, 'touchend', _this._disableDelayedDrag);
            on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);
            on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);
            on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);
            options.supportPointer && on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);
            _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
          } else {
            dragStartFn();
          }
        }
      },
      _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(
      /** TouchEvent|PointerEvent **/
      e) {
        var touch = e.touches ? e.touches[0] : e;

        if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
          this._disableDelayedDrag();
        }
      },
      _disableDelayedDrag: function _disableDelayedDrag() {
        dragEl && _disableDraggable(dragEl);
        clearTimeout(this._dragStartTimer);

        this._disableDelayedDragEvents();
      },
      _disableDelayedDragEvents: function _disableDelayedDragEvents() {
        var ownerDocument = this.el.ownerDocument;
        off(ownerDocument, 'mouseup', this._disableDelayedDrag);
        off(ownerDocument, 'touchend', this._disableDelayedDrag);
        off(ownerDocument, 'touchcancel', this._disableDelayedDrag);
        off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);
        off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);
        off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);
      },
      _triggerDragStart: function _triggerDragStart(
      /** Event */
      evt,
      /** Touch */
      touch) {
        touch = touch || evt.pointerType == 'touch' && evt;

        if (!this.nativeDraggable || touch) {
          if (this.options.supportPointer) {
            on(document, 'pointermove', this._onTouchMove);
          } else if (touch) {
            on(document, 'touchmove', this._onTouchMove);
          } else {
            on(document, 'mousemove', this._onTouchMove);
          }
        } else {
          on(dragEl, 'dragend', this);
          on(rootEl, 'dragstart', this._onDragStart);
        }

        try {
          if (document.selection) {
            // Timeout neccessary for IE9
            _nextTick(function () {
              document.selection.empty();
            });
          } else {
            window.getSelection().removeAllRanges();
          }
        } catch (err) {}
      },
      _dragStarted: function _dragStarted(fallback, evt) {

        awaitingDragStarted = false;

        if (rootEl && dragEl) {
          pluginEvent('dragStarted', this, {
            evt: evt
          });

          if (this.nativeDraggable) {
            on(document, 'dragover', _checkOutsideTargetEl);
          }

          var options = this.options; // Apply effect

          !fallback && toggleClass(dragEl, options.dragClass, false);
          toggleClass(dragEl, options.ghostClass, true);
          Sortable.active = this;
          fallback && this._appendGhost(); // Drag start event

          _dispatchEvent({
            sortable: this,
            name: 'start',
            originalEvent: evt
          });
        } else {
          this._nulling();
        }
      },
      _emulateDragOver: function _emulateDragOver() {
        if (touchEvt) {
          this._lastX = touchEvt.clientX;
          this._lastY = touchEvt.clientY;

          _hideGhostForTarget();

          var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
          var parent = target;

          while (target && target.shadowRoot) {
            target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
            if (target === parent) break;
            parent = target;
          }

          dragEl.parentNode[expando]._isOutsideThisEl(target);

          if (parent) {
            do {
              if (parent[expando]) {
                var inserted = void 0;
                inserted = parent[expando]._onDragOver({
                  clientX: touchEvt.clientX,
                  clientY: touchEvt.clientY,
                  target: target,
                  rootEl: parent
                });

                if (inserted && !this.options.dragoverBubble) {
                  break;
                }
              }

              target = parent; // store last element
            }
            /* jshint boss:true */
            while (parent = parent.parentNode);
          }

          _unhideGhostForTarget();
        }
      },
      _onTouchMove: function _onTouchMove(
      /**TouchEvent*/
      evt) {
        if (tapEvt) {
          var options = this.options,
              fallbackTolerance = options.fallbackTolerance,
              fallbackOffset = options.fallbackOffset,
              touch = evt.touches ? evt.touches[0] : evt,
              ghostMatrix = ghostEl && matrix(ghostEl, true),
              scaleX = ghostEl && ghostMatrix && ghostMatrix.a,
              scaleY = ghostEl && ghostMatrix && ghostMatrix.d,
              relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent),
              dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1),
              dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1); // only set the status to dragging, when we are actually dragging

          if (!Sortable.active && !awaitingDragStarted) {
            if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
              return;
            }

            this._onDragStart(evt, true);
          }

          if (ghostEl) {
            if (ghostMatrix) {
              ghostMatrix.e += dx - (lastDx || 0);
              ghostMatrix.f += dy - (lastDy || 0);
            } else {
              ghostMatrix = {
                a: 1,
                b: 0,
                c: 0,
                d: 1,
                e: dx,
                f: dy
              };
            }

            var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
            css(ghostEl, 'webkitTransform', cssMatrix);
            css(ghostEl, 'mozTransform', cssMatrix);
            css(ghostEl, 'msTransform', cssMatrix);
            css(ghostEl, 'transform', cssMatrix);
            lastDx = dx;
            lastDy = dy;
            touchEvt = touch;
          }

          evt.cancelable && evt.preventDefault();
        }
      },
      _appendGhost: function _appendGhost() {
        // Bug if using scale(): https://stackoverflow.com/questions/2637058
        // Not being adjusted for
        if (!ghostEl) {
          var container = this.options.fallbackOnBody ? document.body : rootEl,
              rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),
              options = this.options; // Position absolutely

          if (PositionGhostAbsolutely) {
            // Get relatively positioned parent
            ghostRelativeParent = container;

            while (css(ghostRelativeParent, 'position') === 'static' && css(ghostRelativeParent, 'transform') === 'none' && ghostRelativeParent !== document) {
              ghostRelativeParent = ghostRelativeParent.parentNode;
            }

            if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
              if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();
              rect.top += ghostRelativeParent.scrollTop;
              rect.left += ghostRelativeParent.scrollLeft;
            } else {
              ghostRelativeParent = getWindowScrollingElement();
            }

            ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
          }

          ghostEl = dragEl.cloneNode(true);
          toggleClass(ghostEl, options.ghostClass, false);
          toggleClass(ghostEl, options.fallbackClass, true);
          toggleClass(ghostEl, options.dragClass, true);
          css(ghostEl, 'transition', '');
          css(ghostEl, 'transform', '');
          css(ghostEl, 'box-sizing', 'border-box');
          css(ghostEl, 'margin', 0);
          css(ghostEl, 'top', rect.top);
          css(ghostEl, 'left', rect.left);
          css(ghostEl, 'width', rect.width);
          css(ghostEl, 'height', rect.height);
          css(ghostEl, 'opacity', '0.8');
          css(ghostEl, 'position', PositionGhostAbsolutely ? 'absolute' : 'fixed');
          css(ghostEl, 'zIndex', '100000');
          css(ghostEl, 'pointerEvents', 'none');
          Sortable.ghost = ghostEl;
          container.appendChild(ghostEl); // Set transform-origin

          css(ghostEl, 'transform-origin', tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + '% ' + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + '%');
        }
      },
      _onDragStart: function _onDragStart(
      /**Event*/
      evt,
      /**boolean*/
      fallback) {
        var _this = this;

        var dataTransfer = evt.dataTransfer;
        var options = _this.options;
        pluginEvent('dragStart', this, {
          evt: evt
        });

        if (Sortable.eventCanceled) {
          this._onDrop();

          return;
        }

        pluginEvent('setupClone', this);

        if (!Sortable.eventCanceled) {
          cloneEl = clone(dragEl);
          cloneEl.removeAttribute("id");
          cloneEl.draggable = false;
          cloneEl.style['will-change'] = '';

          this._hideClone();

          toggleClass(cloneEl, this.options.chosenClass, false);
          Sortable.clone = cloneEl;
        } // #1143: IFrame support workaround


        _this.cloneId = _nextTick(function () {
          pluginEvent('clone', _this);
          if (Sortable.eventCanceled) return;

          if (!_this.options.removeCloneOnHide) {
            rootEl.insertBefore(cloneEl, dragEl);
          }

          _this._hideClone();

          _dispatchEvent({
            sortable: _this,
            name: 'clone'
          });
        });
        !fallback && toggleClass(dragEl, options.dragClass, true); // Set proper drop events

        if (fallback) {
          ignoreNextClick = true;
          _this._loopId = setInterval(_this._emulateDragOver, 50);
        } else {
          // Undo what was set in _prepareDragStart before drag started
          off(document, 'mouseup', _this._onDrop);
          off(document, 'touchend', _this._onDrop);
          off(document, 'touchcancel', _this._onDrop);

          if (dataTransfer) {
            dataTransfer.effectAllowed = 'move';
            options.setData && options.setData.call(_this, dataTransfer, dragEl);
          }

          on(document, 'drop', _this); // #1276 fix:

          css(dragEl, 'transform', 'translateZ(0)');
        }

        awaitingDragStarted = true;
        _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
        on(document, 'selectstart', _this);
        moved = true;

        if (Safari) {
          css(document.body, 'user-select', 'none');
        }
      },
      // Returns true - if no further action is needed (either inserted or another condition)
      _onDragOver: function _onDragOver(
      /**Event*/
      evt) {
        var el = this.el,
            target = evt.target,
            dragRect,
            targetRect,
            revert,
            options = this.options,
            group = options.group,
            activeSortable = Sortable.active,
            isOwner = activeGroup === group,
            canSort = options.sort,
            fromSortable = putSortable || activeSortable,
            vertical,
            _this = this,
            completedFired = false;

        if (_silent) return;

        function dragOverEvent(name, extra) {
          pluginEvent(name, _this, _objectSpread2({
            evt: evt,
            isOwner: isOwner,
            axis: vertical ? 'vertical' : 'horizontal',
            revert: revert,
            dragRect: dragRect,
            targetRect: targetRect,
            canSort: canSort,
            fromSortable: fromSortable,
            target: target,
            completed: completed,
            onMove: function onMove(target, after) {
              return _onMove(rootEl, el, dragEl, dragRect, target, getRect(target), evt, after);
            },
            changed: changed
          }, extra));
        } // Capture animation state


        function capture() {
          dragOverEvent('dragOverAnimationCapture');

          _this.captureAnimationState();

          if (_this !== fromSortable) {
            fromSortable.captureAnimationState();
          }
        } // Return invocation when dragEl is inserted (or completed)


        function completed(insertion) {
          dragOverEvent('dragOverCompleted', {
            insertion: insertion
          });

          if (insertion) {
            // Clones must be hidden before folding animation to capture dragRectAbsolute properly
            if (isOwner) {
              activeSortable._hideClone();
            } else {
              activeSortable._showClone(_this);
            }

            if (_this !== fromSortable) {
              // Set ghost class to new sortable's ghost class
              toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
              toggleClass(dragEl, options.ghostClass, true);
            }

            if (putSortable !== _this && _this !== Sortable.active) {
              putSortable = _this;
            } else if (_this === Sortable.active && putSortable) {
              putSortable = null;
            } // Animation


            if (fromSortable === _this) {
              _this._ignoreWhileAnimating = target;
            }

            _this.animateAll(function () {
              dragOverEvent('dragOverAnimationComplete');
              _this._ignoreWhileAnimating = null;
            });

            if (_this !== fromSortable) {
              fromSortable.animateAll();
              fromSortable._ignoreWhileAnimating = null;
            }
          } // Null lastTarget if it is not inside a previously swapped element


          if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
            lastTarget = null;
          } // no bubbling and not fallback


          if (!options.dragoverBubble && !evt.rootEl && target !== document) {
            dragEl.parentNode[expando]._isOutsideThisEl(evt.target); // Do not detect for empty insert if already inserted


            !insertion && nearestEmptyInsertDetectEvent(evt);
          }

          !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
          return completedFired = true;
        } // Call when dragEl has been inserted


        function changed() {
          newIndex = index(dragEl);
          newDraggableIndex = index(dragEl, options.draggable);

          _dispatchEvent({
            sortable: _this,
            name: 'change',
            toEl: el,
            newIndex: newIndex,
            newDraggableIndex: newDraggableIndex,
            originalEvent: evt
          });
        }

        if (evt.preventDefault !== void 0) {
          evt.cancelable && evt.preventDefault();
        }

        target = closest(target, options.draggable, el, true);
        dragOverEvent('dragOver');
        if (Sortable.eventCanceled) return completedFired;

        if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
          return completed(false);
        }

        ignoreNextClick = false;

        if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) // Reverting item into the original list
        : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
          vertical = this._getDirection(evt, target) === 'vertical';
          dragRect = getRect(dragEl);
          dragOverEvent('dragOverValid');
          if (Sortable.eventCanceled) return completedFired;

          if (revert) {
            parentEl = rootEl; // actualization

            capture();

            this._hideClone();

            dragOverEvent('revert');

            if (!Sortable.eventCanceled) {
              if (nextEl) {
                rootEl.insertBefore(dragEl, nextEl);
              } else {
                rootEl.appendChild(dragEl);
              }
            }

            return completed(true);
          }

          var elLastChild = lastChild(el, options.draggable);

          if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
            // Insert to end of list
            // If already at end of list: Do not insert
            if (elLastChild === dragEl) {
              return completed(false);
            } // if there is a last element, it is the target


            if (elLastChild && el === evt.target) {
              target = elLastChild;
            }

            if (target) {
              targetRect = getRect(target);
            }

            if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
              capture();

              if (elLastChild && elLastChild.nextSibling) {
                // the last draggable element is not the last node
                el.insertBefore(dragEl, elLastChild.nextSibling);
              } else {
                el.appendChild(dragEl);
              }

              parentEl = el; // actualization

              changed();
              return completed(true);
            }
          } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
            // Insert to start of list
            var firstChild = getChild(el, 0, options, true);

            if (firstChild === dragEl) {
              return completed(false);
            }

            target = firstChild;
            targetRect = getRect(target);

            if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
              capture();
              el.insertBefore(dragEl, firstChild);
              parentEl = el; // actualization

              changed();
              return completed(true);
            }
          } else if (target.parentNode === el) {
            targetRect = getRect(target);
            var direction = 0,
                targetBeforeFirstSwap,
                differentLevel = dragEl.parentNode !== el,
                differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical),
                side1 = vertical ? 'top' : 'left',
                scrolledPastTop = isScrolledPast(target, 'top', 'top') || isScrolledPast(dragEl, 'top', 'top'),
                scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;

            if (lastTarget !== target) {
              targetBeforeFirstSwap = targetRect[side1];
              pastFirstInvertThresh = false;
              isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
            }

            direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
            var sibling;

            if (direction !== 0) {
              // Check if target is beside dragEl in respective direction (ignoring hidden elements)
              var dragIndex = index(dragEl);

              do {
                dragIndex -= direction;
                sibling = parentEl.children[dragIndex];
              } while (sibling && (css(sibling, 'display') === 'none' || sibling === ghostEl));
            } // If dragEl is already beside target: Do not insert


            if (direction === 0 || sibling === target) {
              return completed(false);
            }

            lastTarget = target;
            lastDirection = direction;
            var nextSibling = target.nextElementSibling,
                after = false;
            after = direction === 1;

            var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);

            if (moveVector !== false) {
              if (moveVector === 1 || moveVector === -1) {
                after = moveVector === 1;
              }

              _silent = true;
              setTimeout(_unsilent, 30);
              capture();

              if (after && !nextSibling) {
                el.appendChild(dragEl);
              } else {
                target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
              } // Undo chrome's scroll adjustment (has no effect on other browsers)


              if (scrolledPastTop) {
                scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
              }

              parentEl = dragEl.parentNode; // actualization
              // must be done before animation

              if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {
                targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
              }

              changed();
              return completed(true);
            }
          }

          if (el.contains(dragEl)) {
            return completed(false);
          }
        }

        return false;
      },
      _ignoreWhileAnimating: null,
      _offMoveEvents: function _offMoveEvents() {
        off(document, 'mousemove', this._onTouchMove);
        off(document, 'touchmove', this._onTouchMove);
        off(document, 'pointermove', this._onTouchMove);
        off(document, 'dragover', nearestEmptyInsertDetectEvent);
        off(document, 'mousemove', nearestEmptyInsertDetectEvent);
        off(document, 'touchmove', nearestEmptyInsertDetectEvent);
      },
      _offUpEvents: function _offUpEvents() {
        var ownerDocument = this.el.ownerDocument;
        off(ownerDocument, 'mouseup', this._onDrop);
        off(ownerDocument, 'touchend', this._onDrop);
        off(ownerDocument, 'pointerup', this._onDrop);
        off(ownerDocument, 'touchcancel', this._onDrop);
        off(document, 'selectstart', this);
      },
      _onDrop: function _onDrop(
      /**Event*/
      evt) {
        var el = this.el,
            options = this.options; // Get the index of the dragged element within its parent

        newIndex = index(dragEl);
        newDraggableIndex = index(dragEl, options.draggable);
        pluginEvent('drop', this, {
          evt: evt
        });
        parentEl = dragEl && dragEl.parentNode; // Get again after plugin event

        newIndex = index(dragEl);
        newDraggableIndex = index(dragEl, options.draggable);

        if (Sortable.eventCanceled) {
          this._nulling();

          return;
        }

        awaitingDragStarted = false;
        isCircumstantialInvert = false;
        pastFirstInvertThresh = false;
        clearInterval(this._loopId);
        clearTimeout(this._dragStartTimer);

        _cancelNextTick(this.cloneId);

        _cancelNextTick(this._dragStartId); // Unbind events


        if (this.nativeDraggable) {
          off(document, 'drop', this);
          off(el, 'dragstart', this._onDragStart);
        }

        this._offMoveEvents();

        this._offUpEvents();

        if (Safari) {
          css(document.body, 'user-select', '');
        }

        css(dragEl, 'transform', '');

        if (evt) {
          if (moved) {
            evt.cancelable && evt.preventDefault();
            !options.dropBubble && evt.stopPropagation();
          }

          ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);

          if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {
            // Remove clone(s)
            cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
          }

          if (dragEl) {
            if (this.nativeDraggable) {
              off(dragEl, 'dragend', this);
            }

            _disableDraggable(dragEl);

            dragEl.style['will-change'] = ''; // Remove classes
            // ghostClass is added in dragStarted

            if (moved && !awaitingDragStarted) {
              toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
            }

            toggleClass(dragEl, this.options.chosenClass, false); // Drag stop event

            _dispatchEvent({
              sortable: this,
              name: 'unchoose',
              toEl: parentEl,
              newIndex: null,
              newDraggableIndex: null,
              originalEvent: evt
            });

            if (rootEl !== parentEl) {
              if (newIndex >= 0) {
                // Add event
                _dispatchEvent({
                  rootEl: parentEl,
                  name: 'add',
                  toEl: parentEl,
                  fromEl: rootEl,
                  originalEvent: evt
                }); // Remove event


                _dispatchEvent({
                  sortable: this,
                  name: 'remove',
                  toEl: parentEl,
                  originalEvent: evt
                }); // drag from one list and drop into another


                _dispatchEvent({
                  rootEl: parentEl,
                  name: 'sort',
                  toEl: parentEl,
                  fromEl: rootEl,
                  originalEvent: evt
                });

                _dispatchEvent({
                  sortable: this,
                  name: 'sort',
                  toEl: parentEl,
                  originalEvent: evt
                });
              }

              putSortable && putSortable.save();
            } else {
              if (newIndex !== oldIndex) {
                if (newIndex >= 0) {
                  // drag & drop within the same list
                  _dispatchEvent({
                    sortable: this,
                    name: 'update',
                    toEl: parentEl,
                    originalEvent: evt
                  });

                  _dispatchEvent({
                    sortable: this,
                    name: 'sort',
                    toEl: parentEl,
                    originalEvent: evt
                  });
                }
              }
            }

            if (Sortable.active) {
              /* jshint eqnull:true */
              if (newIndex == null || newIndex === -1) {
                newIndex = oldIndex;
                newDraggableIndex = oldDraggableIndex;
              }

              _dispatchEvent({
                sortable: this,
                name: 'end',
                toEl: parentEl,
                originalEvent: evt
              }); // Save sorting


              this.save();
            }
          }
        }

        this._nulling();
      },
      _nulling: function _nulling() {
        pluginEvent('nulling', this);
        rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
        savedInputChecked.forEach(function (el) {
          el.checked = true;
        });
        savedInputChecked.length = lastDx = lastDy = 0;
      },
      handleEvent: function handleEvent(
      /**Event*/
      evt) {
        switch (evt.type) {
          case 'drop':
          case 'dragend':
            this._onDrop(evt);

            break;

          case 'dragenter':
          case 'dragover':
            if (dragEl) {
              this._onDragOver(evt);

              _globalDragOver(evt);
            }

            break;

          case 'selectstart':
            evt.preventDefault();
            break;
        }
      },

      /**
       * Serializes the item into an array of string.
       * @returns {String[]}
       */
      toArray: function toArray() {
        var order = [],
            el,
            children = this.el.children,
            i = 0,
            n = children.length,
            options = this.options;

        for (; i < n; i++) {
          el = children[i];

          if (closest(el, options.draggable, this.el, false)) {
            order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
          }
        }

        return order;
      },

      /**
       * Sorts the elements according to the array.
       * @param  {String[]}  order  order of the items
       */
      sort: function sort(order, useAnimation) {
        var items = {},
            rootEl = this.el;
        this.toArray().forEach(function (id, i) {
          var el = rootEl.children[i];

          if (closest(el, this.options.draggable, rootEl, false)) {
            items[id] = el;
          }
        }, this);
        useAnimation && this.captureAnimationState();
        order.forEach(function (id) {
          if (items[id]) {
            rootEl.removeChild(items[id]);
            rootEl.appendChild(items[id]);
          }
        });
        useAnimation && this.animateAll();
      },

      /**
       * Save the current sorting
       */
      save: function save() {
        var store = this.options.store;
        store && store.set && store.set(this);
      },

      /**
       * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
       * @param   {HTMLElement}  el
       * @param   {String}       [selector]  default: `options.draggable`
       * @returns {HTMLElement|null}
       */
      closest: function closest$1(el, selector) {
        return closest(el, selector || this.options.draggable, this.el, false);
      },

      /**
       * Set/get option
       * @param   {string} name
       * @param   {*}      [value]
       * @returns {*}
       */
      option: function option(name, value) {
        var options = this.options;

        if (value === void 0) {
          return options[name];
        } else {
          var modifiedValue = PluginManager.modifyOption(this, name, value);

          if (typeof modifiedValue !== 'undefined') {
            options[name] = modifiedValue;
          } else {
            options[name] = value;
          }

          if (name === 'group') {
            _prepareGroup(options);
          }
        }
      },

      /**
       * Destroy
       */
      destroy: function destroy() {
        pluginEvent('destroy', this);
        var el = this.el;
        el[expando] = null;
        off(el, 'mousedown', this._onTapStart);
        off(el, 'touchstart', this._onTapStart);
        off(el, 'pointerdown', this._onTapStart);

        if (this.nativeDraggable) {
          off(el, 'dragover', this);
          off(el, 'dragenter', this);
        } // Remove draggable attributes


        Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {
          el.removeAttribute('draggable');
        });

        this._onDrop();

        this._disableDelayedDragEvents();

        sortables.splice(sortables.indexOf(this.el), 1);
        this.el = el = null;
      },
      _hideClone: function _hideClone() {
        if (!cloneHidden) {
          pluginEvent('hideClone', this);
          if (Sortable.eventCanceled) return;
          css(cloneEl, 'display', 'none');

          if (this.options.removeCloneOnHide && cloneEl.parentNode) {
            cloneEl.parentNode.removeChild(cloneEl);
          }

          cloneHidden = true;
        }
      },
      _showClone: function _showClone(putSortable) {
        if (putSortable.lastPutMode !== 'clone') {
          this._hideClone();

          return;
        }

        if (cloneHidden) {
          pluginEvent('showClone', this);
          if (Sortable.eventCanceled) return; // show clone at dragEl or original position

          if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
            rootEl.insertBefore(cloneEl, dragEl);
          } else if (nextEl) {
            rootEl.insertBefore(cloneEl, nextEl);
          } else {
            rootEl.appendChild(cloneEl);
          }

          if (this.options.group.revertClone) {
            this.animate(dragEl, cloneEl);
          }

          css(cloneEl, 'display', '');
          cloneHidden = false;
        }
      }
    };

    function _globalDragOver(
    /**Event*/
    evt) {
      if (evt.dataTransfer) {
        evt.dataTransfer.dropEffect = 'move';
      }

      evt.cancelable && evt.preventDefault();
    }

    function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
      var evt,
          sortable = fromEl[expando],
          onMoveFn = sortable.options.onMove,
          retVal; // Support for new CustomEvent feature

      if (window.CustomEvent && !IE11OrLess && !Edge) {
        evt = new CustomEvent('move', {
          bubbles: true,
          cancelable: true
        });
      } else {
        evt = document.createEvent('Event');
        evt.initEvent('move', true, true);
      }

      evt.to = toEl;
      evt.from = fromEl;
      evt.dragged = dragEl;
      evt.draggedRect = dragRect;
      evt.related = targetEl || toEl;
      evt.relatedRect = targetRect || getRect(toEl);
      evt.willInsertAfter = willInsertAfter;
      evt.originalEvent = originalEvent;
      fromEl.dispatchEvent(evt);

      if (onMoveFn) {
        retVal = onMoveFn.call(sortable, evt, originalEvent);
      }

      return retVal;
    }

    function _disableDraggable(el) {
      el.draggable = false;
    }

    function _unsilent() {
      _silent = false;
    }

    function _ghostIsFirst(evt, vertical, sortable) {
      var rect = getRect(getChild(sortable.el, 0, sortable.options, true));
      var spacer = 10;
      return vertical ? evt.clientX < rect.left - spacer || evt.clientY < rect.top && evt.clientX < rect.right : evt.clientY < rect.top - spacer || evt.clientY < rect.bottom && evt.clientX < rect.left;
    }

    function _ghostIsLast(evt, vertical, sortable) {
      var rect = getRect(lastChild(sortable.el, sortable.options.draggable));
      var spacer = 10;
      return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;
    }

    function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
      var mouseOnAxis = vertical ? evt.clientY : evt.clientX,
          targetLength = vertical ? targetRect.height : targetRect.width,
          targetS1 = vertical ? targetRect.top : targetRect.left,
          targetS2 = vertical ? targetRect.bottom : targetRect.right,
          invert = false;

      if (!invertSwap) {
        // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold
        if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
          // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2
          // check if past first invert threshold on side opposite of lastDirection
          if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
            // past first invert threshold, do not restrict inverted threshold to dragEl shadow
            pastFirstInvertThresh = true;
          }

          if (!pastFirstInvertThresh) {
            // dragEl shadow (target move distance shadow)
            if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow
            : mouseOnAxis > targetS2 - targetMoveDistance) {
              return -lastDirection;
            }
          } else {
            invert = true;
          }
        } else {
          // Regular
          if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
            return _getInsertDirection(target);
          }
        }
      }

      invert = invert || invertSwap;

      if (invert) {
        // Invert of regular
        if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
          return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
        }
      }

      return 0;
    }
    /**
     * Gets the direction dragEl must be swapped relative to target in order to make it
     * seem that dragEl has been "inserted" into that element's position
     * @param  {HTMLElement} target       The target whose position dragEl is being inserted at
     * @return {Number}                   Direction dragEl must be swapped
     */


    function _getInsertDirection(target) {
      if (index(dragEl) < index(target)) {
        return 1;
      } else {
        return -1;
      }
    }
    /**
     * Generate id
     * @param   {HTMLElement} el
     * @returns {String}
     * @private
     */


    function _generateId(el) {
      var str = el.tagName + el.className + el.src + el.href + el.textContent,
          i = str.length,
          sum = 0;

      while (i--) {
        sum += str.charCodeAt(i);
      }

      return sum.toString(36);
    }

    function _saveInputCheckedState(root) {
      savedInputChecked.length = 0;
      var inputs = root.getElementsByTagName('input');
      var idx = inputs.length;

      while (idx--) {
        var el = inputs[idx];
        el.checked && savedInputChecked.push(el);
      }
    }

    function _nextTick(fn) {
      return setTimeout(fn, 0);
    }

    function _cancelNextTick(id) {
      return clearTimeout(id);
    } // Fixed #973:


    if (documentExists) {
      on(document, 'touchmove', function (evt) {
        if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
          evt.preventDefault();
        }
      });
    } // Export utils


    Sortable.utils = {
      on: on,
      off: off,
      css: css,
      find: find,
      is: function is(el, selector) {
        return !!closest(el, selector, el, false);
      },
      extend: extend,
      throttle: throttle,
      closest: closest,
      toggleClass: toggleClass,
      clone: clone,
      index: index,
      nextTick: _nextTick,
      cancelNextTick: _cancelNextTick,
      detectDirection: _detectDirection,
      getChild: getChild
    };
    /**
     * Get the Sortable instance of an element
     * @param  {HTMLElement} element The element
     * @return {Sortable|undefined}         The instance of Sortable
     */

    Sortable.get = function (element) {
      return element[expando];
    };
    /**
     * Mount a plugin to Sortable
     * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted
     */


    Sortable.mount = function () {
      for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
        plugins[_key] = arguments[_key];
      }

      if (plugins[0].constructor === Array) plugins = plugins[0];
      plugins.forEach(function (plugin) {
        if (!plugin.prototype || !plugin.prototype.constructor) {
          throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
        }

        if (plugin.utils) Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
        PluginManager.mount(plugin);
      });
    };
    /**
     * Create sortable instance
     * @param {HTMLElement}  el
     * @param {Object}      [options]
     */


    Sortable.create = function (el, options) {
      return new Sortable(el, options);
    }; // Export


    Sortable.version = version;

    var autoScrolls = [],
        scrollEl,
        scrollRootEl,
        scrolling = false,
        lastAutoScrollX,
        lastAutoScrollY,
        touchEvt$1,
        pointerElemChangedInterval;

    function AutoScrollPlugin() {
      function AutoScroll() {
        this.defaults = {
          scroll: true,
          forceAutoScrollFallback: false,
          scrollSensitivity: 30,
          scrollSpeed: 10,
          bubbleScroll: true
        }; // Bind all private methods

        for (var fn in this) {
          if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
            this[fn] = this[fn].bind(this);
          }
        }
      }

      AutoScroll.prototype = {
        dragStarted: function dragStarted(_ref) {
          var originalEvent = _ref.originalEvent;

          if (this.sortable.nativeDraggable) {
            on(document, 'dragover', this._handleAutoScroll);
          } else {
            if (this.options.supportPointer) {
              on(document, 'pointermove', this._handleFallbackAutoScroll);
            } else if (originalEvent.touches) {
              on(document, 'touchmove', this._handleFallbackAutoScroll);
            } else {
              on(document, 'mousemove', this._handleFallbackAutoScroll);
            }
          }
        },
        dragOverCompleted: function dragOverCompleted(_ref2) {
          var originalEvent = _ref2.originalEvent;

          // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)
          if (!this.options.dragOverBubble && !originalEvent.rootEl) {
            this._handleAutoScroll(originalEvent);
          }
        },
        drop: function drop() {
          if (this.sortable.nativeDraggable) {
            off(document, 'dragover', this._handleAutoScroll);
          } else {
            off(document, 'pointermove', this._handleFallbackAutoScroll);
            off(document, 'touchmove', this._handleFallbackAutoScroll);
            off(document, 'mousemove', this._handleFallbackAutoScroll);
          }

          clearPointerElemChangedInterval();
          clearAutoScrolls();
          cancelThrottle();
        },
        nulling: function nulling() {
          touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
          autoScrolls.length = 0;
        },
        _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
          this._handleAutoScroll(evt, true);
        },
        _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
          var _this = this;

          var x = (evt.touches ? evt.touches[0] : evt).clientX,
              y = (evt.touches ? evt.touches[0] : evt).clientY,
              elem = document.elementFromPoint(x, y);
          touchEvt$1 = evt; // IE does not seem to have native autoscroll,
          // Edge's autoscroll seems too conditional,
          // MACOS Safari does not have autoscroll,
          // Firefox and Chrome are good

          if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
            autoScroll(evt, this.options, elem, fallback); // Listener for pointer element change

            var ogElemScroller = getParentAutoScrollElement(elem, true);

            if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
              pointerElemChangedInterval && clearPointerElemChangedInterval(); // Detect for pointer elem change, emulating native DnD behaviour

              pointerElemChangedInterval = setInterval(function () {
                var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);

                if (newElem !== ogElemScroller) {
                  ogElemScroller = newElem;
                  clearAutoScrolls();
                }

                autoScroll(evt, _this.options, newElem, fallback);
              }, 10);
              lastAutoScrollX = x;
              lastAutoScrollY = y;
            }
          } else {
            // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll
            if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
              clearAutoScrolls();
              return;
            }

            autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
          }
        }
      };
      return _extends(AutoScroll, {
        pluginName: 'scroll',
        initializeByDefault: true
      });
    }

    function clearAutoScrolls() {
      autoScrolls.forEach(function (autoScroll) {
        clearInterval(autoScroll.pid);
      });
      autoScrolls = [];
    }

    function clearPointerElemChangedInterval() {
      clearInterval(pointerElemChangedInterval);
    }

    var autoScroll = throttle(function (evt, options, rootEl, isFallback) {
      // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521
      if (!options.scroll) return;
      var x = (evt.touches ? evt.touches[0] : evt).clientX,
          y = (evt.touches ? evt.touches[0] : evt).clientY,
          sens = options.scrollSensitivity,
          speed = options.scrollSpeed,
          winScroller = getWindowScrollingElement();
      var scrollThisInstance = false,
          scrollCustomFn; // New scroll root, set scrollEl

      if (scrollRootEl !== rootEl) {
        scrollRootEl = rootEl;
        clearAutoScrolls();
        scrollEl = options.scroll;
        scrollCustomFn = options.scrollFn;

        if (scrollEl === true) {
          scrollEl = getParentAutoScrollElement(rootEl, true);
        }
      }

      var layersOut = 0;
      var currentParent = scrollEl;

      do {
        var el = currentParent,
            rect = getRect(el),
            top = rect.top,
            bottom = rect.bottom,
            left = rect.left,
            right = rect.right,
            width = rect.width,
            height = rect.height,
            canScrollX = void 0,
            canScrollY = void 0,
            scrollWidth = el.scrollWidth,
            scrollHeight = el.scrollHeight,
            elCSS = css(el),
            scrollPosX = el.scrollLeft,
            scrollPosY = el.scrollTop;

        if (el === winScroller) {
          canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll' || elCSS.overflowX === 'visible');
          canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll' || elCSS.overflowY === 'visible');
        } else {
          canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll');
          canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll');
        }

        var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
        var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);

        if (!autoScrolls[layersOut]) {
          for (var i = 0; i <= layersOut; i++) {
            if (!autoScrolls[i]) {
              autoScrolls[i] = {};
            }
          }
        }

        if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
          autoScrolls[layersOut].el = el;
          autoScrolls[layersOut].vx = vx;
          autoScrolls[layersOut].vy = vy;
          clearInterval(autoScrolls[layersOut].pid);

          if (vx != 0 || vy != 0) {
            scrollThisInstance = true;
            /* jshint loopfunc:true */

            autoScrolls[layersOut].pid = setInterval(function () {
              // emulate drag over during autoscroll (fallback), emulating native DnD behaviour
              if (isFallback && this.layer === 0) {
                Sortable.active._onTouchMove(touchEvt$1); // To move ghost if it is positioned absolutely

              }

              var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
              var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;

              if (typeof scrollCustomFn === 'function') {
                if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== 'continue') {
                  return;
                }
              }

              scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
            }.bind({
              layer: layersOut
            }), 24);
          }
        }

        layersOut++;
      } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));

      scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not
    }, 30);

    var drop = function drop(_ref) {
      var originalEvent = _ref.originalEvent,
          putSortable = _ref.putSortable,
          dragEl = _ref.dragEl,
          activeSortable = _ref.activeSortable,
          dispatchSortableEvent = _ref.dispatchSortableEvent,
          hideGhostForTarget = _ref.hideGhostForTarget,
          unhideGhostForTarget = _ref.unhideGhostForTarget;
      if (!originalEvent) return;
      var toSortable = putSortable || activeSortable;
      hideGhostForTarget();
      var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
      var target = document.elementFromPoint(touch.clientX, touch.clientY);
      unhideGhostForTarget();

      if (toSortable && !toSortable.el.contains(target)) {
        dispatchSortableEvent('spill');
        this.onSpill({
          dragEl: dragEl,
          putSortable: putSortable
        });
      }
    };

    function Revert() {}

    Revert.prototype = {
      startIndex: null,
      dragStart: function dragStart(_ref2) {
        var oldDraggableIndex = _ref2.oldDraggableIndex;
        this.startIndex = oldDraggableIndex;
      },
      onSpill: function onSpill(_ref3) {
        var dragEl = _ref3.dragEl,
            putSortable = _ref3.putSortable;
        this.sortable.captureAnimationState();

        if (putSortable) {
          putSortable.captureAnimationState();
        }

        var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);

        if (nextSibling) {
          this.sortable.el.insertBefore(dragEl, nextSibling);
        } else {
          this.sortable.el.appendChild(dragEl);
        }

        this.sortable.animateAll();

        if (putSortable) {
          putSortable.animateAll();
        }
      },
      drop: drop
    };

    _extends(Revert, {
      pluginName: 'revertOnSpill'
    });

    function Remove() {}

    Remove.prototype = {
      onSpill: function onSpill(_ref4) {
        var dragEl = _ref4.dragEl,
            putSortable = _ref4.putSortable;
        var parentSortable = putSortable || this.sortable;
        parentSortable.captureAnimationState();
        dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);
        parentSortable.animateAll();
      },
      drop: drop
    };

    _extends(Remove, {
      pluginName: 'removeOnSpill'
    });

    var multiDragElements = [],
        multiDragClones = [],
        lastMultiDragSelect,
        // for selection with modifier key down (SHIFT)
    multiDragSortable,
        initialFolding = false,
        // Initial multi-drag fold when drag started
    folding = false,
        // Folding any other time
    dragStarted = false,
        dragEl$1,
        clonesFromRect,
        clonesHidden;

    function MultiDragPlugin() {
      function MultiDrag(sortable) {
        // Bind all private methods
        for (var fn in this) {
          if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
            this[fn] = this[fn].bind(this);
          }
        }

        if (!sortable.options.avoidImplicitDeselect) {
          if (sortable.options.supportPointer) {
            on(document, 'pointerup', this._deselectMultiDrag);
          } else {
            on(document, 'mouseup', this._deselectMultiDrag);
            on(document, 'touchend', this._deselectMultiDrag);
          }
        }

        on(document, 'keydown', this._checkKeyDown);
        on(document, 'keyup', this._checkKeyUp);
        this.defaults = {
          selectedClass: 'sortable-selected',
          multiDragKey: null,
          avoidImplicitDeselect: false,
          setData: function setData(dataTransfer, dragEl) {
            var data = '';

            if (multiDragElements.length && multiDragSortable === sortable) {
              multiDragElements.forEach(function (multiDragElement, i) {
                data += (!i ? '' : ', ') + multiDragElement.textContent;
              });
            } else {
              data = dragEl.textContent;
            }

            dataTransfer.setData('Text', data);
          }
        };
      }

      MultiDrag.prototype = {
        multiDragKeyDown: false,
        isMultiDrag: false,
        delayStartGlobal: function delayStartGlobal(_ref) {
          var dragged = _ref.dragEl;
          dragEl$1 = dragged;
        },
        delayEnded: function delayEnded() {
          this.isMultiDrag = ~multiDragElements.indexOf(dragEl$1);
        },
        setupClone: function setupClone(_ref2) {
          var sortable = _ref2.sortable,
              cancel = _ref2.cancel;
          if (!this.isMultiDrag) return;

          for (var i = 0; i < multiDragElements.length; i++) {
            multiDragClones.push(clone(multiDragElements[i]));
            multiDragClones[i].sortableIndex = multiDragElements[i].sortableIndex;
            multiDragClones[i].draggable = false;
            multiDragClones[i].style['will-change'] = '';
            toggleClass(multiDragClones[i], this.options.selectedClass, false);
            multiDragElements[i] === dragEl$1 && toggleClass(multiDragClones[i], this.options.chosenClass, false);
          }

          sortable._hideClone();

          cancel();
        },
        clone: function clone(_ref3) {
          var sortable = _ref3.sortable,
              rootEl = _ref3.rootEl,
              dispatchSortableEvent = _ref3.dispatchSortableEvent,
              cancel = _ref3.cancel;
          if (!this.isMultiDrag) return;

          if (!this.options.removeCloneOnHide) {
            if (multiDragElements.length && multiDragSortable === sortable) {
              insertMultiDragClones(true, rootEl);
              dispatchSortableEvent('clone');
              cancel();
            }
          }
        },
        showClone: function showClone(_ref4) {
          var cloneNowShown = _ref4.cloneNowShown,
              rootEl = _ref4.rootEl,
              cancel = _ref4.cancel;
          if (!this.isMultiDrag) return;
          insertMultiDragClones(false, rootEl);
          multiDragClones.forEach(function (clone) {
            css(clone, 'display', '');
          });
          cloneNowShown();
          clonesHidden = false;
          cancel();
        },
        hideClone: function hideClone(_ref5) {
          var _this = this;

          _ref5.sortable;
              var cloneNowHidden = _ref5.cloneNowHidden,
              cancel = _ref5.cancel;
          if (!this.isMultiDrag) return;
          multiDragClones.forEach(function (clone) {
            css(clone, 'display', 'none');

            if (_this.options.removeCloneOnHide && clone.parentNode) {
              clone.parentNode.removeChild(clone);
            }
          });
          cloneNowHidden();
          clonesHidden = true;
          cancel();
        },
        dragStartGlobal: function dragStartGlobal(_ref6) {
          _ref6.sortable;

          if (!this.isMultiDrag && multiDragSortable) {
            multiDragSortable.multiDrag._deselectMultiDrag();
          }

          multiDragElements.forEach(function (multiDragElement) {
            multiDragElement.sortableIndex = index(multiDragElement);
          }); // Sort multi-drag elements

          multiDragElements = multiDragElements.sort(function (a, b) {
            return a.sortableIndex - b.sortableIndex;
          });
          dragStarted = true;
        },
        dragStarted: function dragStarted(_ref7) {
          var _this2 = this;

          var sortable = _ref7.sortable;
          if (!this.isMultiDrag) return;

          if (this.options.sort) {
            // Capture rects,
            // hide multi drag elements (by positioning them absolute),
            // set multi drag elements rects to dragRect,
            // show multi drag elements,
            // animate to rects,
            // unset rects & remove from DOM
            sortable.captureAnimationState();

            if (this.options.animation) {
              multiDragElements.forEach(function (multiDragElement) {
                if (multiDragElement === dragEl$1) return;
                css(multiDragElement, 'position', 'absolute');
              });
              var dragRect = getRect(dragEl$1, false, true, true);
              multiDragElements.forEach(function (multiDragElement) {
                if (multiDragElement === dragEl$1) return;
                setRect(multiDragElement, dragRect);
              });
              folding = true;
              initialFolding = true;
            }
          }

          sortable.animateAll(function () {
            folding = false;
            initialFolding = false;

            if (_this2.options.animation) {
              multiDragElements.forEach(function (multiDragElement) {
                unsetRect(multiDragElement);
              });
            } // Remove all auxiliary multidrag items from el, if sorting enabled


            if (_this2.options.sort) {
              removeMultiDragElements();
            }
          });
        },
        dragOver: function dragOver(_ref8) {
          var target = _ref8.target,
              completed = _ref8.completed,
              cancel = _ref8.cancel;

          if (folding && ~multiDragElements.indexOf(target)) {
            completed(false);
            cancel();
          }
        },
        revert: function revert(_ref9) {
          var fromSortable = _ref9.fromSortable,
              rootEl = _ref9.rootEl,
              sortable = _ref9.sortable,
              dragRect = _ref9.dragRect;

          if (multiDragElements.length > 1) {
            // Setup unfold animation
            multiDragElements.forEach(function (multiDragElement) {
              sortable.addAnimationState({
                target: multiDragElement,
                rect: folding ? getRect(multiDragElement) : dragRect
              });
              unsetRect(multiDragElement);
              multiDragElement.fromRect = dragRect;
              fromSortable.removeAnimationState(multiDragElement);
            });
            folding = false;
            insertMultiDragElements(!this.options.removeCloneOnHide, rootEl);
          }
        },
        dragOverCompleted: function dragOverCompleted(_ref10) {
          var sortable = _ref10.sortable,
              isOwner = _ref10.isOwner,
              insertion = _ref10.insertion,
              activeSortable = _ref10.activeSortable,
              parentEl = _ref10.parentEl,
              putSortable = _ref10.putSortable;
          var options = this.options;

          if (insertion) {
            // Clones must be hidden before folding animation to capture dragRectAbsolute properly
            if (isOwner) {
              activeSortable._hideClone();
            }

            initialFolding = false; // If leaving sort:false root, or already folding - Fold to new location

            if (options.animation && multiDragElements.length > 1 && (folding || !isOwner && !activeSortable.options.sort && !putSortable)) {
              // Fold: Set all multi drag elements's rects to dragEl's rect when multi-drag elements are invisible
              var dragRectAbsolute = getRect(dragEl$1, false, true, true);
              multiDragElements.forEach(function (multiDragElement) {
                if (multiDragElement === dragEl$1) return;
                setRect(multiDragElement, dragRectAbsolute); // Move element(s) to end of parentEl so that it does not interfere with multi-drag clones insertion if they are inserted
                // while folding, and so that we can capture them again because old sortable will no longer be fromSortable

                parentEl.appendChild(multiDragElement);
              });
              folding = true;
            } // Clones must be shown (and check to remove multi drags) after folding when interfering multiDragElements are moved out


            if (!isOwner) {
              // Only remove if not folding (folding will remove them anyways)
              if (!folding) {
                removeMultiDragElements();
              }

              if (multiDragElements.length > 1) {
                var clonesHiddenBefore = clonesHidden;

                activeSortable._showClone(sortable); // Unfold animation for clones if showing from hidden


                if (activeSortable.options.animation && !clonesHidden && clonesHiddenBefore) {
                  multiDragClones.forEach(function (clone) {
                    activeSortable.addAnimationState({
                      target: clone,
                      rect: clonesFromRect
                    });
                    clone.fromRect = clonesFromRect;
                    clone.thisAnimationDuration = null;
                  });
                }
              } else {
                activeSortable._showClone(sortable);
              }
            }
          }
        },
        dragOverAnimationCapture: function dragOverAnimationCapture(_ref11) {
          var dragRect = _ref11.dragRect,
              isOwner = _ref11.isOwner,
              activeSortable = _ref11.activeSortable;
          multiDragElements.forEach(function (multiDragElement) {
            multiDragElement.thisAnimationDuration = null;
          });

          if (activeSortable.options.animation && !isOwner && activeSortable.multiDrag.isMultiDrag) {
            clonesFromRect = _extends({}, dragRect);
            var dragMatrix = matrix(dragEl$1, true);
            clonesFromRect.top -= dragMatrix.f;
            clonesFromRect.left -= dragMatrix.e;
          }
        },
        dragOverAnimationComplete: function dragOverAnimationComplete() {
          if (folding) {
            folding = false;
            removeMultiDragElements();
          }
        },
        drop: function drop(_ref12) {
          var evt = _ref12.originalEvent,
              rootEl = _ref12.rootEl,
              parentEl = _ref12.parentEl,
              sortable = _ref12.sortable,
              dispatchSortableEvent = _ref12.dispatchSortableEvent,
              oldIndex = _ref12.oldIndex,
              putSortable = _ref12.putSortable;
          var toSortable = putSortable || this.sortable;
          if (!evt) return;
          var options = this.options,
              children = parentEl.children; // Multi-drag selection

          if (!dragStarted) {
            if (options.multiDragKey && !this.multiDragKeyDown) {
              this._deselectMultiDrag();
            }

            toggleClass(dragEl$1, options.selectedClass, !~multiDragElements.indexOf(dragEl$1));

            if (!~multiDragElements.indexOf(dragEl$1)) {
              multiDragElements.push(dragEl$1);
              dispatchEvent$1({
                sortable: sortable,
                rootEl: rootEl,
                name: 'select',
                targetEl: dragEl$1,
                originalEvent: evt
              }); // Modifier activated, select from last to dragEl

              if (evt.shiftKey && lastMultiDragSelect && sortable.el.contains(lastMultiDragSelect)) {
                var lastIndex = index(lastMultiDragSelect),
                    currentIndex = index(dragEl$1);

                if (~lastIndex && ~currentIndex && lastIndex !== currentIndex) {
                  // Must include lastMultiDragSelect (select it), in case modified selection from no selection
                  // (but previous selection existed)
                  var n, i;

                  if (currentIndex > lastIndex) {
                    i = lastIndex;
                    n = currentIndex;
                  } else {
                    i = currentIndex;
                    n = lastIndex + 1;
                  }

                  for (; i < n; i++) {
                    if (~multiDragElements.indexOf(children[i])) continue;
                    toggleClass(children[i], options.selectedClass, true);
                    multiDragElements.push(children[i]);
                    dispatchEvent$1({
                      sortable: sortable,
                      rootEl: rootEl,
                      name: 'select',
                      targetEl: children[i],
                      originalEvent: evt
                    });
                  }
                }
              } else {
                lastMultiDragSelect = dragEl$1;
              }

              multiDragSortable = toSortable;
            } else {
              multiDragElements.splice(multiDragElements.indexOf(dragEl$1), 1);
              lastMultiDragSelect = null;
              dispatchEvent$1({
                sortable: sortable,
                rootEl: rootEl,
                name: 'deselect',
                targetEl: dragEl$1,
                originalEvent: evt
              });
            }
          } // Multi-drag drop


          if (dragStarted && this.isMultiDrag) {
            folding = false; // Do not "unfold" after around dragEl if reverted

            if ((parentEl[expando].options.sort || parentEl !== rootEl) && multiDragElements.length > 1) {
              var dragRect = getRect(dragEl$1),
                  multiDragIndex = index(dragEl$1, ':not(.' + this.options.selectedClass + ')');
              if (!initialFolding && options.animation) dragEl$1.thisAnimationDuration = null;
              toSortable.captureAnimationState();

              if (!initialFolding) {
                if (options.animation) {
                  dragEl$1.fromRect = dragRect;
                  multiDragElements.forEach(function (multiDragElement) {
                    multiDragElement.thisAnimationDuration = null;

                    if (multiDragElement !== dragEl$1) {
                      var rect = folding ? getRect(multiDragElement) : dragRect;
                      multiDragElement.fromRect = rect; // Prepare unfold animation

                      toSortable.addAnimationState({
                        target: multiDragElement,
                        rect: rect
                      });
                    }
                  });
                } // Multi drag elements are not necessarily removed from the DOM on drop, so to reinsert
                // properly they must all be removed


                removeMultiDragElements();
                multiDragElements.forEach(function (multiDragElement) {
                  if (children[multiDragIndex]) {
                    parentEl.insertBefore(multiDragElement, children[multiDragIndex]);
                  } else {
                    parentEl.appendChild(multiDragElement);
                  }

                  multiDragIndex++;
                }); // If initial folding is done, the elements may have changed position because they are now
                // unfolding around dragEl, even though dragEl may not have his index changed, so update event
                // must be fired here as Sortable will not.

                if (oldIndex === index(dragEl$1)) {
                  var update = false;
                  multiDragElements.forEach(function (multiDragElement) {
                    if (multiDragElement.sortableIndex !== index(multiDragElement)) {
                      update = true;
                      return;
                    }
                  });

                  if (update) {
                    dispatchSortableEvent('update');
                  }
                }
              } // Must be done after capturing individual rects (scroll bar)


              multiDragElements.forEach(function (multiDragElement) {
                unsetRect(multiDragElement);
              });
              toSortable.animateAll();
            }

            multiDragSortable = toSortable;
          } // Remove clones if necessary


          if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {
            multiDragClones.forEach(function (clone) {
              clone.parentNode && clone.parentNode.removeChild(clone);
            });
          }
        },
        nullingGlobal: function nullingGlobal() {
          this.isMultiDrag = dragStarted = false;
          multiDragClones.length = 0;
        },
        destroyGlobal: function destroyGlobal() {
          this._deselectMultiDrag();

          off(document, 'pointerup', this._deselectMultiDrag);
          off(document, 'mouseup', this._deselectMultiDrag);
          off(document, 'touchend', this._deselectMultiDrag);
          off(document, 'keydown', this._checkKeyDown);
          off(document, 'keyup', this._checkKeyUp);
        },
        _deselectMultiDrag: function _deselectMultiDrag(evt) {
          if (typeof dragStarted !== "undefined" && dragStarted) return; // Only deselect if selection is in this sortable

          if (multiDragSortable !== this.sortable) return; // Only deselect if target is not item in this sortable

          if (evt && closest(evt.target, this.options.draggable, this.sortable.el, false)) return; // Only deselect if left click

          if (evt && evt.button !== 0) return;

          while (multiDragElements.length) {
            var el = multiDragElements[0];
            toggleClass(el, this.options.selectedClass, false);
            multiDragElements.shift();
            dispatchEvent$1({
              sortable: this.sortable,
              rootEl: this.sortable.el,
              name: 'deselect',
              targetEl: el,
              originalEvent: evt
            });
          }
        },
        _checkKeyDown: function _checkKeyDown(evt) {
          if (evt.key === this.options.multiDragKey) {
            this.multiDragKeyDown = true;
          }
        },
        _checkKeyUp: function _checkKeyUp(evt) {
          if (evt.key === this.options.multiDragKey) {
            this.multiDragKeyDown = false;
          }
        }
      };
      return _extends(MultiDrag, {
        // Static methods & properties
        pluginName: 'multiDrag',
        utils: {
          /**
           * Selects the provided multi-drag item
           * @param  {HTMLElement} el    The element to be selected
           */
          select: function select(el) {
            var sortable = el.parentNode[expando];
            if (!sortable || !sortable.options.multiDrag || ~multiDragElements.indexOf(el)) return;

            if (multiDragSortable && multiDragSortable !== sortable) {
              multiDragSortable.multiDrag._deselectMultiDrag();

              multiDragSortable = sortable;
            }

            toggleClass(el, sortable.options.selectedClass, true);
            multiDragElements.push(el);
          },

          /**
           * Deselects the provided multi-drag item
           * @param  {HTMLElement} el    The element to be deselected
           */
          deselect: function deselect(el) {
            var sortable = el.parentNode[expando],
                index = multiDragElements.indexOf(el);
            if (!sortable || !sortable.options.multiDrag || !~index) return;
            toggleClass(el, sortable.options.selectedClass, false);
            multiDragElements.splice(index, 1);
          }
        },
        eventProperties: function eventProperties() {
          var _this3 = this;

          var oldIndicies = [],
              newIndicies = [];
          multiDragElements.forEach(function (multiDragElement) {
            oldIndicies.push({
              multiDragElement: multiDragElement,
              index: multiDragElement.sortableIndex
            }); // multiDragElements will already be sorted if folding

            var newIndex;

            if (folding && multiDragElement !== dragEl$1) {
              newIndex = -1;
            } else if (folding) {
              newIndex = index(multiDragElement, ':not(.' + _this3.options.selectedClass + ')');
            } else {
              newIndex = index(multiDragElement);
            }

            newIndicies.push({
              multiDragElement: multiDragElement,
              index: newIndex
            });
          });
          return {
            items: _toConsumableArray(multiDragElements),
            clones: [].concat(multiDragClones),
            oldIndicies: oldIndicies,
            newIndicies: newIndicies
          };
        },
        optionListeners: {
          multiDragKey: function multiDragKey(key) {
            key = key.toLowerCase();

            if (key === 'ctrl') {
              key = 'Control';
            } else if (key.length > 1) {
              key = key.charAt(0).toUpperCase() + key.substr(1);
            }

            return key;
          }
        }
      });
    }

    function insertMultiDragElements(clonesInserted, rootEl) {
      multiDragElements.forEach(function (multiDragElement, i) {
        var target = rootEl.children[multiDragElement.sortableIndex + (clonesInserted ? Number(i) : 0)];

        if (target) {
          rootEl.insertBefore(multiDragElement, target);
        } else {
          rootEl.appendChild(multiDragElement);
        }
      });
    }
    /**
     * Insert multi-drag clones
     * @param  {[Boolean]} elementsInserted  Whether the multi-drag elements are inserted
     * @param  {HTMLElement} rootEl
     */


    function insertMultiDragClones(elementsInserted, rootEl) {
      multiDragClones.forEach(function (clone, i) {
        var target = rootEl.children[clone.sortableIndex + (elementsInserted ? Number(i) : 0)];

        if (target) {
          rootEl.insertBefore(clone, target);
        } else {
          rootEl.appendChild(clone);
        }
      });
    }

    function removeMultiDragElements() {
      multiDragElements.forEach(function (multiDragElement) {
        if (multiDragElement === dragEl$1) return;
        multiDragElement.parentNode && multiDragElement.parentNode.removeChild(multiDragElement);
      });
    }

    Sortable.mount(new AutoScrollPlugin());
    Sortable.mount(Remove, Revert);

    Sortable.mount(new MultiDragPlugin());
    let SortableService = Sortable;

    /* src/layouts/config/song_list_tags/SelectedTagList.svelte generated by Svelte v3.49.0 */
    const file$a = "src/layouts/config/song_list_tags/SelectedTagList.svelte";

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[3] = list[i];
    	child_ctx[5] = i;
    	return child_ctx;
    }

    // (38:2) {#each $config.songListTags as tag, index (`${tag.value}
    function create_each_block$3(key_1, ctx) {
    	let first;
    	let selectedtag;
    	let current;

    	selectedtag = new SelectedTag({
    			props: {
    				tag: /*tag*/ ctx[3],
    				index: /*index*/ ctx[5]
    			},
    			$$inline: true
    		});

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(selectedtag.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(selectedtag, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const selectedtag_changes = {};
    			if (dirty & /*$config*/ 1) selectedtag_changes.tag = /*tag*/ ctx[3];
    			if (dirty & /*$config*/ 1) selectedtag_changes.index = /*index*/ ctx[5];
    			selectedtag.$set(selectedtag_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(selectedtag.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(selectedtag.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(selectedtag, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(38:2) {#each $config.songListTags as tag, index (`${tag.value}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$d(ctx) {
    	let selected_tags_list;
    	let ul;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let current;
    	let each_value = /*$config*/ ctx[0].songListTags;
    	validate_each_argument(each_value);
    	const get_key = ctx => `${/*tag*/ ctx[3].value}${/*index*/ ctx[5]}`;
    	validate_each_keys(ctx, each_value, get_each_context$3, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$3(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$3(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			selected_tags_list = element("selected-tags-list");
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(ul, "id", "items");
    			add_location(ul, file$a, 36, 1, 1117);
    			set_custom_element_data(selected_tags_list, "class", "svelte-5bkx7e");
    			add_location(selected_tags_list, file$a, 35, 0, 1095);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, selected_tags_list, anchor);
    			append_dev(selected_tags_list, ul);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$config*/ 1) {
    				each_value = /*$config*/ ctx[0].songListTags;
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$3, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, ul, outro_and_destroy_block, create_each_block$3, null, get_each_context$3);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(selected_tags_list);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let $config;
    	validate_store(config, 'config');
    	component_subscribe($$self, config, $$value => $$invalidate(0, $config = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SelectedTagList', slots, []);

    	function createSortableList() {
    		let el = document.querySelector('selected-tags-list ul');
    		if (el === undefined || el === null) return;

    		SortableService.create(el, {
    			animation: 150,
    			selectedClass: null,
    			onEnd: onDragEnd
    		});
    	}

    	function onDragEnd(evt) {
    		let ulElement = document.querySelector('selected-tags-list ul');
    		if (ulElement === undefined || ulElement === null) return;
    		let newTags = [];

    		ulElement.querySelectorAll('li').forEach(liElement => {
    			newTags.push({
    				align: liElement.dataset.align,
    				value: liElement.dataset.value,
    				isExpanded: liElement.dataset.isExpanded === 'true'
    			});
    		});

    		set_store_value(config, $config.songListTags = newTags, $config);
    	}

    	onMount(() => {
    		createSortableList();
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SelectedTagList> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		SelectedTag,
    		SortableService,
    		onMount,
    		config,
    		createSortableList,
    		onDragEnd,
    		$config
    	});

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$config*/ 1) {
    			if ($config.songListTags.length > 0) createSortableList();
    		}
    	};

    	return [$config];
    }

    class SelectedTagList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$d, create_fragment$d, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SelectedTagList",
    			options,
    			id: create_fragment$d.name
    		});
    	}
    }

    /* src/layouts/config/song_list_tags/SongListPreview.svelte generated by Svelte v3.49.0 */

    const file$9 = "src/layouts/config/song_list_tags/SongListPreview.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[5] = list[i];
    	child_ctx[7] = i;
    	return child_ctx;
    }

    // (66:52) 
    function create_if_block_2$1(ctx) {
    	let songtag;
    	let current;

    	songtag = new SongTag({
    			props: {
    				tagName: /*selectedTag*/ ctx[5].value,
    				tagValue: /*sampleSong*/ ctx[3][/*selectedTag*/ ctx[5].value] || '',
    				align: /*selectedTag*/ ctx[5]?.align?.toLowerCase()
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(songtag.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(songtag, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const songtag_changes = {};
    			if (dirty & /*$config*/ 1) songtag_changes.tagName = /*selectedTag*/ ctx[5].value;
    			if (dirty & /*$config*/ 1) songtag_changes.tagValue = /*sampleSong*/ ctx[3][/*selectedTag*/ ctx[5].value] || '';
    			if (dirty & /*$config*/ 1) songtag_changes.align = /*selectedTag*/ ctx[5]?.align?.toLowerCase();
    			songtag.$set(songtag_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(songtag.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(songtag.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(songtag, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(66:52) ",
    		ctx
    	});

    	return block;
    }

    // (60:3) {#if selectedTag.value === 'Title' && $songListTagsValuesStore.includes('DynamicArtists')}
    function create_if_block_1$1(ctx) {
    	let songtag;
    	let current;

    	songtag = new SongTag({
    			props: {
    				tagName: /*selectedTag*/ ctx[5].value,
    				tagValue: `${/*sampleSong*/ ctx[3].Title} ${/*sampleSong*/ ctx[3].DynamicArtists}` || '',
    				align: /*selectedTag*/ ctx[5]?.align?.toLowerCase()
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(songtag.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(songtag, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const songtag_changes = {};
    			if (dirty & /*$config*/ 1) songtag_changes.tagName = /*selectedTag*/ ctx[5].value;
    			if (dirty & /*$config*/ 1) songtag_changes.align = /*selectedTag*/ ctx[5]?.align?.toLowerCase();
    			songtag.$set(songtag_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(songtag.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(songtag.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(songtag, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(60:3) {#if selectedTag.value === 'Title' && $songListTagsValuesStore.includes('DynamicArtists')}",
    		ctx
    	});

    	return block;
    }

    // (59:2) {#each $config.songListTags as selectedTag, index (index)}
    function create_each_block$2(key_1, ctx) {
    	let first;
    	let show_if;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$1, create_if_block_2$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (dirty & /*$config, $songListTagsValuesStore*/ 5) show_if = null;
    		if (show_if == null) show_if = !!(/*selectedTag*/ ctx[5].value === 'Title' && /*$songListTagsValuesStore*/ ctx[2].includes('DynamicArtists'));
    		if (show_if) return 0;
    		if (/*selectedTag*/ ctx[5].value !== 'DynamicArtists') return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx, -1))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx, dirty);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					} else {
    						if_block.p(ctx, dirty);
    					}

    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(59:2) {#each $config.songListTags as selectedTag, index (index)}",
    		ctx
    	});

    	return block;
    }

    // (79:3) {:else}
    function create_else_block$1(ctx) {
    	let span;
    	let t;
    	let toggleofficon;
    	let current;

    	toggleofficon = new ToggleOffIcon({
    			props: {
    				style: "height: 1.25rem;fill:#fff;margin-left: 0.5rem;"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text("Dynamic Artists ");
    			create_component(toggleofficon.$$.fragment);
    			attr_dev(span, "class", "svelte-1ue41o0");
    			add_location(span, file$9, 79, 4, 2686);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    			mount_component(toggleofficon, span, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(toggleofficon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(toggleofficon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(toggleofficon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(79:3) {:else}",
    		ctx
    	});

    	return block;
    }

    // (77:3) {#if $songListTagsValuesStore.includes('DynamicArtists')}
    function create_if_block$2(ctx) {
    	let span;
    	let t;
    	let toggleonicon;
    	let current;

    	toggleonicon = new ToggleOnIcon({
    			props: {
    				style: "height: 1.25rem;fill:#fff;margin-left: 0.5rem;"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text("Dynamic Artists ");
    			create_component(toggleonicon.$$.fragment);
    			attr_dev(span, "class", "svelte-1ue41o0");
    			add_location(span, file$9, 77, 4, 2569);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    			mount_component(toggleonicon, span, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(toggleonicon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(toggleonicon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(toggleonicon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(77:3) {#if $songListTagsValuesStore.includes('DynamicArtists')}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$c(ctx) {
    	let song_list_preview;
    	let grid_tags;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let t;
    	let enable_dynamic_artists;
    	let button;
    	let show_if;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*$config*/ ctx[0].songListTags;
    	validate_each_argument(each_value);
    	const get_key = ctx => /*index*/ ctx[7];
    	validate_each_keys(ctx, each_value, get_each_context$2, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$2(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$2(key, child_ctx));
    	}

    	const if_block_creators = [create_if_block$2, create_else_block$1];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (dirty & /*$songListTagsValuesStore*/ 4) show_if = null;
    		if (show_if == null) show_if = !!/*$songListTagsValuesStore*/ ctx[2].includes('DynamicArtists');
    		if (show_if) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx, -1);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			song_list_preview = element("song-list-preview");
    			grid_tags = element("grid-tags");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			enable_dynamic_artists = element("enable-dynamic-artists");
    			button = element("button");
    			if_block.c();
    			set_style(grid_tags, "grid-template-columns", /*gridStyle*/ ctx[1]);
    			set_custom_element_data(grid_tags, "class", "svelte-1ue41o0");
    			add_location(grid_tags, file$9, 57, 1, 1814);
    			add_location(button, file$9, 75, 2, 2463);
    			set_custom_element_data(enable_dynamic_artists, "class", "svelte-1ue41o0");
    			add_location(enable_dynamic_artists, file$9, 74, 1, 2436);
    			set_custom_element_data(song_list_preview, "class", "svelte-1ue41o0");
    			add_location(song_list_preview, file$9, 56, 0, 1793);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, song_list_preview, anchor);
    			append_dev(song_list_preview, grid_tags);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(grid_tags, null);
    			}

    			append_dev(song_list_preview, t);
    			append_dev(song_list_preview, enable_dynamic_artists);
    			append_dev(enable_dynamic_artists, button);
    			if_blocks[current_block_type_index].m(button, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*toggleDynamicArtists*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$config, sampleSong, $songListTagsValuesStore*/ 13) {
    				each_value = /*$config*/ ctx[0].songListTags;
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$2, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, grid_tags, outro_and_destroy_block, create_each_block$2, null, get_each_context$2);
    				check_outros();
    			}

    			if (!current || dirty & /*gridStyle*/ 2) {
    				set_style(grid_tags, "grid-template-columns", /*gridStyle*/ ctx[1]);
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx, dirty);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(button, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(song_list_preview);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			if_blocks[current_block_type_index].d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let $config;
    	let $songListTagsValuesStore;
    	validate_store(config, 'config');
    	component_subscribe($$self, config, $$value => $$invalidate(0, $config = $$value));
    	validate_store(songListTagsValuesStore, 'songListTagsValuesStore');
    	component_subscribe($$self, songListTagsValuesStore, $$value => $$invalidate(2, $songListTagsValuesStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SongListPreview', slots, []);
    	let gridStyle = '';

    	let sampleSong = {
    		Album: 'Post Traumatic',
    		AlbumArtist: 'Mike Shinoda',
    		Artist: 'Mike Shinoda',
    		BitRate: 159.5405714285714,
    		Comment: 'This is a comment',
    		Composer: 'Mike Shinoda',
    		Date_Day: 15,
    		Date_Month: 6,
    		Date_Year: 2018,
    		DiscNumber: 1,
    		Duration: 204,
    		Extension: 'opus',
    		Genre: 'Hip hop',
    		Rating: 100,
    		SampleRate: 48000,
    		Size: 4078741,
    		Title: 'Running From My Shadow',
    		Track: 13,
    		PlayCount: 10,
    		DynamicArtists: '(feat. Mike Shinoda//Grandson)'
    	};

    	function toggleDynamicArtists() {
    		let dynamicArtistsTagIndex = $config.songListTags.findIndex(tag => tag.value === 'DynamicArtists');
    		let titleTagIndex = $config.songListTags.findIndex(tag => tag.value === 'Title');

    		if (dynamicArtistsTagIndex === -1) {
    			if (titleTagIndex === -1) {
    				$config.songListTags.push({
    					value: 'Title',
    					isExpanded: false,
    					align: 'center'
    				});
    			}

    			$config.songListTags.push({
    				value: 'DynamicArtists',
    				isExpanded: false,
    				align: 'center'
    			});
    		} else {
    			$config.songListTags.splice(dynamicArtistsTagIndex, 1);
    		}

    		config.set($config);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SongListPreview> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		SongTag,
    		tagToGridStyleFn,
    		ToggleOffIcon,
    		ToggleOnIcon,
    		config,
    		songListTagsValuesStore,
    		gridStyle,
    		sampleSong,
    		toggleDynamicArtists,
    		$config,
    		$songListTagsValuesStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('gridStyle' in $$props) $$invalidate(1, gridStyle = $$props.gridStyle);
    		if ('sampleSong' in $$props) $$invalidate(3, sampleSong = $$props.sampleSong);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$config*/ 1) {
    			{
    				$$invalidate(1, gridStyle = tagToGridStyleFn($config.songListTags));
    			}
    		}
    	};

    	return [$config, gridStyle, $songListTagsValuesStore, sampleSong, toggleDynamicArtists];
    }

    class SongListPreview extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$c, create_fragment$c, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SongListPreview",
    			options,
    			id: create_fragment$c.name
    		});
    	}
    }

    /* src/layouts/config/song_list_tags/!SongListTagsConfig.svelte generated by Svelte v3.49.0 */
    const file$8 = "src/layouts/config/song_list_tags/!SongListTagsConfig.svelte";

    function create_fragment$b(ctx) {
    	let song_list_tag_config;
    	let optionsection;
    	let t0;
    	let addsonglisttag;
    	let t1;
    	let selectedtaglist;
    	let t2;
    	let songlistpreview;
    	let current;

    	optionsection = new OptionSection({
    			props: { title: "Song List Tags" },
    			$$inline: true
    		});

    	addsonglisttag = new AddSongListTag({ $$inline: true });
    	selectedtaglist = new SelectedTagList({ $$inline: true });
    	songlistpreview = new SongListPreview({ $$inline: true });

    	const block = {
    		c: function create() {
    			song_list_tag_config = element("song-list-tag-config");
    			create_component(optionsection.$$.fragment);
    			t0 = space();
    			create_component(addsonglisttag.$$.fragment);
    			t1 = space();
    			create_component(selectedtaglist.$$.fragment);
    			t2 = space();
    			create_component(songlistpreview.$$.fragment);
    			set_custom_element_data(song_list_tag_config, "class", "svelte-1ubww35");
    			add_location(song_list_tag_config, file$8, 21, 0, 678);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, song_list_tag_config, anchor);
    			mount_component(optionsection, song_list_tag_config, null);
    			append_dev(song_list_tag_config, t0);
    			mount_component(addsonglisttag, song_list_tag_config, null);
    			append_dev(song_list_tag_config, t1);
    			mount_component(selectedtaglist, song_list_tag_config, null);
    			append_dev(song_list_tag_config, t2);
    			mount_component(songlistpreview, song_list_tag_config, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(optionsection.$$.fragment, local);
    			transition_in(addsonglisttag.$$.fragment, local);
    			transition_in(selectedtaglist.$$.fragment, local);
    			transition_in(songlistpreview.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(optionsection.$$.fragment, local);
    			transition_out(addsonglisttag.$$.fragment, local);
    			transition_out(selectedtaglist.$$.fragment, local);
    			transition_out(songlistpreview.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(song_list_tag_config);
    			destroy_component(optionsection);
    			destroy_component(addsonglisttag);
    			destroy_component(selectedtaglist);
    			destroy_component(songlistpreview);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
    	let $config;
    	validate_store(config, 'config');
    	component_subscribe($$self, config, $$value => $$invalidate(0, $config = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SongListTagsConfig', slots, []);
    	let isMounted = false;

    	function saveSelectedTagsToConfig(newSelectedTags) {
    		if (isMounted === true) {
    			window.ipc.saveConfig({ songListTags: newSelectedTags });
    		}
    	}

    	onMount(() => {
    		isMounted = true;
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SongListTagsConfig> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		OptionSection,
    		config,
    		AddSongListTag,
    		SelectedTagList,
    		SongListPreview,
    		isMounted,
    		saveSelectedTagsToConfig,
    		$config
    	});

    	$$self.$inject_state = $$props => {
    		if ('isMounted' in $$props) isMounted = $$props.isMounted;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$config*/ 1) {
    			// TODO Check this more in depth
    			saveSelectedTagsToConfig($config.songListTags);
    		}
    	};

    	return [$config];
    }

    class SongListTagsConfig extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$b, create_fragment$b, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SongListTagsConfig",
    			options,
    			id: create_fragment$b.name
    		});
    	}
    }

    /* src/layouts/config/ConfigLayout.svelte generated by Svelte v3.49.0 */
    const file$7 = "src/layouts/config/ConfigLayout.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[6] = list[i];
    	child_ctx[8] = i;
    	return child_ctx;
    }

    // (42:2) {#each options as option, index (index)}
    function create_each_block$1(key_1, ctx) {
    	let option_svlt;
    	let t_value = /*option*/ ctx[6].name + "";
    	let t;
    	let option_svlt_data_selected_value;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[4](/*option*/ ctx[6]);
    	}

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			option_svlt = element("option-svlt");
    			t = text(t_value);
    			set_custom_element_data(option_svlt, "data-selected", option_svlt_data_selected_value = /*selectedOption*/ ctx[0] === /*option*/ ctx[6].name);
    			set_custom_element_data(option_svlt, "class", "svelte-1n54e3u");
    			add_location(option_svlt, file$7, 42, 3, 1240);
    			this.first = option_svlt;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option_svlt, anchor);
    			append_dev(option_svlt, t);

    			if (!mounted) {
    				dispose = listen_dev(option_svlt, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*selectedOption*/ 1 && option_svlt_data_selected_value !== (option_svlt_data_selected_value = /*selectedOption*/ ctx[0] === /*option*/ ctx[6].name)) {
    				set_custom_element_data(option_svlt, "data-selected", option_svlt_data_selected_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option_svlt);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(42:2) {#each options as option, index (index)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$a(ctx) {
    	let config_layout_svlt;
    	let options_list;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let t;
    	let current_component_svlt;
    	let switch_instance;
    	let current;
    	let each_value = /*options*/ ctx[2];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*index*/ ctx[8];
    	validate_each_keys(ctx, each_value, get_each_context$1, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$1(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$1(key, child_ctx));
    	}

    	var switch_value = /*currentComponent*/ ctx[1];

    	function switch_props(ctx) {
    		return { $$inline: true };
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	const block = {
    		c: function create() {
    			config_layout_svlt = element("config-layout-svlt");
    			options_list = element("options-list");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			current_component_svlt = element("current-component-svlt");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			set_custom_element_data(options_list, "class", "svelte-1n54e3u");
    			add_location(options_list, file$7, 40, 1, 1179);
    			set_custom_element_data(current_component_svlt, "class", "svelte-1n54e3u");
    			add_location(current_component_svlt, file$7, 48, 1, 1410);
    			set_custom_element_data(config_layout_svlt, "class", "svelte-1n54e3u");
    			add_location(config_layout_svlt, file$7, 39, 0, 1157);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, config_layout_svlt, anchor);
    			append_dev(config_layout_svlt, options_list);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(options_list, null);
    			}

    			append_dev(config_layout_svlt, t);
    			append_dev(config_layout_svlt, current_component_svlt);

    			if (switch_instance) {
    				mount_component(switch_instance, current_component_svlt, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*selectedOption, options, loadComponent*/ 13) {
    				each_value = /*options*/ ctx[2];
    				validate_each_argument(each_value);
    				validate_each_keys(ctx, each_value, get_each_context$1, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, options_list, destroy_block, create_each_block$1, null, get_each_context$1);
    			}

    			if (switch_value !== (switch_value = /*currentComponent*/ ctx[1])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, current_component_svlt, null);
    				} else {
    					switch_instance = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(config_layout_svlt);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			if (switch_instance) destroy_component(switch_instance);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let $selectedConfigOptionName;
    	validate_store(selectedConfigOptionName, 'selectedConfigOptionName');
    	component_subscribe($$self, selectedConfigOptionName, $$value => $$invalidate(5, $selectedConfigOptionName = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ConfigLayout', slots, []);

    	const options = [
    		{
    			name: 'Appearance',
    			component: AppearanceConfig
    		},
    		{
    			name: 'Equalizer',
    			component: EqualizerConfig
    		},
    		{
    			name: 'Library',
    			component: LibraryConfig
    		},
    		{
    			name: 'Song List Tags',
    			component: SongListTagsConfig
    		}
    	];

    	let selectedOption = undefined;
    	let currentComponent = undefined;

    	function loadComponent(optionName) {
    		let option = options.find(option => option.name === optionName);

    		if (option.component && option.name) {
    			$$invalidate(1, currentComponent = option.component);
    			$$invalidate(0, selectedOption = option.name);
    			set_store_value(selectedConfigOptionName, $selectedConfigOptionName = option.name, $selectedConfigOptionName);
    		}
    	}

    	onMount(() => {
    		loadComponent($selectedConfigOptionName);
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ConfigLayout> was created with unknown prop '${key}'`);
    	});

    	const click_handler = option => loadComponent(option.name);

    	$$self.$capture_state = () => ({
    		onMount,
    		selectedConfigOptionName,
    		AppearanceConfig,
    		EqualizerConfig,
    		LibraryConfig,
    		SongListTagsConfig,
    		options,
    		selectedOption,
    		currentComponent,
    		loadComponent,
    		$selectedConfigOptionName
    	});

    	$$self.$inject_state = $$props => {
    		if ('selectedOption' in $$props) $$invalidate(0, selectedOption = $$props.selectedOption);
    		if ('currentComponent' in $$props) $$invalidate(1, currentComponent = $$props.currentComponent);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [selectedOption, currentComponent, options, loadComponent, click_handler];
    }

    class ConfigLayout extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$a, create_fragment$a, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ConfigLayout",
    			options,
    			id: create_fragment$a.name
    		});
    	}
    }

    function isArrayEqualFn (array1, array2) {
        if (array1.length !== array2.length) {
            return false;
        }
        for (let i = 0; i < array1.length; i++) {
            if (array1[i] !== array2[i]) {
                return false;
            }
        }
        return true;
    }

    function parseJsonFn (json) {
        try {
            return JSON.parse(json);
        }
        catch (e) {
            return {};
        }
    }

    /* src/middlewares/EventsHandlerMiddleware.svelte generated by Svelte v3.49.0 */

    function create_fragment$9(ctx) {
    	const block = {
    		c: noop,
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let $config;
    	let $activeSongStore;
    	let $songListStore;
    	let $selectedAlbumDir;
    	let $selectedSongsStore;
    	let $albumPlayingDirStore;
    	let $triggerScrollToSongEvent;
    	let $triggerGroupingChangeEvent;
    	let $playbackStore;
    	let $playingSongStore;
    	let $layoutToShow;
    	let $elementMap;
    	validate_store(config, 'config');
    	component_subscribe($$self, config, $$value => $$invalidate(0, $config = $$value));
    	validate_store(activeSongStore, 'activeSongStore');
    	component_subscribe($$self, activeSongStore, $$value => $$invalidate(1, $activeSongStore = $$value));
    	validate_store(songListStore, 'songListStore');
    	component_subscribe($$self, songListStore, $$value => $$invalidate(2, $songListStore = $$value));
    	validate_store(selectedAlbumDir, 'selectedAlbumDir');
    	component_subscribe($$self, selectedAlbumDir, $$value => $$invalidate(3, $selectedAlbumDir = $$value));
    	validate_store(selectedSongsStore, 'selectedSongsStore');
    	component_subscribe($$self, selectedSongsStore, $$value => $$invalidate(4, $selectedSongsStore = $$value));
    	validate_store(albumPlayingDirStore, 'albumPlayingDirStore');
    	component_subscribe($$self, albumPlayingDirStore, $$value => $$invalidate(5, $albumPlayingDirStore = $$value));
    	validate_store(triggerScrollToSongEvent, 'triggerScrollToSongEvent');
    	component_subscribe($$self, triggerScrollToSongEvent, $$value => $$invalidate(6, $triggerScrollToSongEvent = $$value));
    	validate_store(triggerGroupingChangeEvent, 'triggerGroupingChangeEvent');
    	component_subscribe($$self, triggerGroupingChangeEvent, $$value => $$invalidate(7, $triggerGroupingChangeEvent = $$value));
    	validate_store(playbackStore, 'playbackStore');
    	component_subscribe($$self, playbackStore, $$value => $$invalidate(8, $playbackStore = $$value));
    	validate_store(playingSongStore, 'playingSongStore');
    	component_subscribe($$self, playingSongStore, $$value => $$invalidate(9, $playingSongStore = $$value));
    	validate_store(layoutToShow, 'layoutToShow');
    	component_subscribe($$self, layoutToShow, $$value => $$invalidate(10, $layoutToShow = $$value));
    	validate_store(elementMap, 'elementMap');
    	component_subscribe($$self, elementMap, $$value => $$invalidate(11, $elementMap = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('EventsHandlerMiddleware', slots, []);

    	function handleClickEvents(evt) {
    		set_store_value(elementMap, $elementMap = new Map(), $elementMap);

    		evt.composedPath().forEach(element => {
    			if (element.tagName) {
    				$elementMap.set(element.tagName.toLowerCase(), element);
    			}
    		});

    		const imgElement = $elementMap.get('img');
    		const albumElement = $elementMap.get('album');
    		const songListItemElement = $elementMap.get('song-list-item');
    		const songListElement = $elementMap.get('song-list');
    		const controlBarElement = $elementMap.get('control-bar-svlt');
    		const tagEditElement = $elementMap.get('tag-edit-svlt');
    		if (albumElement) handleAlbumEvent(albumElement, evt.type);
    		if (songListItemElement) handleSongListItemEvent(songListItemElement, evt.type);
    		if (imgElement && controlBarElement) setAlbumBackInView();

    		if (songListElement === undefined && tagEditElement === undefined) {
    			set_store_value(selectedSongsStore, $selectedSongsStore = [], $selectedSongsStore);
    			set_store_value(activeSongStore, $activeSongStore = undefined, $activeSongStore);
    		}
    	}

    	function handleKeyboardEvents(evt) {
    		let keyModifier = {
    			ctrl: evt.ctrlKey || evt.metaKey,
    			shift: evt.shiftKey,
    			alt: evt.altKey
    		};

    		if (evt.key === 'a' && keyModifier.ctrl === true) {
    			const songListElement = $elementMap.get('song-list');

    			if (songListElement) {
    				set_store_value(selectedSongsStore, $selectedSongsStore = [...$songListStore.map(song => song.ID)], $selectedSongsStore);
    			}
    		}
    	}

    	// Applies the proper states that make the album visible (Proper grouping, song list, etc.).
    	function setAlbumBackInView() {
    		set_store_value(layoutToShow, $layoutToShow = 'Library', $layoutToShow);
    		let playingSong = $playingSongStore;
    		set_store_value(selectedAlbumDir, $selectedAlbumDir = $albumPlayingDirStore, $selectedAlbumDir);
    		set_store_value(songListStore, $songListStore = sortSongsArrayFn($playbackStore, $config.userOptions.sortBy, $config.userOptions.sortOrder), $songListStore);
    		let groupByValuesLocalStorage = parseJsonFn(localStorage.getItem('GroupByValues'));

    		if (!isArrayEqualFn(groupByValuesLocalStorage, $config.group.groupByValues)) {
    			set_store_value(triggerGroupingChangeEvent, $triggerGroupingChangeEvent = groupByValuesLocalStorage, $triggerGroupingChangeEvent);
    		}

    		set_store_value(triggerScrollToSongEvent, $triggerScrollToSongEvent = playingSong.ID, $triggerScrollToSongEvent);
    		set_store_value(selectedSongsStore, $selectedSongsStore = [playingSong.ID], $selectedSongsStore);

    		setTimeout(
    			() => {
    				scrollToAlbumFn($albumPlayingDirStore, 'not-smooth-scroll');
    			},
    			250
    		);
    	}

    	async function handleAlbumEvent(element, evtType) {
    		const rootDir = element.getAttribute('rootDir');
    		let songs = await getAlbumSongsFn(rootDir);
    		let sortedSongs = sortSongsArrayFn(songs, $config.userOptions.sortBy, $config.userOptions.sortOrder);

    		if (evtType === 'dblclick') {
    			setNewPlaybackFn(rootDir, sortedSongs, undefined, { playNow: true });
    			saveGroupingConfig();
    		} else if (evtType === 'click') {
    			// Prevents resetting array if album unchanged.
    			if ($selectedAlbumDir !== rootDir) {
    				set_store_value(songListStore, $songListStore = sortedSongs, $songListStore);
    				set_store_value(selectedAlbumDir, $selectedAlbumDir = rootDir, $selectedAlbumDir);
    			}

    			// When clicking on an album, reset selected songs. Prevents songs from being selected after changing albums.
    			set_store_value(selectedSongsStore, $selectedSongsStore = [], $selectedSongsStore);
    		}
    	}

    	function handleSongListItemEvent(element, evtType) {
    		const songId = +element.dataset.id;

    		if (evtType === 'dblclick') {
    			setNewPlaybackFn($selectedAlbumDir, $songListStore, songId, { playNow: true });
    			saveGroupingConfig();
    		}

    		set_store_value(activeSongStore, $activeSongStore = undefined, $activeSongStore);
    	}

    	function saveGroupingConfig() {
    		localStorage.setItem('GroupByValues', JSON.stringify($config.group.groupByValues));

    		// Saves the grouping
    		window.ipc.saveConfig({
    			group: {
    				groupBy: $config.group.groupBy,
    				groupByValues: $config.group.groupByValues
    			}
    		});
    	}

    	onMount(() => {
    		['click', 'dblclick', 'contextmenu'].forEach(evtType => document.addEventListener(evtType, evt => handleClickEvents(evt)));
    		['keydown'].forEach(evtType => document.addEventListener(evtType, evt => handleKeyboardEvents(evt)));
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<EventsHandlerMiddleware> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		getAlbumSongsFn,
    		isArrayEqualFn,
    		parseJsonFn,
    		scrollToAlbumFn,
    		setNewPlaybackFn,
    		sortSongsArrayFn,
    		albumPlayingDirStore,
    		activeSongStore,
    		config,
    		elementMap,
    		layoutToShow,
    		playbackStore,
    		playingSongStore,
    		selectedAlbumDir,
    		selectedSongsStore,
    		songListStore,
    		triggerGroupingChangeEvent,
    		triggerScrollToSongEvent,
    		handleClickEvents,
    		handleKeyboardEvents,
    		setAlbumBackInView,
    		handleAlbumEvent,
    		handleSongListItemEvent,
    		saveGroupingConfig,
    		$config,
    		$activeSongStore,
    		$songListStore,
    		$selectedAlbumDir,
    		$selectedSongsStore,
    		$albumPlayingDirStore,
    		$triggerScrollToSongEvent,
    		$triggerGroupingChangeEvent,
    		$playbackStore,
    		$playingSongStore,
    		$layoutToShow,
    		$elementMap
    	});

    	return [];
    }

    class EventsHandlerMiddleware extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$9, create_fragment$9, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EventsHandlerMiddleware",
    			options,
    			id: create_fragment$9.name
    		});
    	}
    }

    function getClosestElementFn (element, selector) {
        return element.closest(selector);
    }

    /* src/layouts/playback/PlaybackLayout.svelte generated by Svelte v3.49.0 */
    const file$6 = "src/layouts/playback/PlaybackLayout.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (60:2) {#each $playbackStore as song, index (song.ID)}
    function create_each_block(key_1, ctx) {
    	let li;
    	let span0;
    	let t0_value = /*song*/ ctx[8].Track + "";
    	let t0;
    	let t1;
    	let span1;
    	let t2_value = /*song*/ ctx[8].Title + "";
    	let t2;
    	let t3;
    	let span2;
    	let t4_value = /*song*/ ctx[8].SampleRate + "";
    	let t4;
    	let t5;
    	let li_class_value;
    	let li_data_song_id_value;
    	let li_data_index_value;

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			li = element("li");
    			span0 = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			span1 = element("span");
    			t2 = text(t2_value);
    			t3 = space();
    			span2 = element("span");
    			t4 = text(t4_value);
    			t5 = space();
    			add_location(span0, file$6, 67, 4, 2463);
    			add_location(span1, file$6, 68, 4, 2493);
    			add_location(span2, file$6, 69, 4, 2523);

    			attr_dev(li, "class", li_class_value = "" + (null_to_empty(/*selectedSongsId*/ ctx[1].includes(/*song*/ ctx[8].ID)
    			? 'selected'
    			: null) + " svelte-ty0vqa"));

    			attr_dev(li, "data-song-id", li_data_song_id_value = /*song*/ ctx[8].ID);
    			attr_dev(li, "data-index", li_data_index_value = /*index*/ ctx[10]);
    			add_location(li, file$6, 60, 3, 2187);
    			this.first = li;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, span0);
    			append_dev(span0, t0);
    			append_dev(li, t1);
    			append_dev(li, span1);
    			append_dev(span1, t2);
    			append_dev(li, t3);
    			append_dev(li, span2);
    			append_dev(span2, t4);
    			append_dev(li, t5);
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*$playbackStore*/ 1 && t0_value !== (t0_value = /*song*/ ctx[8].Track + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$playbackStore*/ 1 && t2_value !== (t2_value = /*song*/ ctx[8].Title + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*$playbackStore*/ 1 && t4_value !== (t4_value = /*song*/ ctx[8].SampleRate + "")) set_data_dev(t4, t4_value);

    			if (dirty & /*selectedSongsId, $playbackStore*/ 3 && li_class_value !== (li_class_value = "" + (null_to_empty(/*selectedSongsId*/ ctx[1].includes(/*song*/ ctx[8].ID)
    			? 'selected'
    			: null) + " svelte-ty0vqa"))) {
    				attr_dev(li, "class", li_class_value);
    			}

    			if (dirty & /*$playbackStore*/ 1 && li_data_song_id_value !== (li_data_song_id_value = /*song*/ ctx[8].ID)) {
    				attr_dev(li, "data-song-id", li_data_song_id_value);
    			}

    			if (dirty & /*$playbackStore*/ 1 && li_data_index_value !== (li_data_index_value = /*index*/ ctx[10])) {
    				attr_dev(li, "data-index", li_data_index_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(60:2) {#each $playbackStore as song, index (song.ID)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$8(ctx) {
    	let selected_songs_preview;
    	let t;
    	let playback_layout;
    	let ul;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let mounted;
    	let dispose;
    	let each_value = /*$playbackStore*/ ctx[0];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*song*/ ctx[8].ID;
    	validate_each_keys(ctx, each_value, get_each_context, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			selected_songs_preview = element("selected-songs-preview");
    			t = space();
    			playback_layout = element("playback-layout");
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			set_custom_element_data(selected_songs_preview, "class", "svelte-ty0vqa");
    			add_location(selected_songs_preview, file$6, 55, 0, 2036);
    			attr_dev(ul, "id", "items");
    			add_location(ul, file$6, 58, 1, 2118);
    			set_custom_element_data(playback_layout, "class", "svelte-ty0vqa");
    			add_location(playback_layout, file$6, 57, 0, 2064);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, selected_songs_preview, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, playback_layout, anchor);
    			append_dev(playback_layout, ul);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			if (!mounted) {
    				dispose = listen_dev(playback_layout, "dblclick", /*dblclick_handler*/ ctx[3], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*selectedSongsId, $playbackStore*/ 3) {
    				each_value = /*$playbackStore*/ ctx[0];
    				validate_each_argument(each_value);
    				validate_each_keys(ctx, each_value, get_each_context, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, ul, destroy_block, create_each_block, null, get_each_context);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(selected_songs_preview);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(playback_layout);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let $playbackStore;
    	validate_store(playbackStore, 'playbackStore');
    	component_subscribe($$self, playbackStore, $$value => $$invalidate(0, $playbackStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PlaybackLayout', slots, []);
    	let selectedSongsId = [];

    	function createSortableList() {
    		let el = document.querySelector('playback-layout ul');
    		if (el === undefined || el === null) return;

    		SortableService.create(el, {
    			multiDrag: true,
    			animation: 150,
    			selectedClass: null,
    			onEnd: onDragEnd,
    			onSelect,
    			onDeselect
    		});
    	}

    	function onSelect(evt) {
    		$$invalidate(1, selectedSongsId = evt.items.map(liElement => Number(liElement.dataset.songId)));
    	}

    	function onDeselect(evt) {
    		$$invalidate(1, selectedSongsId = []);
    	}

    	function onDragEnd(evt) {
    		let ulElement = document.querySelector('playback-layout ul');
    		if (ulElement === undefined || ulElement === null) return;
    		let newOrder = [];

    		ulElement.querySelectorAll('li').forEach(liElement => {
    			newOrder.push($playbackStore.find(song => song.ID === Number(liElement.dataset.songId)));
    		});

    		set_store_value(playbackStore, $playbackStore = newOrder, $playbackStore);
    	}

    	function playSong(evt) {
    		var _a, _b;
    		let listElement = getClosestElementFn(evt.target, 'li');
    		if (listElement === undefined || listElement === null) return;

    		let songId = (_a = listElement === null || listElement === void 0
    		? void 0
    		: listElement.dataset) === null || _a === void 0
    		? void 0
    		: _a.songId;

    		if (songId === undefined || songId === null) return;

    		let songSourceFile = (_b = $playbackStore.find(song => song.ID === Number(songId))) === null || _b === void 0
    		? void 0
    		: _b.SourceFile;

    		if (songSourceFile === undefined || songSourceFile === null) return;
    		songToPlayUrlStore.set([songSourceFile, { playNow: true }]);
    	}

    	onMount(() => {
    		createSortableList();
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PlaybackLayout> was created with unknown prop '${key}'`);
    	});

    	const dblclick_handler = evt => playSong(evt);

    	$$self.$capture_state = () => ({
    		onMount,
    		getClosestElementFn,
    		SortableService,
    		playbackStore,
    		songToPlayUrlStore,
    		selectedSongsId,
    		createSortableList,
    		onSelect,
    		onDeselect,
    		onDragEnd,
    		playSong,
    		$playbackStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('selectedSongsId' in $$props) $$invalidate(1, selectedSongsId = $$props.selectedSongsId);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$playbackStore*/ 1) {
    			if ($playbackStore.length > 0) createSortableList();
    		}
    	};

    	return [$playbackStore, selectedSongsId, playSong, dblclick_handler];
    }

    class PlaybackLayout extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$8, create_fragment$8, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PlaybackLayout",
    			options,
    			id: create_fragment$8.name
    		});
    	}
    }

    /* src/svelte_services/EqualizerService.svelte generated by Svelte v3.49.0 */

    function create_fragment$7(ctx) {
    	const block = {
    		c: noop,
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let $isEqualizerDirty;
    	let $equalizer;
    	let $selectedEqName;
    	let $equalizerProfiles;
    	let $isEqualizerOn;
    	validate_store(isEqualizerDirty, 'isEqualizerDirty');
    	component_subscribe($$self, isEqualizerDirty, $$value => $$invalidate(8, $isEqualizerDirty = $$value));
    	validate_store(equalizer, 'equalizer');
    	component_subscribe($$self, equalizer, $$value => $$invalidate(6, $equalizer = $$value));
    	validate_store(selectedEqName, 'selectedEqName');
    	component_subscribe($$self, selectedEqName, $$value => $$invalidate(9, $selectedEqName = $$value));
    	validate_store(equalizerProfiles, 'equalizerProfiles');
    	component_subscribe($$self, equalizerProfiles, $$value => $$invalidate(10, $equalizerProfiles = $$value));
    	validate_store(isEqualizerOn, 'isEqualizerOn');
    	component_subscribe($$self, isEqualizerOn, $$value => $$invalidate(11, $isEqualizerOn = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('EqualizerService', slots, []);

    	function changeProfile(id) {
    		if ($isEqualizerOn === false && $selectedEqName === id) {
    			resetEqualizer();
    		} else {
    			set_store_value(selectedEqName, $selectedEqName = id, $selectedEqName);
    		}

    		set_store_value(isEqualizerOn, $isEqualizerOn = true, $isEqualizerOn);
    	}

    	function updateEqualizer() {
    		let equalizerFound = $equalizerProfiles.find(x => x.name === $selectedEqName);
    		let newValues = {};
    		objectToArrayFn($equalizer).forEach(x => newValues[x.frequency.value] = x.gain.value);

    		window.ipc.updateEqualizerValues(equalizerFound.name, newValues).then(isEqualizerUpdated => {
    			if (isEqualizerUpdated) {
    				equalizerFound.values = newValues;
    				equalizerProfiles.set($equalizerProfiles);
    				set_store_value(isEqualizerDirty, $isEqualizerDirty = false, $isEqualizerDirty);
    				notifyService.success('Equalizer Updated');
    			}
    		});
    	}

    	function gainChange(evt, frequency) {
    		const target = evt.target;
    		const value = Number(target.value);
    		set_store_value(equalizer, $equalizer[frequency].gain.value = value, $equalizer);
    	}

    	function getEqualizerName(eqName) {
    		let equalizerProfileFound = $equalizerProfiles.find(x => x.name === eqName);

    		if (equalizerProfileFound) {
    			return (equalizerProfileFound === null || equalizerProfileFound === void 0
    			? void 0
    			: equalizerProfileFound.name) || 'No Name';
    		}
    	}

    	let tempEq = { name: 'Temp Equalizer', values: {} };

    	function toggleEq() {
    		if ($isEqualizerOn === true) {
    			// Turn off
    			set_store_value(isEqualizerOn, $isEqualizerOn = false, $isEqualizerOn);

    			for (let Hz in $equalizer) {
    				tempEq.values[Hz] = $equalizer[Hz].gain.value;
    				set_store_value(equalizer, $equalizer[Hz].gain.value = 0, $equalizer);
    			}
    		} else {
    			// Turn on
    			set_store_value(isEqualizerOn, $isEqualizerOn = true, $isEqualizerOn);

    			applyEqualizerProfile(tempEq.values);
    		}
    	}

    	function resetEqualizer() {
    		applyEqualizerProfile($equalizerProfiles.find(x => x.name === $selectedEqName).values);
    	}

    	function applyEqualizerProfile(values) {
    		for (let Hz in $equalizer) {
    			set_store_value(equalizer, $equalizer[Hz].gain.value = values[Hz], $equalizer);
    		}
    	}

    	function checkIfEqualizerChanged() {
    		let isChanged = false;
    		let equalizerSelected = $equalizerProfiles.find(x => x.name === $selectedEqName);
    		if (equalizerSelected === undefined) return;

    		for (let Hz in $equalizer) {
    			if ($equalizer[Hz].gain.value !== equalizerSelected.values[Hz]) {
    				isChanged = true;
    			}
    		}

    		set_store_value(isEqualizerDirty, $isEqualizerDirty = isChanged, $isEqualizerDirty);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<EqualizerService> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		objectToArrayFn,
    		notify: notifyService,
    		equalizer,
    		equalizerProfiles,
    		selectedEqName,
    		isEqualizerDirty,
    		isEqualizerOn,
    		changeProfile,
    		updateEqualizer,
    		gainChange,
    		getEqualizerName,
    		tempEq,
    		toggleEq,
    		resetEqualizer,
    		applyEqualizerProfile,
    		checkIfEqualizerChanged,
    		$isEqualizerDirty,
    		$equalizer,
    		$selectedEqName,
    		$equalizerProfiles,
    		$isEqualizerOn
    	});

    	$$self.$inject_state = $$props => {
    		if ('tempEq' in $$props) tempEq = $$props.tempEq;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$equalizer*/ 64) {
    			{
    				checkIfEqualizerChanged();
    			}
    		}
    	};

    	return [
    		changeProfile,
    		updateEqualizer,
    		gainChange,
    		getEqualizerName,
    		toggleEq,
    		resetEqualizer,
    		$equalizer
    	];
    }

    class EqualizerService extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$7, create_fragment$7, safe_not_equal, {
    			changeProfile: 0,
    			updateEqualizer: 1,
    			gainChange: 2,
    			getEqualizerName: 3,
    			toggleEq: 4,
    			resetEqualizer: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EqualizerService",
    			options,
    			id: create_fragment$7.name
    		});
    	}

    	get changeProfile() {
    		return this.$$.ctx[0];
    	}

    	set changeProfile(value) {
    		throw new Error("<EqualizerService>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get updateEqualizer() {
    		return this.$$.ctx[1];
    	}

    	set updateEqualizer(value) {
    		throw new Error("<EqualizerService>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get gainChange() {
    		return this.$$.ctx[2];
    	}

    	set gainChange(value) {
    		throw new Error("<EqualizerService>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getEqualizerName() {
    		return this.$$.ctx[3];
    	}

    	set getEqualizerName(value) {
    		throw new Error("<EqualizerService>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get toggleEq() {
    		return this.$$.ctx[4];
    	}

    	set toggleEq(value) {
    		throw new Error("<EqualizerService>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get resetEqualizer() {
    		return this.$$.ctx[5];
    	}

    	set resetEqualizer(value) {
    		throw new Error("<EqualizerService>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/icons/CheckIcon.svelte generated by Svelte v3.49.0 */

    const file$5 = "src/icons/CheckIcon.svelte";

    function create_fragment$6(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill", "none");
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			add_location(path0, file$5, 6, 2, 159);
    			attr_dev(path1, "d", "M12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10-4.477 10-10 10zm-.997-6l7.07-7.071-1.414-1.414-5.656 5.657-2.829-2.829-1.414 1.414L11.003 16z");
    			add_location(path1, file$5, 6, 40, 197);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "style", /*style*/ ctx[0]);
    			add_location(svg, file$5, 5, 0, 89);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*style*/ 1) {
    				attr_dev(svg, "style", /*style*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CheckIcon', slots, []);
    	let { style = '' } = $$props;
    	const writable_props = ['style'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CheckIcon> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	$$self.$capture_state = () => ({ style });

    	$$self.$inject_state = $$props => {
    		if ('style' in $$props) $$invalidate(0, style = $$props.style);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [style];
    }

    class CheckIcon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$6, create_fragment$6, safe_not_equal, { style: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CheckIcon",
    			options,
    			id: create_fragment$6.name
    		});
    	}

    	get style() {
    		throw new Error("<CheckIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<CheckIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/svelte_services/PromptService.svelte generated by Svelte v3.49.0 */

    const { Object: Object_1 } = globals;
    const file$4 = "src/svelte_services/PromptService.svelte";

    function create_fragment$5(ctx) {
    	let prompt_svlt;
    	let prompt_content;
    	let prompt_close;
    	let t1;
    	let prompt_title;
    	let t2_value = /*promptState*/ ctx[2].title + "";
    	let t2;
    	let t3;
    	let prompt_body;
    	let input;
    	let input_placeholder_value;
    	let t4;
    	let prompt_footer;
    	let button0;
    	let deleteicon;
    	let t5;
    	let t6_value = /*promptState*/ ctx[2].cancelButtonText + "";
    	let t6;
    	let t7;
    	let button1;
    	let checkicon;
    	let t8;
    	let t9_value = /*promptState*/ ctx[2].confirmButtonText + "";
    	let t9;
    	let current;
    	let mounted;
    	let dispose;

    	deleteicon = new DeleteIcon({
    			props: {
    				style: "height:1rem;width:auto;fill:#fff;margin-right:0.25rem;"
    			},
    			$$inline: true
    		});

    	checkicon = new CheckIcon({
    			props: {
    				style: "height:1rem;width:auto;fill:#fff;margin-right:0.25rem;"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			prompt_svlt = element("prompt-svlt");
    			prompt_content = element("prompt-content");
    			prompt_close = element("prompt-close");
    			prompt_close.textContent = "x";
    			t1 = space();
    			prompt_title = element("prompt-title");
    			t2 = text(t2_value);
    			t3 = space();
    			prompt_body = element("prompt-body");
    			input = element("input");
    			t4 = space();
    			prompt_footer = element("prompt-footer");
    			button0 = element("button");
    			create_component(deleteicon.$$.fragment);
    			t5 = space();
    			t6 = text(t6_value);
    			t7 = space();
    			button1 = element("button");
    			create_component(checkicon.$$.fragment);
    			t8 = space();
    			t9 = text(t9_value);
    			set_custom_element_data(prompt_close, "class", "svelte-sgbza9");
    			add_location(prompt_close, file$4, 74, 2, 2128);
    			set_custom_element_data(prompt_title, "class", "svelte-sgbza9");
    			add_location(prompt_title, file$4, 75, 2, 2192);
    			attr_dev(input, "slot", "body");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "placeholder", input_placeholder_value = /*promptState*/ ctx[2].placeholder);
    			attr_dev(input, "class", "svelte-sgbza9");
    			add_location(input, file$4, 77, 3, 2260);
    			set_custom_element_data(prompt_body, "class", "svelte-sgbza9");
    			add_location(prompt_body, file$4, 76, 2, 2243);
    			attr_dev(button0, "class", "cancel svelte-sgbza9");
    			add_location(button0, file$4, 86, 3, 2463);
    			attr_dev(button1, "class", "confirm svelte-sgbza9");
    			add_location(button1, file$4, 90, 3, 2651);
    			set_custom_element_data(prompt_footer, "class", "svelte-sgbza9");
    			add_location(prompt_footer, file$4, 85, 2, 2444);
    			set_custom_element_data(prompt_content, "class", "svelte-sgbza9");
    			add_location(prompt_content, file$4, 73, 1, 2109);
    			set_custom_element_data(prompt_svlt, "show", /*isPromptVisible*/ ctx[1]);
    			set_custom_element_data(prompt_svlt, "class", "svelte-sgbza9");
    			add_location(prompt_svlt, file$4, 72, 0, 2027);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, prompt_svlt, anchor);
    			append_dev(prompt_svlt, prompt_content);
    			append_dev(prompt_content, prompt_close);
    			append_dev(prompt_content, t1);
    			append_dev(prompt_content, prompt_title);
    			append_dev(prompt_title, t2);
    			append_dev(prompt_content, t3);
    			append_dev(prompt_content, prompt_body);
    			append_dev(prompt_body, input);
    			set_input_value(input, /*inputValue*/ ctx[3]);
    			append_dev(prompt_content, t4);
    			append_dev(prompt_content, prompt_footer);
    			append_dev(prompt_footer, button0);
    			mount_component(deleteicon, button0, null);
    			append_dev(button0, t5);
    			append_dev(button0, t6);
    			append_dev(prompt_footer, t7);
    			append_dev(prompt_footer, button1);
    			mount_component(checkicon, button1, null);
    			append_dev(button1, t8);
    			append_dev(button1, t9);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(prompt_close, "click", /*click_handler*/ ctx[10], false, false, false),
    					listen_dev(input, "input", /*input_input_handler*/ ctx[11]),
    					listen_dev(input, "keypress", /*keypress_handler*/ ctx[12], false, false, false),
    					listen_dev(button0, "click", /*click_handler_1*/ ctx[13], false, false, false),
    					listen_dev(button1, "click", /*click_handler_2*/ ctx[14], false, false, false),
    					listen_dev(prompt_svlt, "click", /*click_handler_3*/ ctx[15], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*promptState*/ 4) && t2_value !== (t2_value = /*promptState*/ ctx[2].title + "")) set_data_dev(t2, t2_value);

    			if (!current || dirty & /*promptState*/ 4 && input_placeholder_value !== (input_placeholder_value = /*promptState*/ ctx[2].placeholder)) {
    				attr_dev(input, "placeholder", input_placeholder_value);
    			}

    			if (dirty & /*inputValue*/ 8 && input.value !== /*inputValue*/ ctx[3]) {
    				set_input_value(input, /*inputValue*/ ctx[3]);
    			}

    			if ((!current || dirty & /*promptState*/ 4) && t6_value !== (t6_value = /*promptState*/ ctx[2].cancelButtonText + "")) set_data_dev(t6, t6_value);
    			if ((!current || dirty & /*promptState*/ 4) && t9_value !== (t9_value = /*promptState*/ ctx[2].confirmButtonText + "")) set_data_dev(t9, t9_value);

    			if (!current || dirty & /*isPromptVisible*/ 2) {
    				set_custom_element_data(prompt_svlt, "show", /*isPromptVisible*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(deleteicon.$$.fragment, local);
    			transition_in(checkicon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(deleteicon.$$.fragment, local);
    			transition_out(checkicon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(prompt_svlt);
    			destroy_component(deleteicon);
    			destroy_component(checkicon);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let $keyPressed;
    	validate_store(keyPressed, 'keyPressed');
    	component_subscribe($$self, keyPressed, $$value => $$invalidate(9, $keyPressed = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PromptService', slots, []);
    	let isPromptVisible = false;

    	let promptState = {
    		title: '',
    		cancelButtonText: '',
    		confirmButtonText: '',
    		data: {},
    		placeholder: '',
    		validateFn: undefined
    	};

    	let promptElement = undefined;
    	let inputValue = '';
    	let deferredPromise = undefined;

    	function showPrompt(newState) {
    		return new Promise((resolve, reject) => {
    				$$invalidate(2, promptState = newState);
    				deferredPromise = resolve;
    				$$invalidate(1, isPromptVisible = true);
    			});
    	}

    	function closePrompt() {
    		deferredPromise = undefined;
    		$$invalidate(1, isPromptVisible = false);
    	}

    	function setInputValueFromData() {
    		var _a;

    		$$invalidate(3, inputValue = ((_a = promptState === null || promptState === void 0
    		? void 0
    		: promptState.data) === null || _a === void 0
    		? void 0
    		: _a.inputValue) || '');
    	}

    	function confirmPrompt() {
    		let validatedInput = promptState.validateFn(inputValue);

    		if (validatedInput.isValid === true) {
    			deferredPromise({
    				data: Object.assign(promptState.data, { result: inputValue })
    			});
    		} else {
    			notifyService.error(validatedInput.errorMessage);
    		}
    	}

    	function handleOutsidePromptClick(e) {
    		let doClosePrompt = true;

    		e.composedPath().forEach(element => {
    			if (element.tagName === 'PROMPT-CONTENT') {
    				doClosePrompt = false;
    			}
    		});

    		if (doClosePrompt) closePrompt();
    	}

    	function handleInputKeypress(evt) {
    		if (evt.key === 'Enter') confirmPrompt();
    	}

    	const writable_props = [];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PromptService> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => closePrompt();

    	function input_input_handler() {
    		inputValue = this.value;
    		$$invalidate(3, inputValue);
    	}

    	const keypress_handler = evt => handleInputKeypress(evt);
    	const click_handler_1 = () => closePrompt();
    	const click_handler_2 = () => confirmPrompt();
    	const click_handler_3 = e => handleOutsidePromptClick(e);

    	$$self.$capture_state = () => ({
    		CheckIcon,
    		DeleteIcon,
    		notifyService,
    		keyPressed,
    		isPromptVisible,
    		promptState,
    		promptElement,
    		inputValue,
    		deferredPromise,
    		showPrompt,
    		closePrompt,
    		setInputValueFromData,
    		confirmPrompt,
    		handleOutsidePromptClick,
    		handleInputKeypress,
    		$keyPressed
    	});

    	$$self.$inject_state = $$props => {
    		if ('isPromptVisible' in $$props) $$invalidate(1, isPromptVisible = $$props.isPromptVisible);
    		if ('promptState' in $$props) $$invalidate(2, promptState = $$props.promptState);
    		if ('promptElement' in $$props) $$invalidate(8, promptElement = $$props.promptElement);
    		if ('inputValue' in $$props) $$invalidate(3, inputValue = $$props.inputValue);
    		if ('deferredPromise' in $$props) deferredPromise = $$props.deferredPromise;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*isPromptVisible, promptElement*/ 258) {
    			{
    				if (isPromptVisible === true) {
    					if (promptElement === undefined) {
    						$$invalidate(8, promptElement = document.querySelector('prompt-svlt input'));
    					}

    					promptElement.focus();
    				}
    			}
    		}

    		if ($$self.$$.dirty & /*$keyPressed, isPromptVisible*/ 514) {
    			if ($keyPressed === 'Escape' && isPromptVisible === true) closePrompt();
    		}

    		if ($$self.$$.dirty & /*promptState*/ 4) {
    			{
    				setInputValueFromData();
    			}
    		}
    	};

    	return [
    		closePrompt,
    		isPromptVisible,
    		promptState,
    		inputValue,
    		confirmPrompt,
    		handleOutsidePromptClick,
    		handleInputKeypress,
    		showPrompt,
    		promptElement,
    		$keyPressed,
    		click_handler,
    		input_input_handler,
    		keypress_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3
    	];
    }

    class PromptService extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$5, create_fragment$5, safe_not_equal, { showPrompt: 7, closePrompt: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PromptService",
    			options,
    			id: create_fragment$5.name
    		});
    	}

    	get showPrompt() {
    		return this.$$.ctx[7];
    	}

    	set showPrompt(value) {
    		throw new Error("<PromptService>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get closePrompt() {
    		return this.$$.ctx[0];
    	}

    	set closePrompt(value) {
    		throw new Error("<PromptService>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/svelte_services/ConfirmService.svelte generated by Svelte v3.49.0 */
    const file$3 = "src/svelte_services/ConfirmService.svelte";

    function create_fragment$4(ctx) {
    	let confirm_svlt;
    	let confirm_content;
    	let confirm_close;
    	let t1;
    	let confirm_title;
    	let t2_value = /*confirmState*/ ctx[2].title + "";
    	let t2;
    	let t3;
    	let confirm_body;
    	let t4_value = /*confirmState*/ ctx[2].textToConfirm + "";
    	let t4;
    	let t5;
    	let confirm_footer;
    	let button0;
    	let deleteicon;
    	let t6;
    	let t7;
    	let button1;
    	let checkicon;
    	let t8;
    	let current;
    	let mounted;
    	let dispose;

    	deleteicon = new DeleteIcon({
    			props: {
    				style: "height:1rem;width:auto;fill:#fff;margin-right:0.25rem;"
    			},
    			$$inline: true
    		});

    	checkicon = new CheckIcon({
    			props: {
    				style: "height:1rem;width:auto;fill:#fff;margin-right:0.25rem;"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			confirm_svlt = element("confirm-svlt");
    			confirm_content = element("confirm-content");
    			confirm_close = element("confirm-close");
    			confirm_close.textContent = "x";
    			t1 = space();
    			confirm_title = element("confirm-title");
    			t2 = text(t2_value);
    			t3 = space();
    			confirm_body = element("confirm-body");
    			t4 = text(t4_value);
    			t5 = space();
    			confirm_footer = element("confirm-footer");
    			button0 = element("button");
    			create_component(deleteicon.$$.fragment);
    			t6 = text("\n\t\t\t\tCancel");
    			t7 = space();
    			button1 = element("button");
    			create_component(checkicon.$$.fragment);
    			t8 = text("\n\t\t\t\tConfirm");
    			set_custom_element_data(confirm_close, "class", "svelte-c1prmq");
    			add_location(confirm_close, file$3, 42, 2, 1237);
    			set_custom_element_data(confirm_title, "class", "svelte-c1prmq");
    			add_location(confirm_title, file$3, 43, 2, 1304);
    			set_custom_element_data(confirm_body, "class", "svelte-c1prmq");
    			add_location(confirm_body, file$3, 44, 2, 1358);
    			attr_dev(button0, "class", "cancel svelte-c1prmq");
    			add_location(button0, file$3, 48, 3, 1445);
    			attr_dev(button1, "class", "confirm svelte-c1prmq");
    			add_location(button1, file$3, 52, 3, 1610);
    			set_custom_element_data(confirm_footer, "class", "svelte-c1prmq");
    			add_location(confirm_footer, file$3, 47, 2, 1425);
    			set_custom_element_data(confirm_content, "class", "svelte-c1prmq");
    			add_location(confirm_content, file$3, 41, 1, 1217);
    			set_custom_element_data(confirm_svlt, "show", /*isConfirmVisible*/ ctx[1]);
    			set_custom_element_data(confirm_svlt, "class", "svelte-c1prmq");
    			add_location(confirm_svlt, file$3, 40, 0, 1133);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, confirm_svlt, anchor);
    			append_dev(confirm_svlt, confirm_content);
    			append_dev(confirm_content, confirm_close);
    			append_dev(confirm_content, t1);
    			append_dev(confirm_content, confirm_title);
    			append_dev(confirm_title, t2);
    			append_dev(confirm_content, t3);
    			append_dev(confirm_content, confirm_body);
    			append_dev(confirm_body, t4);
    			append_dev(confirm_content, t5);
    			append_dev(confirm_content, confirm_footer);
    			append_dev(confirm_footer, button0);
    			mount_component(deleteicon, button0, null);
    			append_dev(button0, t6);
    			append_dev(confirm_footer, t7);
    			append_dev(confirm_footer, button1);
    			mount_component(checkicon, button1, null);
    			append_dev(button1, t8);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(confirm_close, "click", /*click_handler*/ ctx[7], false, false, false),
    					listen_dev(button0, "click", /*click_handler_1*/ ctx[8], false, false, false),
    					listen_dev(button1, "click", /*click_handler_2*/ ctx[9], false, false, false),
    					listen_dev(confirm_svlt, "click", /*click_handler_3*/ ctx[10], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*confirmState*/ 4) && t2_value !== (t2_value = /*confirmState*/ ctx[2].title + "")) set_data_dev(t2, t2_value);
    			if ((!current || dirty & /*confirmState*/ 4) && t4_value !== (t4_value = /*confirmState*/ ctx[2].textToConfirm + "")) set_data_dev(t4, t4_value);

    			if (!current || dirty & /*isConfirmVisible*/ 2) {
    				set_custom_element_data(confirm_svlt, "show", /*isConfirmVisible*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(deleteicon.$$.fragment, local);
    			transition_in(checkicon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(deleteicon.$$.fragment, local);
    			transition_out(checkicon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(confirm_svlt);
    			destroy_component(deleteicon);
    			destroy_component(checkicon);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let $keyPressed;
    	validate_store(keyPressed, 'keyPressed');
    	component_subscribe($$self, keyPressed, $$value => $$invalidate(6, $keyPressed = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ConfirmService', slots, []);
    	let isConfirmVisible = false;
    	let confirmState = { data: {}, textToConfirm: '', title: '' };
    	let deferredPromise = undefined;

    	function showConfirm(newState) {
    		return new Promise((resolve, reject) => {
    				$$invalidate(2, confirmState = newState);
    				deferredPromise = resolve;
    				$$invalidate(1, isConfirmVisible = true);
    			});
    	}

    	function closeConfirm() {
    		deferredPromise = undefined;
    		$$invalidate(1, isConfirmVisible = false);
    	}

    	function confirmConfirm() {
    		deferredPromise({ data: confirmState.data });
    	}

    	function handleOutsidePromptClick(e) {
    		let doCloseConfirm = true;

    		e.composedPath().forEach(element => {
    			if (element.tagName === 'CONFIRM-CONTENT') {
    				doCloseConfirm = false;
    			}
    		});

    		if (doCloseConfirm) closeConfirm();
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ConfirmService> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => closeConfirm();
    	const click_handler_1 = () => closeConfirm();
    	const click_handler_2 = () => confirmConfirm();
    	const click_handler_3 = e => handleOutsidePromptClick(e);

    	$$self.$capture_state = () => ({
    		CheckIcon,
    		DeleteIcon,
    		keyPressed,
    		isConfirmVisible,
    		confirmState,
    		deferredPromise,
    		showConfirm,
    		closeConfirm,
    		confirmConfirm,
    		handleOutsidePromptClick,
    		$keyPressed
    	});

    	$$self.$inject_state = $$props => {
    		if ('isConfirmVisible' in $$props) $$invalidate(1, isConfirmVisible = $$props.isConfirmVisible);
    		if ('confirmState' in $$props) $$invalidate(2, confirmState = $$props.confirmState);
    		if ('deferredPromise' in $$props) deferredPromise = $$props.deferredPromise;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$keyPressed, isConfirmVisible*/ 66) {
    			if ($keyPressed === 'Escape' && isConfirmVisible === true) closeConfirm();
    		}

    		if ($$self.$$.dirty & /*$keyPressed, isConfirmVisible*/ 66) {
    			if ($keyPressed === 'Enter' && isConfirmVisible === true) confirmConfirm();
    		}
    	};

    	return [
    		closeConfirm,
    		isConfirmVisible,
    		confirmState,
    		confirmConfirm,
    		handleOutsidePromptClick,
    		showConfirm,
    		$keyPressed,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3
    	];
    }

    class ConfirmService extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$4, create_fragment$4, safe_not_equal, { showConfirm: 5, closeConfirm: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ConfirmService",
    			options,
    			id: create_fragment$4.name
    		});
    	}

    	get showConfirm() {
    		return this.$$.ctx[5];
    	}

    	set showConfirm(value) {
    		throw new Error("<ConfirmService>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get closeConfirm() {
    		return this.$$.ctx[0];
    	}

    	set closeConfirm(value) {
    		throw new Error("<ConfirmService>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/svelte_services/RangeInputService.svelte generated by Svelte v3.49.0 */
    const file$2 = "src/svelte_services/RangeInputService.svelte";

    function create_fragment$3(ctx) {
    	let range_input_svlt;
    	let range_input_container;
    	let range_input_input_title;
    	let t0_value = /*rangeInputState*/ ctx[2].title + "";
    	let t0;
    	let t1;
    	let input;
    	let input_min_value;
    	let input_max_value;
    	let input_step_value;
    	let t2;
    	let range_input_steps_info;
    	let t3;
    	let shift_button;
    	let t5;
    	let t6;
    	let range_input_value;
    	let t7;
    	let t8;
    	let t9;
    	let range_input_buttons;
    	let button0;
    	let deleteicon;
    	let t10;
    	let t11_value = /*rangeInputState*/ ctx[2].cancelButtonText + "";
    	let t11;
    	let t12;
    	let button1;
    	let checkicon;
    	let t13;
    	let t14_value = /*rangeInputState*/ ctx[2].confirmButtonText + "";
    	let t14;
    	let button1_disabled_value;
    	let current;
    	let mounted;
    	let dispose;

    	deleteicon = new DeleteIcon({
    			props: {
    				style: "height:1rem;width:auto;fill:#fff;margin-right:0.25rem;"
    			},
    			$$inline: true
    		});

    	checkicon = new CheckIcon({
    			props: {
    				style: "height:1rem;width:auto;fill:#fff;margin-right:0.25rem;"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			range_input_svlt = element("range-input-svlt");
    			range_input_container = element("range-input-container");
    			range_input_input_title = element("range-input-input-title");
    			t0 = text(t0_value);
    			t1 = space();
    			input = element("input");
    			t2 = space();
    			range_input_steps_info = element("range-input-steps-info");
    			t3 = text("Hold ");
    			shift_button = element("shift-button");
    			shift_button.textContent = "⇧ Shift";
    			t5 = text(" to be more accurate");
    			t6 = space();
    			range_input_value = element("range-input-value");
    			t7 = text(/*rangeInputValue*/ ctx[1]);
    			t8 = text(" px");
    			t9 = space();
    			range_input_buttons = element("range-input-buttons");
    			button0 = element("button");
    			create_component(deleteicon.$$.fragment);
    			t10 = space();
    			t11 = text(t11_value);
    			t12 = space();
    			button1 = element("button");
    			create_component(checkicon.$$.fragment);
    			t13 = space();
    			t14 = text(t14_value);
    			set_custom_element_data(range_input_input_title, "class", "svelte-1vo00eh");
    			add_location(range_input_input_title, file$2, 65, 2, 1895);
    			attr_dev(input, "type", "range");
    			attr_dev(input, "min", input_min_value = /*rangeInputState*/ ctx[2].min);
    			attr_dev(input, "max", input_max_value = /*rangeInputState*/ ctx[2].max);

    			attr_dev(input, "step", input_step_value = /*$keyPressed*/ ctx[4] === 'Shift'
    			? /*rangeInputState*/ ctx[2].minStep
    			: /*rangeInputState*/ ctx[2].step);

    			attr_dev(input, "class", "svelte-1vo00eh");
    			add_location(input, file$2, 69, 2, 1980);
    			set_custom_element_data(shift_button, "class", "svelte-1vo00eh");
    			add_location(shift_button, file$2, 77, 31, 2213);
    			set_custom_element_data(range_input_steps_info, "class", "svelte-1vo00eh");
    			add_location(range_input_steps_info, file$2, 77, 2, 2184);
    			set_custom_element_data(range_input_value, "class", "svelte-1vo00eh");
    			add_location(range_input_value, file$2, 79, 2, 2298);
    			attr_dev(button0, "class", "cancel svelte-1vo00eh");
    			add_location(button0, file$2, 82, 3, 2386);
    			attr_dev(button1, "class", "info");
    			button1.disabled = button1_disabled_value = /*rangeInputValue*/ ctx[1] === /*rangeInputState*/ ctx[2].value;
    			add_location(button1, file$2, 86, 3, 2582);
    			set_custom_element_data(range_input_buttons, "class", "svelte-1vo00eh");
    			add_location(range_input_buttons, file$2, 81, 2, 2361);
    			set_custom_element_data(range_input_container, "class", "svelte-1vo00eh");
    			add_location(range_input_container, file$2, 64, 1, 1869);
    			set_custom_element_data(range_input_svlt, "show", /*isRangeInputVisible*/ ctx[3]);
    			set_custom_element_data(range_input_svlt, "class", "svelte-1vo00eh");
    			add_location(range_input_svlt, file$2, 63, 0, 1822);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, range_input_svlt, anchor);
    			append_dev(range_input_svlt, range_input_container);
    			append_dev(range_input_container, range_input_input_title);
    			append_dev(range_input_input_title, t0);
    			append_dev(range_input_container, t1);
    			append_dev(range_input_container, input);
    			set_input_value(input, /*rangeInputValue*/ ctx[1]);
    			append_dev(range_input_container, t2);
    			append_dev(range_input_container, range_input_steps_info);
    			append_dev(range_input_steps_info, t3);
    			append_dev(range_input_steps_info, shift_button);
    			append_dev(range_input_steps_info, t5);
    			append_dev(range_input_container, t6);
    			append_dev(range_input_container, range_input_value);
    			append_dev(range_input_value, t7);
    			append_dev(range_input_value, t8);
    			append_dev(range_input_container, t9);
    			append_dev(range_input_container, range_input_buttons);
    			append_dev(range_input_buttons, button0);
    			mount_component(deleteicon, button0, null);
    			append_dev(button0, t10);
    			append_dev(button0, t11);
    			append_dev(range_input_buttons, t12);
    			append_dev(range_input_buttons, button1);
    			mount_component(checkicon, button1, null);
    			append_dev(button1, t13);
    			append_dev(button1, t14);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "change", /*input_change_input_handler*/ ctx[7]),
    					listen_dev(input, "input", /*input_change_input_handler*/ ctx[7]),
    					listen_dev(button0, "click", /*click_handler*/ ctx[8], false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[9], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*rangeInputState*/ 4) && t0_value !== (t0_value = /*rangeInputState*/ ctx[2].title + "")) set_data_dev(t0, t0_value);

    			if (!current || dirty & /*rangeInputState*/ 4 && input_min_value !== (input_min_value = /*rangeInputState*/ ctx[2].min)) {
    				attr_dev(input, "min", input_min_value);
    			}

    			if (!current || dirty & /*rangeInputState*/ 4 && input_max_value !== (input_max_value = /*rangeInputState*/ ctx[2].max)) {
    				attr_dev(input, "max", input_max_value);
    			}

    			if (!current || dirty & /*$keyPressed, rangeInputState*/ 20 && input_step_value !== (input_step_value = /*$keyPressed*/ ctx[4] === 'Shift'
    			? /*rangeInputState*/ ctx[2].minStep
    			: /*rangeInputState*/ ctx[2].step)) {
    				attr_dev(input, "step", input_step_value);
    			}

    			if (dirty & /*rangeInputValue*/ 2) {
    				set_input_value(input, /*rangeInputValue*/ ctx[1]);
    			}

    			if (!current || dirty & /*rangeInputValue*/ 2) set_data_dev(t7, /*rangeInputValue*/ ctx[1]);
    			if ((!current || dirty & /*rangeInputState*/ 4) && t11_value !== (t11_value = /*rangeInputState*/ ctx[2].cancelButtonText + "")) set_data_dev(t11, t11_value);
    			if ((!current || dirty & /*rangeInputState*/ 4) && t14_value !== (t14_value = /*rangeInputState*/ ctx[2].confirmButtonText + "")) set_data_dev(t14, t14_value);

    			if (!current || dirty & /*rangeInputValue, rangeInputState*/ 6 && button1_disabled_value !== (button1_disabled_value = /*rangeInputValue*/ ctx[1] === /*rangeInputState*/ ctx[2].value)) {
    				prop_dev(button1, "disabled", button1_disabled_value);
    			}

    			if (!current || dirty & /*isRangeInputVisible*/ 8) {
    				set_custom_element_data(range_input_svlt, "show", /*isRangeInputVisible*/ ctx[3]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(deleteicon.$$.fragment, local);
    			transition_in(checkicon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(deleteicon.$$.fragment, local);
    			transition_out(checkicon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(range_input_svlt);
    			destroy_component(deleteicon);
    			destroy_component(checkicon);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let $keyPressed;
    	validate_store(keyPressed, 'keyPressed');
    	component_subscribe($$self, keyPressed, $$value => $$invalidate(4, $keyPressed = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('RangeInputService', slots, []);
    	let isRangeInputVisible = false;
    	let rangeInputValue = 0;

    	let rangeInputState = {
    		title: '',
    		min: 0,
    		value: 0,
    		max: 100,
    		step: 1,
    		minStep: 1,
    		cancelButtonText: '',
    		confirmButtonText: '',
    		onChange: () => {
    			
    		},
    		onConfirm: () => {
    			
    		},
    		onCancel: () => {
    			
    		}
    	};

    	function setRangeInputValueBind(state) {
    		if ((state === null || state === void 0
    		? void 0
    		: state.value) !== undefined) {
    			$$invalidate(1, rangeInputValue = state.value);
    		}
    	}

    	function sendNewValue() {
    		if (rangeInputState.onChange !== undefined) {
    			rangeInputState.onChange(rangeInputValue);
    		}
    	}

    	function showRangeInput(newState) {
    		$$invalidate(2, rangeInputState = newState);
    		$$invalidate(3, isRangeInputVisible = true);
    	}

    	function closeRangeInput() {
    		// If User did NOT change value then set it to previous value.
    		if (rangeInputValue !== rangeInputState.value) {
    			rangeInputState.onCancel(rangeInputState.value);
    		}

    		$$invalidate(3, isRangeInputVisible = false);
    	}

    	function confirmRangeInput() {
    		$$invalidate(2, rangeInputState.value = rangeInputValue, rangeInputState);
    		rangeInputState.onConfirm(rangeInputValue);
    		$$invalidate(3, isRangeInputVisible = false);
    	}

    	onMount(() => {
    		setTimeout(
    			() => {
    				// Prevents the container to animate when app is loading.
    				let rangeInputContainer = document.querySelector('range-input-container');

    				if (rangeInputContainer) {
    					rangeInputContainer.setAttribute('style', 'transition: transform 300ms cubic-bezier(0.68, -0.55, 0.265, 1.55);');
    				}
    			},
    			1000
    		);
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<RangeInputService> was created with unknown prop '${key}'`);
    	});

    	function input_change_input_handler() {
    		rangeInputValue = to_number(this.value);
    		$$invalidate(1, rangeInputValue);
    	}

    	const click_handler = () => closeRangeInput();
    	const click_handler_1 = () => confirmRangeInput();

    	$$self.$capture_state = () => ({
    		onMount,
    		CheckIcon,
    		DeleteIcon,
    		keyPressed,
    		isRangeInputVisible,
    		rangeInputValue,
    		rangeInputState,
    		setRangeInputValueBind,
    		sendNewValue,
    		showRangeInput,
    		closeRangeInput,
    		confirmRangeInput,
    		$keyPressed
    	});

    	$$self.$inject_state = $$props => {
    		if ('isRangeInputVisible' in $$props) $$invalidate(3, isRangeInputVisible = $$props.isRangeInputVisible);
    		if ('rangeInputValue' in $$props) $$invalidate(1, rangeInputValue = $$props.rangeInputValue);
    		if ('rangeInputState' in $$props) $$invalidate(2, rangeInputState = $$props.rangeInputState);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*rangeInputValue*/ 2) {
    			{
    				sendNewValue();
    			}
    		}

    		if ($$self.$$.dirty & /*rangeInputState*/ 4) {
    			{
    				setRangeInputValueBind(rangeInputState);
    			}
    		}
    	};

    	return [
    		closeRangeInput,
    		rangeInputValue,
    		rangeInputState,
    		isRangeInputVisible,
    		$keyPressed,
    		confirmRangeInput,
    		showRangeInput,
    		input_change_input_handler,
    		click_handler,
    		click_handler_1
    	];
    }

    class RangeInputService extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, { showRangeInput: 6, closeRangeInput: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "RangeInputService",
    			options,
    			id: create_fragment$3.name
    		});
    	}

    	get showRangeInput() {
    		return this.$$.ctx[6];
    	}

    	set showRangeInput(value) {
    		throw new Error("<RangeInputService>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get closeRangeInput() {
    		return this.$$.ctx[0];
    	}

    	set closeRangeInput(value) {
    		throw new Error("<RangeInputService>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/svelte_services/StorageService.svelte generated by Svelte v3.49.0 */

    const { console: console_1 } = globals;

    function create_fragment$2(ctx) {
    	const block = {
    		c: noop,
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    async function addSong(song) {
    	try {
    		// let dbSong = await getSongById(song.ID)
    		let dbSong = undefined;

    		if (dbSong === undefined) {
    			addSong(song);
    		} // TODO: Update song
    		// await db.update(song)
    	} catch(e) {
    		console.log(`Failed to add ${song.Title}.`);
    	}
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('StorageService', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<StorageService> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ addSong });
    	return [addSong];
    }

    class StorageService extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, { addSong: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "StorageService",
    			options,
    			id: create_fragment$2.name
    		});
    	}

    	get addSong() {
    		return addSong;
    	}

    	set addSong(value) {
    		throw new Error("<StorageService>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function parseLyricsFn (lyrics, lyricsContainerElement) {
        lyricsContainerElement.innerHTML = '';
        let lyricsLines = lyrics.split('\n');
        lyricsLines.forEach(line => {
            let paragraphElement = document.createElement('p');
            paragraphElement.innerHTML = line;
            lyricsContainerElement.appendChild(paragraphElement);
        });
    }

    /* src/layouts/lyrics/!LyricsLayout.svelte generated by Svelte v3.49.0 */
    const file$1 = "src/layouts/lyrics/!LyricsLayout.svelte";

    // (58:2) {:else}
    function create_else_block(ctx) {
    	let lyrics_container;

    	const block = {
    		c: function create() {
    			lyrics_container = element("lyrics-container");
    			set_custom_element_data(lyrics_container, "class", "svelte-1fxog6n");
    			add_location(lyrics_container, file$1, 58, 3, 1731);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, lyrics_container, anchor);
    			/*lyrics_container_binding*/ ctx[8](lyrics_container);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(lyrics_container);
    			/*lyrics_container_binding*/ ctx[8](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(58:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (56:2) {#if isEditModeOn === true}
    function create_if_block$1(ctx) {
    	let textarea;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			textarea = element("textarea");
    			attr_dev(textarea, "class", "svelte-1fxog6n");
    			add_location(textarea, file$1, 56, 3, 1681);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, textarea, anchor);
    			set_input_value(textarea, /*lyricsText*/ ctx[1]);

    			if (!mounted) {
    				dispose = listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[7]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*lyricsText*/ 2) {
    				set_input_value(textarea, /*lyricsText*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(textarea);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(56:2) {#if isEditModeOn === true}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1(ctx) {
    	let lyrics_layout;
    	let lyrics_layout_header;
    	let song_information;
    	let t0_value = `${/*$playingSongStore*/ ctx[0]?.Title} by ${/*$playingSongStore*/ ctx[0]?.Artist}` + "";
    	let t0;
    	let t1;
    	let lyrics_controls;
    	let event_wrapper0;
    	let updateicon;
    	let t2;
    	let event_wrapper1;
    	let saveicon;
    	let t3;
    	let lyrics_layout_body;
    	let current;
    	let mounted;
    	let dispose;

    	updateicon = new UpdateIcon({
    			props: {
    				style: "height: 1.5rem;fill:var(--color-bg-1)"
    			},
    			$$inline: true
    		});

    	saveicon = new SaveIcon({
    			props: {
    				style: "height: 1.5rem;fill:var(--color-bg-1)"
    			},
    			$$inline: true
    		});

    	function select_block_type(ctx, dirty) {
    		if (/*isEditModeOn*/ ctx[2] === true) return create_if_block$1;
    		return create_else_block;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			lyrics_layout = element("lyrics-layout");
    			lyrics_layout_header = element("lyrics-layout-header");
    			song_information = element("song-information");
    			t0 = text(t0_value);
    			t1 = space();
    			lyrics_controls = element("lyrics-controls");
    			event_wrapper0 = element("event-wrapper");
    			create_component(updateicon.$$.fragment);
    			t2 = space();
    			event_wrapper1 = element("event-wrapper");
    			create_component(saveicon.$$.fragment);
    			t3 = space();
    			lyrics_layout_body = element("lyrics-layout-body");
    			if_block.c();
    			set_custom_element_data(song_information, "class", "svelte-1fxog6n");
    			add_location(song_information, file$1, 40, 2, 1166);
    			set_custom_element_data(event_wrapper0, "class", "svelte-1fxog6n");
    			add_location(event_wrapper0, file$1, 45, 3, 1298);
    			set_custom_element_data(event_wrapper1, "class", "svelte-1fxog6n");
    			add_location(event_wrapper1, file$1, 48, 3, 1450);
    			set_custom_element_data(lyrics_controls, "class", "svelte-1fxog6n");
    			add_location(lyrics_controls, file$1, 44, 2, 1277);
    			set_custom_element_data(lyrics_layout_header, "class", "svelte-1fxog6n");
    			add_location(lyrics_layout_header, file$1, 39, 1, 1141);
    			set_custom_element_data(lyrics_layout_body, "class", "svelte-1fxog6n");
    			add_location(lyrics_layout_body, file$1, 54, 1, 1627);
    			set_custom_element_data(lyrics_layout, "class", "layout svelte-1fxog6n");
    			add_location(lyrics_layout, file$1, 38, 0, 1109);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, lyrics_layout, anchor);
    			append_dev(lyrics_layout, lyrics_layout_header);
    			append_dev(lyrics_layout_header, song_information);
    			append_dev(song_information, t0);
    			append_dev(lyrics_layout_header, t1);
    			append_dev(lyrics_layout_header, lyrics_controls);
    			append_dev(lyrics_controls, event_wrapper0);
    			mount_component(updateicon, event_wrapper0, null);
    			append_dev(lyrics_controls, t2);
    			append_dev(lyrics_controls, event_wrapper1);
    			mount_component(saveicon, event_wrapper1, null);
    			append_dev(lyrics_layout, t3);
    			append_dev(lyrics_layout, lyrics_layout_body);
    			if_block.m(lyrics_layout_body, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(event_wrapper0, "click", /*click_handler*/ ctx[5], false, false, false),
    					listen_dev(event_wrapper1, "click", /*click_handler_1*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*$playingSongStore*/ 1) && t0_value !== (t0_value = `${/*$playingSongStore*/ ctx[0]?.Title} by ${/*$playingSongStore*/ ctx[0]?.Artist}` + "")) set_data_dev(t0, t0_value);

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(lyrics_layout_body, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(updateicon.$$.fragment, local);
    			transition_in(saveicon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(updateicon.$$.fragment, local);
    			transition_out(saveicon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(lyrics_layout);
    			destroy_component(updateicon);
    			destroy_component(saveicon);
    			if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let $playingSongStore;
    	validate_store(playingSongStore, 'playingSongStore');
    	component_subscribe($$self, playingSongStore, $$value => $$invalidate(0, $playingSongStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('LyricsLayout', slots, []);
    	let lyricsText = '';
    	let isEditModeOn = false;
    	let lyricsContainer;

    	function saveLyrics() {
    		window.ipc.saveLyrics(lyricsText, $playingSongStore.Title, $playingSongStore.Artist, $playingSongStore.Duration).then(response => {
    			notifyService.success(response);
    		}).catch(err => {
    			notifyService.error(String(err));
    		});
    	}

    	function loadLyrics() {
    		window.ipc.getLyrics($playingSongStore.Title, $playingSongStore.Artist, $playingSongStore.Duration).then(lyrics => {
    			$$invalidate(1, lyricsText = lyrics);
    			parseLyricsFn(lyrics, lyricsContainer);
    		}).catch(err => {
    			notifyService.error(String(err));
    		});
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<LyricsLayout> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => $$invalidate(2, isEditModeOn = !isEditModeOn);
    	const click_handler_1 = () => saveLyrics();

    	function textarea_input_handler() {
    		lyricsText = this.value;
    		$$invalidate(1, lyricsText);
    	}

    	function lyrics_container_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			lyricsContainer = $$value;
    			$$invalidate(3, lyricsContainer);
    		});
    	}

    	$$self.$capture_state = () => ({
    		parseLyricsFn,
    		SaveIcon,
    		UpdateIcon,
    		notifyService,
    		playingSongStore,
    		lyricsText,
    		isEditModeOn,
    		lyricsContainer,
    		saveLyrics,
    		loadLyrics,
    		$playingSongStore
    	});

    	$$self.$inject_state = $$props => {
    		if ('lyricsText' in $$props) $$invalidate(1, lyricsText = $$props.lyricsText);
    		if ('isEditModeOn' in $$props) $$invalidate(2, isEditModeOn = $$props.isEditModeOn);
    		if ('lyricsContainer' in $$props) $$invalidate(3, lyricsContainer = $$props.lyricsContainer);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$playingSongStore*/ 1) {
    			{
    				if ($playingSongStore) {
    					loadLyrics();
    				}
    			}
    		}
    	};

    	return [
    		$playingSongStore,
    		lyricsText,
    		isEditModeOn,
    		lyricsContainer,
    		saveLyrics,
    		click_handler,
    		click_handler_1,
    		textarea_input_handler,
    		lyrics_container_binding
    	];
    }

    class LyricsLayout extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LyricsLayout",
    			options,
    			id: create_fragment$1.name
    		});
    	}
    }

    /* src/App.svelte generated by Svelte v3.49.0 */
    const file = "src/App.svelte";

    // (64:39) 
    function create_if_block_3(ctx) {
    	let lyricslayout;
    	let current;
    	lyricslayout = new LyricsLayout({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(lyricslayout.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(lyricslayout, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(lyricslayout.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(lyricslayout.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(lyricslayout, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(64:39) ",
    		ctx
    	});

    	return block;
    }

    // (62:41) 
    function create_if_block_2(ctx) {
    	let playbacklayout;
    	let current;
    	playbacklayout = new PlaybackLayout({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(playbacklayout.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(playbacklayout, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(playbacklayout.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(playbacklayout.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(playbacklayout, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(62:41) ",
    		ctx
    	});

    	return block;
    }

    // (60:39) 
    function create_if_block_1(ctx) {
    	let configlayout;
    	let current;
    	configlayout = new ConfigLayout({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(configlayout.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(configlayout, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(configlayout.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(configlayout.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(configlayout, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(60:39) ",
    		ctx
    	});

    	return block;
    }

    // (58:2) {#if $layoutToShow === 'Library'}
    function create_if_block(ctx) {
    	let librarylayout;
    	let current;
    	librarylayout = new LibraryLayout({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(librarylayout.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(librarylayout, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(librarylayout.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(librarylayout.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(librarylayout, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(58:2) {#if $layoutToShow === 'Library'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment(ctx) {
    	let title_value;
    	let t0;
    	let ipcmiddleware;
    	let t1;
    	let playermiddleware;
    	let t2;
    	let equalizermiddleware;
    	let t3;
    	let eventshandlermiddleware;
    	let t4;
    	let audioplayer;
    	let t5;
    	let main_app;
    	let navigation;
    	let t6;
    	let controlbar;
    	let t7;
    	let statusbar;
    	let t8;
    	let current_window_svlt;
    	let current_block_type_index;
    	let if_block;
    	let t9;
    	let equalizerservice;
    	let t10;
    	let promptservice;
    	let t11;
    	let confirmservice;
    	let t12;
    	let rangeinputservice;
    	let t13;
    	let storageservice;
    	let current;
    	document.title = title_value = /*$appTitle*/ ctx[0];
    	ipcmiddleware = new IpcMiddleware({ $$inline: true });
    	playermiddleware = new PlayerMiddleware({ $$inline: true });
    	equalizermiddleware = new EqualizerMiddleware({ $$inline: true });
    	eventshandlermiddleware = new EventsHandlerMiddleware({ $$inline: true });
    	audioplayer = new AudioPlayer({ $$inline: true });
    	navigation = new Navigation({ $$inline: true });
    	controlbar = new ControlBar({ $$inline: true });
    	statusbar = new StatusBar({ $$inline: true });
    	const if_block_creators = [create_if_block, create_if_block_1, create_if_block_2, create_if_block_3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$layoutToShow*/ ctx[1] === 'Library') return 0;
    		if (/*$layoutToShow*/ ctx[1] === 'Config') return 1;
    		if (/*$layoutToShow*/ ctx[1] === 'Playback') return 2;
    		if (/*$layoutToShow*/ ctx[1] === 'Lyrics') return 3;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	let equalizerservice_props = {};

    	equalizerservice = new EqualizerService({
    			props: equalizerservice_props,
    			$$inline: true
    		});

    	/*equalizerservice_binding*/ ctx[7](equalizerservice);
    	let promptservice_props = {};

    	promptservice = new PromptService({
    			props: promptservice_props,
    			$$inline: true
    		});

    	/*promptservice_binding*/ ctx[8](promptservice);
    	let confirmservice_props = {};

    	confirmservice = new ConfirmService({
    			props: confirmservice_props,
    			$$inline: true
    		});

    	/*confirmservice_binding*/ ctx[9](confirmservice);
    	let rangeinputservice_props = {};

    	rangeinputservice = new RangeInputService({
    			props: rangeinputservice_props,
    			$$inline: true
    		});

    	/*rangeinputservice_binding*/ ctx[10](rangeinputservice);
    	let storageservice_props = {};

    	storageservice = new StorageService({
    			props: storageservice_props,
    			$$inline: true
    		});

    	/*storageservice_binding*/ ctx[11](storageservice);

    	const block = {
    		c: function create() {
    			t0 = space();
    			create_component(ipcmiddleware.$$.fragment);
    			t1 = space();
    			create_component(playermiddleware.$$.fragment);
    			t2 = space();
    			create_component(equalizermiddleware.$$.fragment);
    			t3 = space();
    			create_component(eventshandlermiddleware.$$.fragment);
    			t4 = space();
    			create_component(audioplayer.$$.fragment);
    			t5 = space();
    			main_app = element("main-app");
    			create_component(navigation.$$.fragment);
    			t6 = space();
    			create_component(controlbar.$$.fragment);
    			t7 = space();
    			create_component(statusbar.$$.fragment);
    			t8 = space();
    			current_window_svlt = element("current-window-svlt");
    			if (if_block) if_block.c();
    			t9 = space();
    			create_component(equalizerservice.$$.fragment);
    			t10 = space();
    			create_component(promptservice.$$.fragment);
    			t11 = space();
    			create_component(confirmservice.$$.fragment);
    			t12 = space();
    			create_component(rangeinputservice.$$.fragment);
    			t13 = space();
    			create_component(storageservice.$$.fragment);
    			set_custom_element_data(current_window_svlt, "class", "svelte-gvvlpk");
    			add_location(current_window_svlt, file, 56, 1, 2300);
    			set_custom_element_data(main_app, "class", "svelte-gvvlpk");
    			add_location(main_app, file, 51, 0, 2240);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			mount_component(ipcmiddleware, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(playermiddleware, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(equalizermiddleware, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(eventshandlermiddleware, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(audioplayer, target, anchor);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, main_app, anchor);
    			mount_component(navigation, main_app, null);
    			append_dev(main_app, t6);
    			mount_component(controlbar, main_app, null);
    			append_dev(main_app, t7);
    			mount_component(statusbar, main_app, null);
    			append_dev(main_app, t8);
    			append_dev(main_app, current_window_svlt);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(current_window_svlt, null);
    			}

    			insert_dev(target, t9, anchor);
    			mount_component(equalizerservice, target, anchor);
    			insert_dev(target, t10, anchor);
    			mount_component(promptservice, target, anchor);
    			insert_dev(target, t11, anchor);
    			mount_component(confirmservice, target, anchor);
    			insert_dev(target, t12, anchor);
    			mount_component(rangeinputservice, target, anchor);
    			insert_dev(target, t13, anchor);
    			mount_component(storageservice, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*$appTitle*/ 1) && title_value !== (title_value = /*$appTitle*/ ctx[0])) {
    				document.title = title_value;
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					}

    					transition_in(if_block, 1);
    					if_block.m(current_window_svlt, null);
    				} else {
    					if_block = null;
    				}
    			}

    			const equalizerservice_changes = {};
    			equalizerservice.$set(equalizerservice_changes);
    			const promptservice_changes = {};
    			promptservice.$set(promptservice_changes);
    			const confirmservice_changes = {};
    			confirmservice.$set(confirmservice_changes);
    			const rangeinputservice_changes = {};
    			rangeinputservice.$set(rangeinputservice_changes);
    			const storageservice_changes = {};
    			storageservice.$set(storageservice_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(ipcmiddleware.$$.fragment, local);
    			transition_in(playermiddleware.$$.fragment, local);
    			transition_in(equalizermiddleware.$$.fragment, local);
    			transition_in(eventshandlermiddleware.$$.fragment, local);
    			transition_in(audioplayer.$$.fragment, local);
    			transition_in(navigation.$$.fragment, local);
    			transition_in(controlbar.$$.fragment, local);
    			transition_in(statusbar.$$.fragment, local);
    			transition_in(if_block);
    			transition_in(equalizerservice.$$.fragment, local);
    			transition_in(promptservice.$$.fragment, local);
    			transition_in(confirmservice.$$.fragment, local);
    			transition_in(rangeinputservice.$$.fragment, local);
    			transition_in(storageservice.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(ipcmiddleware.$$.fragment, local);
    			transition_out(playermiddleware.$$.fragment, local);
    			transition_out(equalizermiddleware.$$.fragment, local);
    			transition_out(eventshandlermiddleware.$$.fragment, local);
    			transition_out(audioplayer.$$.fragment, local);
    			transition_out(navigation.$$.fragment, local);
    			transition_out(controlbar.$$.fragment, local);
    			transition_out(statusbar.$$.fragment, local);
    			transition_out(if_block);
    			transition_out(equalizerservice.$$.fragment, local);
    			transition_out(promptservice.$$.fragment, local);
    			transition_out(confirmservice.$$.fragment, local);
    			transition_out(rangeinputservice.$$.fragment, local);
    			transition_out(storageservice.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			destroy_component(ipcmiddleware, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(playermiddleware, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(equalizermiddleware, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(eventshandlermiddleware, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(audioplayer, detaching);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(main_app);
    			destroy_component(navigation);
    			destroy_component(controlbar);
    			destroy_component(statusbar);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d();
    			}

    			if (detaching) detach_dev(t9);
    			/*equalizerservice_binding*/ ctx[7](null);
    			destroy_component(equalizerservice, detaching);
    			if (detaching) detach_dev(t10);
    			/*promptservice_binding*/ ctx[8](null);
    			destroy_component(promptservice, detaching);
    			if (detaching) detach_dev(t11);
    			/*confirmservice_binding*/ ctx[9](null);
    			destroy_component(confirmservice, detaching);
    			if (detaching) detach_dev(t12);
    			/*rangeinputservice_binding*/ ctx[10](null);
    			destroy_component(rangeinputservice, detaching);
    			if (detaching) detach_dev(t13);
    			/*storageservice_binding*/ ctx[11](null);
    			destroy_component(storageservice, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let $dbSongsStore;
    	let $appTitle;
    	let $layoutToShow;
    	let $equalizerService;
    	let $promptService;
    	let $confirmService;
    	let $rangeInputService;
    	let $storageService;
    	validate_store(dbSongsStore, 'dbSongsStore');
    	component_subscribe($$self, dbSongsStore, $$value => $$invalidate(12, $dbSongsStore = $$value));
    	validate_store(appTitle, 'appTitle');
    	component_subscribe($$self, appTitle, $$value => $$invalidate(0, $appTitle = $$value));
    	validate_store(layoutToShow, 'layoutToShow');
    	component_subscribe($$self, layoutToShow, $$value => $$invalidate(1, $layoutToShow = $$value));
    	validate_store(equalizerService, 'equalizerService');
    	component_subscribe($$self, equalizerService, $$value => $$invalidate(2, $equalizerService = $$value));
    	validate_store(promptService, 'promptService');
    	component_subscribe($$self, promptService, $$value => $$invalidate(3, $promptService = $$value));
    	validate_store(confirmService, 'confirmService');
    	component_subscribe($$self, confirmService, $$value => $$invalidate(4, $confirmService = $$value));
    	validate_store(rangeInputService, 'rangeInputService');
    	component_subscribe($$self, rangeInputService, $$value => $$invalidate(5, $rangeInputService = $$value));
    	validate_store(storageService, 'storageService');
    	component_subscribe($$self, storageService, $$value => $$invalidate(6, $storageService = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('App', slots, []);

    	liveQuery(async () => {
    		return await getDB().songs.toArray();
    	}).subscribe(songs => {
    		set_store_value(dbSongsStore, $dbSongsStore = songs, $dbSongsStore);
    	});

    	onMount(() => {
    		onAppMountedService();
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	function equalizerservice_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$equalizerService = $$value;
    			equalizerService.set($equalizerService);
    		});
    	}

    	function promptservice_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$promptService = $$value;
    			promptService.set($promptService);
    		});
    	}

    	function confirmservice_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$confirmService = $$value;
    			confirmService.set($confirmService);
    		});
    	}

    	function rangeinputservice_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$rangeInputService = $$value;
    			rangeInputService.set($rangeInputService);
    		});
    	}

    	function storageservice_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$storageService = $$value;
    			storageService.set($storageService);
    		});
    	}

    	$$self.$capture_state = () => ({
    		onMount,
    		liveQuery,
    		onAppMountedService,
    		IpcMiddleware,
    		PlayerMiddleware,
    		EqualizerMiddleware,
    		AudioPlayer,
    		Navigation,
    		ControlBar,
    		StatusBar,
    		LibraryLayout,
    		ConfigLayout,
    		EventsHandlerMiddleware,
    		getDB,
    		dbSongsStore,
    		appTitle,
    		layoutToShow,
    		PlaybackLayout,
    		equalizerService,
    		confirmService,
    		promptService,
    		rangeInputService,
    		storageService,
    		EqualizerService,
    		PromptService,
    		ConfirmService,
    		RangeInputService,
    		StorageService,
    		LyricsLayout,
    		$dbSongsStore,
    		$appTitle,
    		$layoutToShow,
    		$equalizerService,
    		$promptService,
    		$confirmService,
    		$rangeInputService,
    		$storageService
    	});

    	return [
    		$appTitle,
    		$layoutToShow,
    		$equalizerService,
    		$promptService,
    		$confirmService,
    		$rangeInputService,
    		$storageService,
    		equalizerservice_binding,
    		promptservice_binding,
    		confirmservice_binding,
    		rangeinputservice_binding,
    		storageservice_binding
    	];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance, create_fragment, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment.name
    		});
    	}
    }

    async function loadApp() {
        config.set(await window.ipc.getConfig());
        return new App({
            target: document.body
        });
    }
    var main = loadApp();

    return main;

})();
//# sourceMappingURL=bundle.js.map
